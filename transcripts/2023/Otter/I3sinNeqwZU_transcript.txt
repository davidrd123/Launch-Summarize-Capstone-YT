foreign hello everyone welcome and thank you for being here today we will be presenting otter a cloud native framework for peer-to-peer video communication within web applications my name is Connor and these are my colleagues Chris Max and Kush we created otter together over the last couple months and we're excited to share our application here with you today so to get us started we'll first get an overview of video calling and the design decisions that a developer might have to consider when implementing video calling next we'll go in depth into the topic of webrtc what it is why a developer would want to use it and for the developer who does want to use it what available Solutions exist next we'll explain how we designed otter with the current available Solutions in mind we'll discuss otters architecture and show a short demo we'll bring up the engineering challenges we face while designing otter discuss what we want to implement in the future and then at the very end we'll open the floor to questions so to begin let's first hone in on the domain in which otter whips and that's video calling and the last few years especially we've seen the relevance of video calling Skyrocket from Telehealth to online classes virtual business meetings video calling is more popular now than ever and so naturally it's not surprising that developers are increasingly interested in implementing video calling functionality into their application so for the developer who wants to add video calling to their application what needs to be considered well different use cases are going to Warrant different design decisions that's how a health video calling application might look very different than a video calling application for online classes however one design decision that should be considered is a trade-offs between two major Network models client server versus peer-to-peer and for people who are not familiar here's just a quick introduction to these models in a peer-to-peer Network shown on the left devices are able to communicate directly with each other without the need for a central server and this is contrasted with a traditional client server model shown on the right in which devices connect to a central server and the server manages the communication between the devices so in the context of excuse me video calling why does any of this matter well a peer-to-peer Network can bring multiple benefits over a client server Network in the context of video calls for example a peer-to-peer Network can yield increased privacy for the end users since in a client server model data will have to pass through a server and the data can be monitored as it's passing through the server since peer-to-peer networks eliminate the need for a server they therefore eliminate this possibility thus increasing the Privacy for the end users a peer-to-peer Network can also lead to decreased latency between peers since with the client server model data has to stop at the server before being sent to its destination if you take out the central server data is able to travel directly from one period to the other and this can reduce latency for the end users and for a video call being low latency is something that's super important to ensuring that the call appears as real time and responsive as possible and we'll discuss latency a little more later a peer-to-peer Network can also bring increased Network resilience since in a client server model a central server represents a single point of failure if the server goes down then peers can no longer video call but a peer-to-peer network doesn't have this problem since each peer is responsible for transporting video data to the other peers there's no Central server that has to shoulder this entire burden finally a peer-to-peer Network can also be more cost effective since cutting out a central server means the developer doesn't have to pay to provision or maintain these servers the main downside of peer-to-peer in the context of video calling is call size so as you can see in our purple peer-to-peer diagram right now we have just one peer connected to one other peer however let's see what happens if we try to add more peers to the call so in its simplest form a peer-to-peer Network requires that every single peer in the network connects to every other peer in the network and so in a peer-to-peer video call with six peers each peer has to send its video data in five different directions and has to process five separate incoming video streams from the other peers since the burden of transporting data to the other peers in a peer-to-peer network is placed on the individual devices this means that call sizes have to remain small otherwise the individual devices will become overwhelmed with having to send and receive so many different video streams this problem doesn't really happen in a client server model as you can see on the right since each device only has to communicate with one other entity the central server what this means is typically a peer-to-peer call might be able to support up to around five or six people and this leads us into the benefits of the client server model greater call size because the server is managing the connections between peers video calls are able to support many more participants under a client server model and this is mainly because the server is under the developer's control and so the developer can scale the hardware of the server or potentially even scale to multiple servers in order to handle increased call sizes another notable benefit that you get from the client server model is real-time processing abilities for example the ability to record a call apply real-time closed captions or facial recognition or even use an AI note taker so both of these Network models have their respective use cases for video calling a client server model would likely be a more effective choice for a developer who needs to support call sizes of more than a few people or who needs additional features like the ability to record calls and so this model could make sense for a developer who wants to implement video calling for online classes to support large business meetings or who needs to record video calls that can be reviewed later for training purposes however for a developer working on an application where privacy is of the utmost importance a peer-to-peer model would be a better fit for example Telehealth calls or virtual legal consultations are situations where calls will often contain sensitive information and so the Privacy that you gain by removing a central server which can process and monitor your Communications is a notable benefit also the private nature of these calls means that call sizes will usually never be larger than a few people and so the fact that peer-to-peer calls can only support a few participants might not be a limiting factor here so for the developer who wants to add peer-to-peer video calling to their application what else needs to be considered what other design decisions can affect the end user experience as we started to mention before an important aspect that makes video calls feel responsive is latency or in other words how long data takes to travel from its origin to its destination in a real-time video call a higher latency will result in a longer delay between when one person speaks or moves and when the other person hears or sees that and so a high latency can make it difficult to feel like you could have a natural conversation and in its worst form it can feel like you're reacting to something that already happened several seconds ago so from the perspective of a developer how do we design our video calling application in a way that minimizes latency well latency can actually be affected by how data is transmitted over the network so next let's go ahead and explore the trade-offs of implementing real-time video using TCP or transmission control protocol versus UDP or user datagram protocol and just as a brief introduction TCP and UDP are both protocols that specify how data should be sent over the network TCP is a protocol that's designed to make data transmission across the network reliable and it does this by ensuring a connection has to be established before sending data provides guarantees the data has been delivered and TCP will retransmit data if any data is lost along the way However the fact that TCP provides these guarantees and re-transmission mechanisms actually increases latency on the other hand UDP is a protocol that doesn't offer this type of reliability but instead offers speed UDP doesn't have to establish a connection in order to send data and it doesn't provide any guarantees or re-transmission mechanisms but this is actually perfect for video data transmission because as we discussed before we want latency to be as low as possible to ensure that a video call feels real time and so it's okay if a little data gets lost and the call lags for a split second as long as in general the call is fast responsive and has the most up-to-date data so we've established the need for a UDP base peer-to-peer video calling solution for example for our developer who wants to implement video calling for Telehealth or some other private call but there are still many more questions that need to be answered in order to implement video calling for example because UDP is an unreliable protocol it doesn't have to establish a connection to send data how do we establish reliable communication channels on top of UDP how do we process our users audio and video media streams and how do we encrypt our application data as we send it over the network finally if we have a user who's behind a restricted Network environment like a firewall how do we set up a video call while they're behind that restrictive Network environment now fortunately there are already existing protocols that specify how a developer can overcome these challenges and it is possible for developers to build peer-to-peer video calling functionality by manually stitching together these protocols and this could provide you with a solution with a high degree of customization but at the expense of time since the developer would have to gain a deep understanding of multiple protocols and how they interact together now fortunately there is already an existing solution that does this it stitches together multiple protocols in order to simplify the complexity of implementing peer-to-peer video calling and it's called webrtc webrtc is free and was developed by Google it works natively within browsers and it's already been adopted in many services and products like Google me Facebook messenger and Discord and next Max will be discussing what a developer would need to know to set up a video call between two peers using webrtc thanks Connor we will now take a deeper dive into webrtc and take a quick look at existing solutions to implement webrtc functionality but let's get started Conor already alluded to this but it's worth mentioning again the key idea behind the success of webrtc is that it orchestrates multiple protocols to do the heavy lifting required for peer-to-peer communication just to name a few webrtc provides end-to-end encryption of audio video and application data techniques to bypass restrictive Network environments and reliable communication channels over UDP and again this is just a short list of all the complex data webrtc abstracts away from the developer we chose webrtc as the underlying technology to power otter for two main reasons first it abstracts away a lot of complexity that requires Niche knowledge like audio and video processing and second it is the most widely used UDP based peer-to-peer video calling solution for web applications to better understand the design decisions behind otter will first go through an example to build webrtc awareness this example follows Alice and Bob who are trying to establish a udp-based peer-to-peer connection as we know a P2P connection involves both peers communicating directly with one another without the need for essential server this means that for this connection to succeed Alice must know the IP address of Bob and Bob must know her IP address as all communication over the Internet requires an IP address the question then becomes how do Alice and Bob figure out what their respective IP address is answering this question largely depends on the network environments of Alice and Bob we'll explore three different scenarios through Alice's perspective interestingly enough Alice will end up with a different IP address in each scenario the first scenario we'll look at occurs when Alice and Bob were within the same local network this is the most straightforward scenario as the communication between Alice and Bob occurs locally in this case their private IP addresses are sufficient for a peer-to-peer connection to take place all Alice needs is the private IP address assigned to her in the local network although this scenario may occur in practice it is the least common one of all three the second scenario is the one which occurs the most in this case Alice and Bob were located in different private networks across the internet this means that the first solution the one where Alice uses her private IP address does not work anymore as the communication is no longer a local one we now have a P2P connection taking place across networks which means that Alice must have a public IP address to be reached over the internet the question we now need to answer is how does Alice figure out what public IP address to use but before we answer this question some of you may have noticed a new component in our diagram a net device will first need to understand the role they play on the network to answer Alice's question not devices are often found at the edge of private networks and can be thought of as gateways to the internet for hosts within the private Network this means that all traffic inbound 2 and outbound from the private network will pass through the NAT device let's take host a as an example the one with an IP address of 192.168.1.10 sending a message to host B who is in the public network the flow of the communication starts with Jose sending a message to host B the net device will intercept this message as it is leaving the private Network and change the source IP address of the message from a private one to a public one this allows the message to be routed to host B across the network the internet then holsby receives a message and sends back a response with a destination IP address being the one of the NAT device 32.8.2.66. as the response reaches the private Network then that device can look in its internal table and see that this message should be routed back to host a it will then once again modify the message by changing the destination IP address from a public one to a private one the last important detail to note here is that some net devices also change the source and destination ports as the messages passed through it in our example the net device mapped host as Port 80 to its own port 3000. this allows the net device to reuse a single public IP address for multiple internal hosts who don't have one but need one to communicate over the internet this is one of the reasons why Nat devices exist in the first place they allow multiple hosts within a private Network to share the same public IP address now if we link this back to our second scenario because Alice is behind on that device she doesn't know what her public IP address is the solution to this problem is a straightforward one Alice needs to ask someone outside her private Network what her public IP address is by sending them a special type of request that someone or more accurately something is a stun server Alice can send a request to a stun server asking it to note down the source IP address of her request if we look back at how net devices work the stun server receives the request from Alice but only after the net device has changed the source IP address of the request from a private one to a public one the stun server includes the source IP address of Alice's request and the response that it then sends back to her once Alice receives the response from the stunt server she now has access to the public IP address that the net device assigned her with this in hand Alice can now communicate over the Internet with Bob we've now solved our second scenario the third and final one once again involves Alice in Bob being in different networks their goal is still the same they want to establish a direct peer-to-peer UDP based connection however this time around Alice's network is very restrictive and blocks all UDP traffic in practice this can be accomplished by having the net device simply drop all UDP traffic in this case a direct connection is simply not possible due to the restrictive nature of Alice's network but we still want Alice and Bob to be able to communicate with one another the question then becomes how does Alice figure out a way to bypass a restrictive Network again the answer to this question is conceptually easy to understand Alice simply needs someone to relay messages between her and Bob for this we need a turn server we know that Alice's network doesn't allow UDP traffic this tells us that she needs to use TCP to send her messages to Bob a turn server allows her to do exactly that in our example Alice can send her TCP messages to the turn server who will then convert them to UDP messages before relaying them to Bob this solves the communication from Alice to Bob on the other hand if Bob tried to send his messages directly to Alice her net device would simply drop them as UDP traffic is not allowed the turn server can also handle this side of the communication in our example Alice retrieves the public IP address of the turn server and then tells Bob to send his UDP messages to the third server who will then convert them to TCP messages before relying them to Alice this solves the communication from Bob to Alice that's really all that there is to a turn server it simply relays the messages between the peers and nothing more in fact Bob isn't even aware that he's now communicating with a turn server and he doesn't need to be as his side of the communication can still be UDP based and benefit from the lower latency associated with UDP traffic we've now solved our final scenario now you've probably been wondering how does Alice actually tell Bob what are the different IP addresses she's been able to gather without these IP addresses Bob will never be able to establish a peer-to-peer connection with her as with the other problems we've encountered so far we need a new component to help them this new component is a signaling server This Server allows Alice and Bob to exchange all the information they need to establish a peer-to-peer connection in our example Alice is able to tell Bob that she wants to share audio and video media with him through an offer uh previous slide question previous previous previous previous yeah this one okay so Alice is able to tell Bob that she wants to share audio and video media with him to an offer she can also pass along the different IP addresses she's obtained so either her private AP address her public IP address or the public IP address of a turn server but this Bob can build an answer and include all his relevant information for the call in webrtc terminology we refer to this process of establishing a peer-to-peer session as negotiation peers negotiate the parameters of the call to initialize it but also at any time the parameters of the session need to change renegotiation can simply be appear wanting to share New Media or the occurrence of network issues that impact the call so the key idea to retain from a signaling server is that whenever Alice and Bob need to negotiate or renegotiate the parameters of the peer-to-peer session they can do so with the help of the signaling server that's all that there is we now have the full picture of the webrtc communication flow so let's summarize it one last time first both Alice and Bob need to gather different IP addresses for the other person to be able to communicate with them depending on the network environments that they find themselves in a direct connection can be achieved by using a stunt server or they might need a turn server to relay the media between them they can exchange these different IP addresses through the signaling server as well as any other relevant parameter for the session once both peers have all this information in hand only then can they establish a peer-to-peer video call so as we've just seen establishing a peer-to-peer connection requires multiple steps and many different components there are therefore many options that a developer can choose from to include webrtc functionality into a web application we'll now explore some of these options the first approach is to do everything from scratch this involves stitching the different components together which can be custom or open source implementations under this approach the developer needs to understand the stun and turn protocols as well as have a deep understanding of the webrtc API this approach is the most flexible one but it's also the one that requires most knowledge it can also be very time consuming as the developer needs to deploy and maintain the infrastructure the second approach is for the developer to use a software development kit such as the one from twilio the primary benefit of this approach is that it becomes easier to build a robust application as commercial sdks include all the functionality a developer needs on the other hand this approach tends to cost more as commercial sdks are not free and data privacy can become a concern as the developer now needs to rely on the infrastructure of a third party I'll now pass it to Kush to introduce a third approach that a developer can use to include webrtc functionality thank you Max hi everyone my name is kashal I'm going to be introducing otter talking about how we built it and some of the design decisions we considered so what is otter otter is a cloud native framework for peer-to-peer video communication within web applications otters for the developer who wants a video calling solution where privacy is of the utmost importance otter is made up of three things first it is a react web application for peer-to-peer calls it offers audio video instant messaging and file sharing second it is a developer friendly CLI with just one command to deploy the infrastructure and one command to tear it down third it is an API which allows developers to integrate Auto into their web application otter slots right in the middle of the DIY and the commercial Solutions Max disgust the beauty of otter is that webrtc knowledge is not required and we've seen how this can be complex or time consuming otters deployed on the AWS cloud and Rise heavily on the serverless Paradigm the serverless Paradigm abstracts away the complexity of provisioning and managing servers for a developer whose only concern then is core application logic as a drop-in framework otter leverages the serverless Paradigm in the design of its architecture let's talk about how we built otter we base the design of otter on three objectives the first was to provision the infrastructure that supports video calling recall the need for a signaling stun and turn servers second to abstract the way the complexity of interacting with such an infrastructure recall the complexity of working with webrtc API the third was to allow developers to easily integrate otter into their application and this is what makes otter a drop-in framework we segmented the architecture into groups of components that fulfill these objectives we call these groups stacks and we have four the signaling stack the stun turn stack the front end stack and the API stack let's peer into these stacks we'll start with the signaling stack recall to establish a web RTC connection we need some mechanism to pass messages between peers AKA signaling what are the characteristics of a signaling server well as a real-time application there's going to be a chat like feel to it we need a two-way Communication channel for clients and servers to independently send data to each other as opposed to a traditional HTTP request response cycle we need something low latency for a real-time effect the website protocol is built for this purpose the websocket protocol enables low latency bi-directional asynchronous communication between client and server the client and server can transmit data independently once a connection is established so what does a websocket server consist of a typical websocket server for a chat like application will have three event listeners one to assign an identifier to each client that connects two to send messages between clients and the third to delete the identifier for each client that disconnects since media flows directly between peers we can observe two insights the first event listeners can respond to requests on demand as opposed to continuously running and listening the second Insight is that peers need to maintain a long-lived connection to the server in case of renegotiation as Max had previously introduced so how can we take advantage of this natural decoupling between being event-based and long-lived we can use two AWS Services API websocket Gateway and lambdas both Services Leverage The serverless Paradigm and require minimal maintenance the websocket Gateway maintains a long-lived connection with the client whereas the lambdas being event based are snoozing and respond only when a request comes in since lambdas or functions running specific logic we will have one Lambda per event listener behind the gateway so the connect Lambda assigns identifiers to each client's connecting the signaling Lambda passes messages between clients and the disconnect Lambda deletes identifiers associated with the client's disconnecting since the Gateway is stateless to persist these identifiers the lambdas need to consult a dynamodb you will also see an authorizer Lambda attached to the Gateway the authorizer restricts access to the Gateway which Chris will explain more about later next we will discuss the stun turn stack recall the need for a stun turn server to help with IP traversals in the case of nat devices or firewalls we chose to implement coturn an open source solution it provides functionality for both stun and turn and it is the most widely used between open source managed or third-party implementations so how do we implement coturn our first requirement was to have a public IP address because the turn server needs to be accessible by The Wider internet as we saw with Alice and Bob in Max's example to stay aligned with our serverless Paradigm we also required something low maintenance and scalable this led to two insights the coturn software should run in a container to eliminate any runtime dependencies and we could use AWS fargate another AWS service which allows developers to run containers without having to manage servers so how do we go about scaling co-turn we needed to be able to add or remove containers depending on traffic load AWS elastic container service handled this need ECS is a fully managed container orchestration tool we configured ECS to have at least one instance running at all times and to adapt the number of instances depending on CPU utilization this means at any given point we could have multiple instances of coturn running this also means we would need to direct traffic accordingly the AWS Network load balancer handled this need the network load balancer is different from application load balancer because it handles requests at the transport layer recall Connor's discussion about UDP versus TCP and so this is what the stun turn stack looks like with the signaling stack and the stun turn stack we have met the first objective to provide the infrastructure support video calling but without a way to interact with this instruct infrastructure a developer would still need to consume the webrtc API to develop test and deploy a video calling application this is where the front end stack comes in it serves two purposes to provide a video calling application which we lovingly refer to as the otter web app and to host this otter web app how does the auto web app work it consumes two resources from the API stack to connect and plug into the auto video calling infrastructure it also consumes a webrtc API to set up connections between peers allowing peers to process video streams share files and instant messages this is what the front end stack looks like and how is the auto web app hosted we used AWS cloudfront a cloud content delivery Network cloudfront distributes a website hosted in an S3 Bucket from Edge locations closest to the end user you'll notice an ec2 component on the far right and we'll explore this later with Chris in the challenges section so now we have achieved the first two objectives with the signaling and stun turn Stacks we have provisioned the infrastructure to support video calling and with the front end stack in the auto web app we have abstracted away the complexity of interacting with this video calling infrastructure but how do we allow developers to integrate Auto into their applications we've seen that the auto web app leverages the auto video calling infrastructure so how do developers access the auto web app so they can leverage the auto ecosystem the API stack helps with that it serves two purposes first it provides a route for developers to access the auto web app the create room route creates a room and responds with a URL that automatically joins an auto web app peer-to-peer session when clicked upon second it provides two routes for the auto web app to consume the room ID route verifies that the room indeed exists and the credentials route fetches the co-train credentials so how should we implement the API stack let's consider its traffic pattern recall that once a webrtc session begins media flows directly between peers and their browsers the lifecycle of a webrt session includes one API call to create the room resource two API calls to fetch the room metadata and two API calls to fetch the code print credentials this life cycle lends to two insights since the life cycle has five API calls which happens at its beginning we do not need a server running continuously the second Insight is that the create room resource will be called half as many times as either of the other routes these insights warn an infrastructure that can respond to an on-demand nature and distinct scaling needs per route as these needs were similar to the signaling stack we used an HTTP API Gateway and more lambdas here's the API stack and the layout of its component again the create room create room root is for the developer it is how they access and leverage otter the other two routes are for the auto web app to access and plug into the signaling and stun turn Stacks here the dynamodb stores API Keys room metadata and cultured credentials similar to the signaling stack the authorizer Lambda attached to the Gateway restricts access to it Chris will discuss this further in the engineering challenges so here are the four Stacks together and now with an understanding of each we can walk over the workflow of establishing an auto video call which happens after deploying the audit infrastructure first we create the room resource the developer adds functionality like a button in their application which sends a post request to the create room resource and a URL is generated as a response by visiting the URL the otter web app is loaded and served from cloudfront the auto web app validates the room and fetches the codeword credentials with two respective get requests asynchronously the auto web app also establishes a connection to the API websocket Gateway the auto web app starts Gathering candidate IP addresses to include in its offers and answers that are sent via the signaling server at this point the video call between peers can commence that wraps up the architecture of Arc otter I'll now hand it off to Chris who will give us a demo of otter and highlight some of the engineering challenges we've faced while building otter thanks Kush now that we know the workflow of establishing an auto video call let's take a quick look at how it works in practice everything starts with executing the auto deploy command it will provision offer stats create the host Auto web app and output the API endpoint with an API key for the developer in addition it will also create a sample room with a link the developer can follow the link and test the functionality of other right away without writing any code to create a new room for a video call send a request to the get room endpoint the API will return a unique link to the room when an end user can access through the browser this link can then be shared with users who want to join a video account now when the user clicks the link the browser loads the auto web app that provides an easy to use interface for peer-to-peer video call the web app also provides some essential video calling features such as mute unmute audio messaging and file sharing as you can see a developer only needs to take care of creating new rooms and other will handle everything else now let's dive into some technical challenges we encountered and talk about what we did to tackle these challenges in this section we are going to discuss how do we generate the auto web app on the Fly how do we apply authentication mechanism to others infrastructure and how do we resolve a risk condition called glare during the initiation of a video call first recall we built our web app to interact with the underlying infrastructure such interaction includes connecting with the websocket Gateway making requests to the API and communicating with the stand turn stack now a problem arises in order to interact with these infrastructure components the other web app needs to know their endpoints since they are referencing since the app referencing them in the code as you can see here now we could send us get requests to fetch these endpoints somewhere but then it becomes a chicken and egg situation because the app still needs to know the endpoints for fetching other endpoints in another word the problem we have here means the application can only be built after other deploy is finished and we have all the endpoints available to achieve this our solution is to build the application on the Fly here's how it works after Auto deploy is executed a series of API calls will be made to AWS cloud formation which is responsible for provisioning all the resources other needs among these resources we also create an ec2 instance to help us build the web application after all resources are provisioned we will make another series of API calls to fetch all the endpoints then the other CLI creates a JavaScript file populate all endpoints in it so the web app can reference them in the code then we push the file to an S3 bucket for storage now that we have all the endpoints available our ec2 instance will execute a script that pulls the web app source code from GitHub it then fetches the Javascript file and builds the web application after the web app is built it is pushed to the S3 bucket and ready for access from the cloud fronts at this point the ec2 instance is no longer needed and will be terminated however this solution introduced another problem at this point if someone loads the web app in the browser opens up the developer developers console and takes a look at a source code all the endpoints are exposed there this is a serious security issue since anyone can send requests to these endpoints and no questions will be asked the solution will be securing the endpoints so that they only respond to authenticated requests with that even though the endpoints are still exposed to the public other is only accessible from authenticated clients with the solution in mind let's see how we implement it recall from what coach mentioned before there are two types of accessing patterns for other the first type is developers communicating with the API in order to create a new room and generate a link the second type is the other web app accessing both the API and websocket Gateway in order to initiate a video call for the developers we implemented API key authentication so that only requests with a valid API key will be processed here's how it works during the order deploy an API key is generated storing the database and displayed in the CLI and authorized Lambda is attached to the Gateway when the developer sends a request to the Gateway the authorizer Lambda fascist API key in the database and it checks if the incoming API Keys matches the key in the database if it is a match the Lambda sends a message to the Gateway that allows the request to go through then the Lambda will respond with the resource required by the developer now that we have the API key authentication in place our next task is to secure the traffic from the other web app this involves both the API and the websocket Gateway this time we chose to implement Json web token a Json web token is a type of token used to securely transmit information between parties it is ideal for this scenario because without the key to sign the token it is almost impossible to fabric the token to access the resource that requires it why did we chose it because the other web app is for public use anyone with the link can access it so we cannot rely on API key authentication anymore since the key could also be exposed in the application source code as well first let's see how we create a token remember that when a request is sent to the API create room route it responds with the link to join the video call except this time the create room Lambda also generates a Json web token using their API key fetch in the database and embed the token in the URL in the form of query parameter one additional benefit of using Json web token is that we can set a time to leave parameter to it in this case the token will expire in 48 hours which means the room will be no longer available there setting reduces the possibility for someone abusing the system and using the same room all the time okay now we have the link with the token here's how we authenticate it when someone visits the link the other web app extracts the token from the URL and sends all further requests with the token within its request body in this example the Gateway receives the request pass the token to the authorized lender the authorizer refreshes the API key from the database again and uses it to verify the token based on the result of the verification it instructs the gateway to allow or deny the request accordingly and that's it now we have our other web app generated dynamically based on the infrastructure endpoints we've also secured these endpoints to only allow authenticated requests being processed foreign to our next challenge now that we have a secure and perfect working web app two peers are trying to use the application to connect let's first consider a happy path recall that during the initial connection process peer a would send an offer encapsulating session parameters and appear B will respond with an answer when pure a receives the answer they will try to initiate a peer-to-peer connection but this process is not without caveats what if two peers are trying to reach out to the other side at the same time to make it worse since the network is unreliable in nature due to network latency or network partition appear can send out its own offer before it receives the offer from the other side as we can see from this example on the right the default way of negotiating the offer answer processing webrtc introduces risk conditions that cannot be resolved on their own resulting in deadlock errors and bad user experience this is known as glare to resolve this issue our solution is to assign roles to both peers so they have different behaviors when receiving an offer the two assigned rules are applied and implied here's an example showcasing these two rows first apply peer discards their own offer upon receiving an incoming offer in this example appears sent out the offer waiting for an answer but received an offer since this is a pipe here it discards its own offer creates and response with an answer on the other hand an implied peer ignores all ignorance and incoming offer if it collides with their own in this case the implied peer ignores the incoming offer and continues to wait for an answer this pattern is what we call a perfect negotiation let's see how it resolves the glare when we apply it to our previous example here since the implied peer discards the incoming offer and the play peer sends out the answer when receiving an offer will no longer need to worry about the risk condition that previously caused deadlock and poor user experience okay although we have managed to solve some technical challenges there are still some limitations for offer that we wanted to continue to work on firstly order only allows two peers in the room for now we would like to increase the number of peers that can participate in a video call to 4 as anything above this can become difficult to manage under a pure P2P Network model secondly right now accessing the API Gateway requires an API key we would like to add a route to the API to invalidate the key and generate a new one this way a developer who integrates order within a web application has the possibility to rotate the API key for enhanced security lastly we would like to work on an SDK that abstracts the way the complexity of working with the web RTC API so the developer can use the SDK and build their own other web app but still retain the ability to interact with the other infrastructure all right that's all for today thank you very much for joining us now I'm going to hand it over to Connor feel free to ask any questions yes thank you everyone for coming and now we're just gonna go ahead and wait a couple minutes to allow some questions to come in there doesn't seem to be any questions so I'm assuming the presentation was extremely clear actually we did just get one question just now uh Team what would you say was the most challenging part of the project implementation I can I can say for myself I think one of the aspects that was definitely challenging is working with lower layer protocols with UDP TCP trying to understand how they interact with upper layer protocols um so that that's one for sure and then the other one was figuring out um which current server to use so we ended up choosing coturn and even though it's widely used the documentation around it is not awesome so that was another challenge of trying to figure out how to you know make it work yeah I just want to add another challenge for us was actually to create this uh web application since it requires knowledge for the webrtc API and work on work with the API and the webrcc API is actually really complex although we we we didn't share it like uh we didn't demonstrate how complex that would be but uh that's actually the most difficult part in my opinion just to create a web application itself for someone who might have missed this part is auto ready to scale I can enter that one we tested the websocket Gateway and AWS has theoretical limits of they can handle quite a large number of requests per second we didn't have the resources to test the turn server specifically but our websocket Gateway is able to handle several thousands of requests per second all right looks like we have one last question uh which parts we enjoy implementing or did you enjoy implementing the most uh I think for me was working with the working with the webrtc API how Chris just mentioned it but it's uh it's a fairly involved API and just trying to figure out how to you know work with media streams that was very very interesting um so that's that's for me yeah I always say it's a bitter and the sweet uh at the same time working with the web access API uh at one point it's uh pretty complex but on the other hand seen um seeing like people could communicate without each other directly during a video call and share files and instant messages uh that was super fun I was gonna add working with AWS lambdas was quite fun um fun and interesting sense but able to trace the logs and and just see how they work and interact and how flexible they can be all right and then the last question someone asked how did you come up with the name otter uh for our team we actually this was kind of a little play on words uh because otters are navigate through streams and we wanted our app to help developers navigate the process of managing video streams uh and with that that's all the time we have for today so thank you everyone for coming foreign 