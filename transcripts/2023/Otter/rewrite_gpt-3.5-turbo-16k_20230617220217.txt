Hello everyone and thank you for joining us today. We are here to present Otter, a cloud-native framework for peer-to-peer video communication within web applications. My name is Connor and I am joined by my colleagues Chris, Max, and Kush. Together, we have developed Otter over the last few months and we are excited to share it with you today.

Let's start by giving an overview of video calling and the design decisions that developers need to consider when implementing it. Video calling has become increasingly relevant in recent years, with applications ranging from telehealth to online classes and virtual business meetings. Developers are keen to add video calling functionality to their applications. However, different use cases require different design decisions.

One important consideration is the choice between a client-server or a peer-to-peer network model. In a client-server model, devices connect to a central server which mediates the communication between them. On the other hand, in a peer-to-peer network, devices can communicate directly with each other without the need for a central server. Each model has its own advantages and trade-offs.

A peer-to-peer network offers increased privacy for end users since data does not pass through a central server that can monitor it. It also reduces latency as data can travel directly between peers without stopping at a server. Furthermore, a peer-to-peer network increases network resilience as there is no single point of failure like a central server. Lastly, it can be more cost-effective as developers do not need to provision and maintain servers.

However, peer-to-peer networks have limitations in terms of call size. Each peer needs to connect to every other peer in the network, which becomes challenging as the number of participants increases. On the other hand, a client-server model can support larger call sizes since the server manages the connections. It also allows for additional features like real-time processing and recording of calls.

For developers who prioritize privacy and have smaller call sizes, a peer-to-peer model is a better fit. Examples include telehealth calls or virtual legal consultations. For those who need large call sizes and additional features, a client-server model is more suitable, like for online classes or large business meetings.

Another important aspect of video calling is latency, which affects the responsiveness of the call. Latency refers to the time it takes for data to travel from its origin to its destination. High latency can cause delays and make conversations feel unnatural. To minimize latency, developers need to choose the right protocols for data transmission.

There are two main protocols to consider: TCP (Transmission Control Protocol) and UDP (User Datagram Protocol). TCP ensures reliable transmission of data by establishing a connection and retransmitting lost data. However, this reliability comes at the cost of increased latency. On the other hand, UDP offers faster transmission by not establishing a connection and not guaranteeing delivery. This makes UDP more suitable for real-time video calls where speed is prioritized over reliability.

To simplify the implementation of peer-to-peer video calling, we chose to use WebRTC (Web Real-Time Communication). WebRTC is a free technology developed by Google that abstracts away the complexity of protocols to provide end-to-end encryption, bypass restrictive network environments, and establish reliable communication channels over UDP. It is widely used in web applications, including services like Google Meet, Facebook Messenger, and Discord.

Now, let's dive deeper into WebRTC and the process of setting up a video call between two peers. In this example, we will follow Alice and Bob as they try to establish a UDP-based peer-to-peer connection. The success of this connection depends on them knowing each other's IP addresses.

In the first scenario, Alice and Bob are on the same local network, which makes communication straightforward. They can use their private IP addresses to establish the connection. However, this scenario is less common.

The second scenario is when Alice and Bob are in different private networks across the internet. In this case, they need to use their public IP addresses to communicate over the internet. Alice needs to determine her public IP address, which can be achieved through her network environment. Network Address Translation (NAT) devices play a crucial role in this scenario, as they act as gateways for hosts within a private network to access the internet. The NAT device modifies the source IP address of outgoing messages from a private IP to a public IP, allowing communication across networks.

In the third scenario, Alice is behind a restricted network environment like a firewall. In this case, setting up a video call becomes more challenging. However, WebRTC provides techniques to bypass such restrictions, ensuring that the connection can be established even in these situations.

WebRTC simplifies the implementation of peer-to-peer video calling by integrating multiple protocols to handle the complexities of establishing reliable communication channels, processing audio and video data, and encrypting application data. By leveraging the power of WebRTC, Otter provides a user-friendly cloud-native framework for developers to add video calling functionality to their web applications.

In terms of future plans for Otter, we aim to continue improving and expanding its capabilities. This includes enhancing support for larger call sizes in peer-to-peer networks, developing additional features for the client-server model, and exploring ways to optimize latency. We are committed to delivering a robust and versatile solution for developers looking to incorporate video calling into their applications.

Thank you for your attention. We have provided an overview of video calling, discussed the benefits of different network models, introduced WebRTC as the underlying technology, and explained how Otter leverages WebRTC to simplify video calling implementation. We hope that Otter will be a valuable tool for developers and we are open to any questions you may have. This is a transcript of a coding Capstone project video on a web application video calling solution. The video explains how to establish a peer-to-peer connection using WebRTC and discusses different scenarios and components involved in the process. 

In the first scenario, Alice and Bob are in the same local network. Communication between them is straightforward as they can use their private IP addresses for a peer-to-peer connection. However, this scenario is the least common one. 

The second scenario occurs when Alice and Bob are in different private networks across the internet. In this case, Alice needs to know her public IP address to establish a connection with Bob. To find her public IP address, Alice can send a request to a STUN (Session Traversal Utilities for NAT) server, which will note down the source IP address of her request after it has been changed from a private to a public one by the NAT (Network Address Translation) device. The STUN server then sends this information back to Alice, allowing her to communicate over the internet with Bob. 

The third scenario is similar to the second one, but Alice's network restricts all UDP (User Datagram Protocol) traffic. In this case, a direct UDP-based connection is not possible. However, Alice can still communicate with Bob by using a TURN (Traversal Using Relays around NAT) server. Alice sends TCP (Transmission Control Protocol) messages to the TURN server, which then converts them to UDP messages and relays them to Bob. Similarly, Bob can send UDP messages to the TURN server, which converts them to TCP messages and relays them to Alice. The TURN server acts as a relay for their communication. 

To establish a peer-to-peer connection, Alice and Bob need to exchange their respective IP addresses. They can do this through a signaling server, which allows them to exchange information and negotiate the parameters of the session. The signaling server facilitates communication between the peers and enables them to establish a peer-to-peer video call. 

In summary, the process of establishing a peer-to-peer connection involves multiple steps and different components. It requires gathering IP addresses, utilizing STUN and TURN servers, and using a signaling server for communication between Alice and Bob. 

Now let's discuss some options for integrating WebRTC functionality into web applications. 

The first approach is to build everything from scratch, using custom or open-source implementations of the necessary components. This approach provides the most flexibility but requires a deep understanding of the STUN, TURN, and WebRTC API protocols. It also involves deploying and maintaining the infrastructure. 

The second approach is to use a software development kit (SDK), such as the one offered by Twilio. This approach simplifies the development process by providing all the necessary functionality for building a robust application. However, it may come at a cost, as commercial SDKs are not free, and data privacy can be a concern when relying on a third-party infrastructure. 

There is a third approach that developers can use to include WebRTC functionality in their web applications, and that is where Otter comes in. Otter is a cloud-native framework for peer-to-peer video communication within web applications. It is designed for developers who prioritize privacy. 

Otter consists of three main components. First, it is a React web application that supports peer-to-peer calls with audio, video, instant messaging, and file sharing. Second, it is a developer-friendly command-line interface (CLI) that simplifies infrastructure deployment and maintenance. And third, it is an API that allows developers to integrate Otter into their web applications. 

Otter leverages the serverless paradigm and is deployed on the AWS cloud. This abstraction reduces the complexity of provisioning and managing servers, allowing developers to focus on their core application logic. 

The design of Otter is based on three objectives. The first is to provision the infrastructure for video calling, including signaling, STUN, and TURN servers. The second is to abstract the complexity of interacting with this infrastructure, including the WebRTC API. The third objective is to make it easy for developers to integrate Otter into their applications. 

To achieve these objectives, Otter is divided into four stacks or groups of components. The first stack is the signaling stack, which handles the communication between peers using websockets. It includes a websocket gateway and Lambda functions to handle the different events, such as connection, message passing, and disconnection. 

The second stack is the STUN/TURN stack, which provides the necessary infrastructure for handling peer-to-peer connections across networks. This stack includes STUN and TURN servers that leverage the serverless paradigm and require minimal maintenance. 

The third stack is the front-end stack, which consists of the React web application that enables peer-to-peer calls with audio, video, instant messaging, and file sharing. 

And finally, the fourth stack is the API stack, which allows developers to integrate Otter into their web applications. 

In conclusion, Otter is a cloud-native framework that simplifies the integration of WebRTC functionality into web applications. It provides a drop-in solution for peer-to-peer video communication with a focus on privacy. Developers can choose from different options, ranging from building everything from scratch to using commercial SDKs or leveraging the serverless paradigm with Otter. Each approach has its advantages and considerations, and it's up to the developer to choose the one that best fits their needs and requirements. This transcript outlines the architecture and implementation of a coding Capstone project called "Otter" that heavily relies on the serverless paradigm in the AWS cloud. The serverless paradigm abstracts away the complexities of managing servers, allowing developers to focus solely on the core application logic. Otter aims to provide a drop-in framework for video calling, with a focus on simplicity and ease of integration.

To achieve this, Otter's design is based on three main objectives. The first objective is to provision the necessary infrastructure for supporting video calling, including signaling, STUN, and TURN servers. The second objective is to abstract away the complexity of interacting with this infrastructure, particularly the challenges of working with the WebRTC API. Lastly, Otter aims to provide developers with an easy integration process, making it a true drop-in framework.

The architecture of Otter is divided into four main components, or stacks: the signaling stack, the STUN/TURN stack, the front-end stack, and the API stack. The signaling stack handles the communication between peers by utilizing the WebSocket protocol. This allows for low-latency, bi-directional, asynchronous communication. Each client that connects is assigned an identifier, and the stack includes event listeners to send and delete messages between clients. The stack is implemented using AWS services, such as API Gateway and Lambdas, which leverage the serverless paradigm and require minimal maintenance.

The STUN/TURN stack is responsible for handling IP traversals in the case of NAT devices or firewalls. Coturn, an open-source solution, is used for this purpose. To align with the serverless paradigm, Coturn is implemented as a container using AWS Fargate, a serverless container orchestration service. AWS Elastic Container Service (ECS) is used to scale the number of Coturn containers based on traffic load, with AWS Network Load Balancer handling the traffic distribution.

The front-end stack consists of two main components: the Otter web app and its hosting. The web app uses resources from the API stack to connect to and interact with the Otter video calling infrastructure. It also utilizes the WebRTC API for establishing video connections between peers. The front-end stack is hosted using AWS CloudFront, a content delivery network that distributes the web app from edge locations closest to end users. An EC2 instance is also used for certain specific functionalities, which will be further explained later.

The API stack serves as a bridge between developers and the Otter ecosystem. It provides routes for developers to access the Otter web app, such as a "create room" route that generates a URL for joining a peer-to-peer session. It also includes routes for the web app to access the signaling and STUN/TURN stacks. The API stack leverages an HTTP API Gateway and Lambdas, similar to the signaling stack, and uses DynamoDB to store API keys, room metadata, and Coturn credentials. An authorizer Lambda is attached to the Gateway to restrict access and ensure security.

With these four stacks, Otter is built to support the integration of video calling capabilities into applications. The workflow of establishing an Otter video call begins with creating a room resource using the API stack. Developers can add functionality, such as a button, to their application to initiate this process. Upon clicking the button, a URL is generated, which, when visited, loads the Otter web app from CloudFront. The web app validates the room and fetches Coturn credentials asynchronously. It then establishes a connection to the API WebSocket Gateway and starts gathering candidate IP addresses for video communication between peers.

Moving on to the engineering challenges, let's first address how the Otter web app is generated on the fly. The app needs to know the endpoints of the infrastructure components it interacts with, but fetching these endpoints creates a chicken-and-egg problem. To solve this, Otter's solution is to build the application dynamically. After the deployment process, API calls are made to AWS CloudFormation, which provisions the necessary resources. An EC2 instance is created specifically to build the web app and fetch the endpoints. The instance pulls the web app source code from GitHub, populates a JavaScript file with the endpoints, and pushes it to an S3 bucket. The web app is then built and pushed to the S3 bucket, ready to be served.

However, this solution exposes the endpoints in the web app source code. To address this security concern, authentication mechanisms are implemented. Developers accessing the API are authenticated using API keys, which are checked by the authorizer Lambda attached to the API Gateway. The web app's access to the API and WebSocket Gateway is secured using JSON Web Tokens (JWTs), ensuring that only authenticated clients can interact with Otter's infrastructure. This approach enhances security and prevents unauthorized access to the endpoints.

Lastly, the engineering challenge of resolving a risk condition called "glare" during the initiation of a video call is tackled. Glare refers to a race condition where multiple peers initiate a video call simultaneously, causing conflicts that prevent connections from being established. To mitigate this, Otter implements a unique room creation process. When a developer requests the creation of a new room, Otter ensures the room's uniqueness and performs necessary checks to avoid conflicts. This prevents glare and ensures seamless video call initiation for all participants.

In conclusion, Otter is a serverless-based video calling framework designed to simplify the integration process for developers. Its architecture consists of four key stacks: signaling, STUN/TURN, front-end, and API. By leveraging AWS services and the serverless paradigm, Otter abstracts away infrastructure complexities, allows for scalability, and ensures low-latency communication. The dynamic generation of the Otter web app, authentication mechanisms, and glare resolution demonstrate the engineering solutions to specific challenges faced during the project. The application we developed is designed to be highly dynamic and adaptable. Here's how it works: once the Auto deploy is executed, a series of API calls are made to AWS cloud formation. This is responsible for provisioning all the necessary resources. One of these resources is an EC2 instance used to build the web application. After all the resources are provisioned, another series of API calls are made to fetch all the endpoints. A JavaScript file is then generated by the other CLI, which populates it with all the endpoints. This allows the web app to easily reference them in its code. The file is then pushed to an S3 bucket for storage.

Once all the endpoints are available, the EC2 instance executes a script to fetch the web app source code from GitHub. It also retrieves the JavaScript file and proceeds to build the web application. Once the web app is built, it is pushed to the S3 bucket and becomes accessible via the cloud front.

At this point, the EC2 instance is no longer needed and will be terminated. However, a new problem arises: if someone loads the web app in the browser and opens up the developer console, they can easily view the source code and expose all the endpoints. This poses a serious security issue, as anyone can send requests to these endpoints without any authentication.

To address this security concern, we implemented a solution to secure the endpoints and only allow authenticated requests. This means that even though the endpoints are still exposed to the public, they can only be accessed by authenticated clients.

To achieve this, we implemented API key authentication for developers who interact with the API to create a new room and generate a link. During the order deploy process, an API key is generated and stored in the database. This key is displayed in the CLI. An authorized Lambda function is attached to the Gateway. When a developer sends a request to the Gateway, the authorizer Lambda checks if the incoming API key matches the one stored in the database. If there is a match, the Lambda sends a message to the Gateway to allow the request to pass through. The Lambda then sends the required resource back to the developer.

With API key authentication in place, we needed to secure the traffic from the other web app. This involved both the API and the WebSocket Gateway. To achieve this, we chose to implement JSON Web Tokens (JWTs). JWTs are a type of token used to securely transmit information between parties. They are ideal for this scenario because, without the key to sign the token, it is nearly impossible to fabricate a token to gain access to the required resource.

Since the other web app is publicly accessible, we cannot rely solely on API key authentication, as the key could be exposed in the application source code. To authenticate the token, when someone visits the link generated by the create room route, the other web app extracts the token from the URL and includes it in all further requests within the request body. The Gateway receives the request and passes the token to the authorized Lambda. The authorizer Lambda refreshes the API key from the database and uses it to verify the token. Based on the verification result, the Lambda instructs the Gateway to allow or deny the request accordingly.

With the secure authentication process in place, we now have a dynamically generated other web app that utilizes the infrastructure endpoints. These endpoints are secured to only allow authenticated requests to be processed.

Moving forward, we aimed to address some limitations of the current implementation. Firstly, we wanted to allow more than just two peers in a room. Our goal was to increase the number of peers that can participate in a video call to four, as managing more than four peers can become challenging within a peer-to-peer network model.

Secondly, we wanted to enhance the security of the API by adding a route that allows developers to invalidate the API key and generate a new one. This would provide developers integrating order within a web application the ability to rotate the API key for enhanced security.

Finally, we wanted to abstract the complexity of working with the WebRTC API by developing an SDK. This SDK would enable developers to build their own other web app while still having the ability to interact with the other infrastructure.

Thank you for joining us for today's presentation. If you have any questions, please feel free to ask.