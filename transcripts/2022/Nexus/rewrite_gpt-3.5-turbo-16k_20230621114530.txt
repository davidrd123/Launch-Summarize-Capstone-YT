Thank you for joining our presentation on Nexus, an instant GraphQL framework. I'm Felicia, joined by my teammates Kim, Ben, and Matt. Together, we have built Nexus, an open-source GraphQL framework. Nexus takes a user's existing data sources, generates a GraphQL API, and deploys that API to the cloud. This allows all the user's clients to make requests to a single endpoint. Nexus serves the middle part of the diagram, focusing on quickly building and deploying the server.

Before we delve deeper into Nexus, let's discuss REST APIs and some of the problems they present, which have led to the adoption of GraphQL. We will also explore the challenges developers face when implementing a GraphQL API and some existing solutions. Finally, we'll share why and how we built Nexus, along with the decisions we made along the way.

So let's begin by talking about APIs. When parts of a system are decoupled to separate concerns, there needs to be a standardized way for those parts to communicate. This is where an API, or Application Programming Interface, comes in. The most common API pattern today is REST, which provides endpoints corresponding to significant resources in an application. REST is popular due to its simplicity for developers, particularly in client applications where the client's pages directly correspond to REST endpoints.

However, issues can arise when a new client with different data access patterns needs to integrate with an existing REST API. Each client type has different data requirements, and a fixed endpoint may not serve both at the same time. Overfetching occurs when one client receives more data than it needs, leading to slower page loads and decreased performance. Underfetching, on the other hand, happens when an endpoint doesn't contain all the required data, resulting in additional requests and increased page load time.

These issues not only affect application performance but also impact how front-end developers spend their time. When an API does not match the front-end client's data needs, developers must spend extra time fetching data, filtering unnecessary data, and orchestrating multiple API calls. This can lead to a significant amount of time being spent solely on data management, leaving less time for crucial UI building.

To address these challenges, GraphQL emerged as an option in 2015. GraphQL provides highly customizable and flexible APIs that can handle multiple different clients with varying data needs. It is especially useful when data is nested, interrelated, recursive, varies frequently, or when data is distributed across many different sources.

So how does GraphQL differ from REST? Well, while a REST API exposes many endpoints corresponding to resources, a GraphQL API exposes a single endpoint. This difference is key to the benefits GraphQL offers. With a GraphQL API, each front-end client can use the single endpoint to request all the data it needs. Front-end developers no longer need to keep track of multiple endpoints, and back-end developers don't have to add or adapt endpoints for different client types. This results in simplified data sourcing.

GraphQL supports fetching multiple resources for different client types using a single endpoint by introducing a query language that clients use to request the data they need. Queries are customizable, and the same query can fetch multiple resources at once. The response will contain only the requested information, optimizing performance and reducing data sent over the wire. The query language, known as the Query Language (QL) in GraphQL, enables more efficient and tailored data retrieval.

In summary, we have discussed how APIs help standardize communication between system parts. REST APIs are popular but often encounter issues like overfetching and underfetching. This led to the emergence of GraphQL, which exposes a single endpoint and enables custom queries for efficient data retrieval.

Now, let's shift our focus to the challenges developers face when implementing a GraphQL API and the existing solutions available to them. Implementing a GraphQL API involves multiple components, such as schema and resolvers. The schema defines the data types and relationships, while resolvers retrieve the requested data. Choosing the right approach for schema writing can be a challenge, with options including schema-first and code-first approaches. Each approach has its trade-offs and can affect the setup process.

Additionally, deploying a GraphQL server can be complex, especially for small teams or those new to GraphQL. Developers need to provision and connect the necessary resources for deployment, which can involve multiple steps and coordination between different services. This can be time-consuming, error-prone, and require an understanding of cloud services like AWS.

To address these challenges, existing solutions have been developed within the GraphQL ecosystem. Managed cloud services, such as Hasura and StepZen, automatically create, manage, and deploy GraphQL servers within minutes. These solutions require minimal previous knowledge of GraphQL and support various data sources while offering the ability to combine them into a unified GraphQL layer. Deployment is handled entirely by the service, eliminating the need for manual infrastructure management.

However, these existing solutions may not meet all requirements or support every data source. Furthermore, they can lack extensibility for future needs. This is where Nexus comes in. Nexus was specifically built to address these challenges for small teams that want to leverage GraphQL without the initial overhead of setting up a GraphQL server and deploying it to the cloud.

With Nexus, developers can set up a server in minutes and easily combine multiple data sources into a single endpoint. It simplifies the learning curve by providing a straightforward, opinionated approach. Nexus also facilitates deployment, reducing the time spent on provisioning and connecting resources. It offers extensibility to accommodate future needs, making it a versatile framework for developers.

In conclusion, while large organizations can dedicate teams to implement GraphQL APIs in-house, smaller organizations may find the complexity outweighs the benefits. Small teams can benefit from existing solutions in the GraphQL ecosystem, but these solutions may not meet all requirements or lack extensibility. Nexus addresses these challenges, providing a fast and easy way to set up a server, combine data sources, and deploy to the cloud.

Thank you for your attention, and we are excited to present Nexus, an open-source GraphQL framework designed to simplify and accelerate the development process. This document provides an overview of our coding Capstone project, focusing on the AWS CLI and the challenges developers face when provisioning an EC2 instance. While the AWS CLI offers a vast array of commands, it can be challenging for developers, particularly those new to infrastructure, to navigate the many options. For developers new to GraphQL, there is a need to understand and become proficient in the GraphQL specification, including the schema definition language, type definitions, and resolvers. They must also research and evaluate different schema writing approaches and modularize and combine multiple data sources into a unified schema. In addition, they need to grasp the various cloud services required to deploy their server.

For large organizations, dedicating a team of developers to learn the GraphQL specification and implement their API in-house is feasible. However, smaller organizations may view the complexity of GraphQL as outweighing its benefits and opt for alternative solutions. One such solution is to explore the GraphQL ecosystem to find existing tools that can simplify and speed up the process. Managed cloud services like Hasura and Stepson can quickly set up and deploy a GraphQL API. These services abstract away much of the complexity by automatically creating, managing, and deploying the server. While they offer convenience and ease of setup, they lack control over the infrastructure and may limit extensibility.

Alternatively, open-source GraphQL API generator libraries like WonderGraph or GraphQL Mesh can be used. These libraries provide a starting point and simplify the process of generating a GraphQL server by offering basic setup templates and configuration options. They support various data sources and allow for manual schema extension and the addition of advanced features through plugins. However, these libraries do not provide direct assistance with deployment and require developers to have a good understanding of GraphQL and the library's specific syntax.

To address these challenges and provide a solution that combines convenience, extensibility, and deployment control, we developed Nexus. Nexus serves as a framework for generating a GraphQL API from multiple data sources and deploying it to the user's AWS account. By leveraging GraphQL Mesh, a powerful GraphQL API generator, we simplify the configuration process, enabling developers to get started without prior GraphQL or Mesh experience. Nexus currently supports three data sources: Postgres databases, REST endpoints specified in a JSON file following the OpenAPI specification, and other GraphQL APIs.

Deploying the generated GraphQL server with Nexus is a straightforward process. A single command handles all the complexities of packaging the server code and provisioning the necessary infrastructure. Leveraging the user's AWS account, Nexus deploys the infrastructure, delivering a URL to access the deployed GraphQL server. While Nexus offers the benefits of extensibility and ownership that come with open-source solutions, it also abstracts away much of the deployment complexity, striking a balance between convenience and control.

To demonstrate the features and capabilities of Nexus, we will walk you through the process of going from zero to a deployed GraphQL API. First, we'll cover the setup and building of the server. Nexus is available as an npm package, and the global installation provides access to all the commands and a local admin dashboard. After initializing a new project with the "init" command, Nexus prompts the user for a Postgres connection string. This connection string is validated, and the user now has a basic GraphQL server built from their Postgres database.

To add additional data sources, such as REST endpoints, the user provides a JSON file following the OpenAPI specification that defines the endpoints. Adding GraphQL data sources follows a similar process. With the multiple data sources connected, the user can start the API locally and test it using the "dev" command. The locally tested server serves as an accurate representation of the deployed API and enables pre-planning of client queries.

Once the server is generated and tested, it's time to deploy it. Nexus simplifies the deployment process with a single command, "Nexus deploy." This command takes care of packaging the server code, provisioning the necessary infrastructure, and deploying the server to the user's AWS account. In just a few minutes, the user receives a URL that can be used to query the deployed GraphQL server from any frontend client.

Nexus also provides a local dashboard that displays information about the server and offers advanced configuration options. Here, users can view the server's status, endpoint, authorization key, and manage their data sources. Additionally, the dashboard includes a local development server for testing changes made to data sources. When changes are made, the user is alerted to redeploy, ensuring that the deployed server is up to date.

For users who wish to remove the provisioned infrastructure at any time, Nexus offers the "destroy" command. This command deprovisions all AWS services set up by Nexus, removing the risk of being charged by AWS for any missed services. Users can also make changes directly within the AWS console if they desire more control over their infrastructure decisions and costs.

Now that we've demonstrated how Nexus can save developers time and streamline the use of generator and deployment tools, let's delve into the architecture and development challenges we encountered during its construction. The Nexus architecture involves two main steps: creating the GraphQL API server and deploying it.

To create the GraphQL API server, Nexus utilizes GraphQL Mesh, an open-source tool, to generate schemas and combine them into a unified GraphQL API. The interaction between Nexus and GraphQL Mesh occurs through a configuration file written in YAML. When a user executes a command in the Nexus command-line tool, such as "init" or "add," the tool installs the necessary GraphQL Mesh packages and creates a configuration file in the user's current working directory. The user provides a Postgres connection string, which is validated, formatted into YAML, and added to the configuration file. Additional data sources, such as REST endpoints or other GraphQL APIs, can be added in a similar manner.

Once the data sources are set up, GraphQL schemas are generated for each source using the schema definition language (SDL). Introspection is performed on each data source to gather information, and the schemas are created accordingly. The generated schemas can be viewed in the user's project directory. These schemas are then combined into a unified schema, with any necessary schema customizations applied. For example, an authorization middleware function can be added to restrict unauthorized access.

To deploy the server, Nexus utilizes containerization through Docker. By encapsulating the application code, libraries, and dependencies required to run the software, Docker ensures consistency and eliminates dependency issues when transferring the application from the user's local machine to the cloud-hosted machine. Docker images, which serve as blueprints for the application, are stored in a repository. Nexus creates and pushes a Docker image to a private repository, which is then pulled onto the cloud infrastructure to run the application. Infrastructure provisioning is handled using Terraform, allowing for the creation of an Amazon Elastic Container Registry for private image storage and the provisioning of Amazon Elastic Container Service and Fargate for managing and scaling containers.

In conclusion, Nexus serves as a powerful tool for simplifying the process of generating and deploying a GraphQL API. By combining convenience, extensibility, and deployment control, Nexus saves developers time while also allowing for customization and ownership of the deployed infrastructure. With its user-friendly command-line interface, local dashboard, and support for various data sources, Nexus offers a streamlined experience from initial setup to deployment. In this coding Capstone project, we focused on both the individual and unified schema levels. For example, we added an authorization middleware function to the unified schema to prevent unauthorized access. Once the schemas were generated and combined, the local GraphQL server was ready for deployment.

To deploy the server for the user, we needed a reliable way to deploy their application code on their AWS infrastructure. Since we generated the GraphQL server on the user's local machine, we chose to deploy the server using containerization. This involved encapsulating the application code, libraries, and dependencies required for the software to run. Docker, an open-source implementation for containerization, was used for this process.

Docker introduced several key terms, including images, image repositories, and containers. An image is like a blueprint of the application, including all the dependencies. We stored Docker images in a repository, similar to how we store source code on remote repositories like GitHub. Containers are created from images and run the actual application code. By pulling the Docker image from the repository onto a cloud machine, we were able to run the application.

For the deployment workflow, we provisioned AWS services to get the server up and running. We started by locally building a Docker image from the generated GraphQL API server. Next, we used Terraform, an infrastructure as code tool, to create a private image repository on Amazon's Elastic Container Registry.

Instead of using AWS's CloudFormation, we chose Terraform to allow for multi-cloud deployment in the future. Additionally, we used the AWS CLI to push the Docker image to the newly created private repository. AWS Elastic Container Service and Fargate were provisioned using Terraform to make managing and scaling containers easier.

Fargate works alongside Elastic Container Service to provision and manage all the infrastructure required to run the container. This setup allowed developers to spend less time managing resources while still having the ability to make changes or scale in the future. Nexus also handled the setup of related infrastructure components, such as virtual private cloud, subnets, internet gateway, security group, router, and routing table.

After deployment, we encountered several technical challenges. One challenge was facilitating advanced server configuration through the dashboard. We wanted to make the process easier for the user, who would otherwise have to go through many steps using the command line.

To address this, we developed a dynamic form in the dashboard that allowed users to quickly test their configurations. This way, they could make changes and immediately test them without relying solely on the command line.

Another challenge was connecting data across different sources. Although the data sources were combined in the unified schema, the relationships between them were not automatically recognized. This led to over-fetching of data, which we wanted to avoid.

To help users establish these relationships within their GraphQL server, we created a form on the dashboard. This form allowed users to specify the types they wanted to associate and display the available fields for each type. By understanding how the data was associated, we could build the necessary connections in the GraphQL schema.

When making changes to the server on the dashboard, it was crucial to test these changes locally. We implemented a hot-reloading function to keep the server up to date without shutting down the dashboard. This ensured that the user's local test server was always synchronized with the current configuration.

In addition to hot-reloading, we needed a way to remind users to redeploy their changes to their deployed architecture. We implemented a change notification system that alerted users when their local server was out of sync with the deployed server. Users could initiate redeployment through the alert and lock the dashboard's deploy and redeploy functionality until it was successful.

Overall, Nexus was designed to serve as a framework for generating a GraphQL API from multiple data sources and deploying it to the user's AWS account. It aimed to combine the benefits of extendability and ownership of open-source libraries with the deployment abstractions of a managed service. By simplifying the setup process, Nexus helped developers save time and made generator and deployment tools easier to use.

Thank you for joining us in this presentation. We appreciate your support and would now like to open the floor to questions. During the project, we decided to stick with an open source tool that was a perfect fit for our needs. The tool provided the necessary sources for our project. Moving on to the second question, we did create a way for the user to enter the data Association and auto-generate resolvers. We initially used Postgres connections, which presented an interesting challenge. When connecting data sources, we encountered a common problem. Once the fields were connected, we started requesting data from multiple sources within the same nested query. This created an N plus one problem, as we had to fetch data from a cart that returned three books, and then individually fetch each book from the second data source. To address this, we implemented filtering options and additional configuration during the transformation from individual schema to unified schema. This allowed us to add an additional resolver to retrieve the necessary data from the source, without creating the N plus one problem for the user. Ultimately, we were able to auto-create resolvers that didn't exist in the originally generated schema.

Regarding extendability, it was a significant concern when comparing solutions and creating Nexus. The question arises as to whether there are use cases that can afford to ignore extendability. The answer depends on several factors. If a team already knows what they will need in the future and have no plans for changes, they may not require extendability. For example, if they opt for a fully managed service that only supports Postgres, and they are an established team, then extendability may not be necessary. However, for smaller teams that are just starting out and may need to incorporate additional GraphQL APIs or databases in the future, extendability becomes vital. It provides flexibility for future changes and expansions. Ultimately, it depends on the specific circumstances and requirements of each team.

Regarding managed services, we explored some options that had upcoming support for data sources like MongoDB. However, we also found articles from two years ago that mentioned "coming soon" for MongoDB support. This highlights the challenge of relying on a fully managed service for data sources. By choosing such a service, teams relinquish control and must rely on the service provider to support the required features. One alternative is to generate a separate API from a different service that supports the desired data source. However, this would require migrating all the settings and setup from one service to another, or operating two separate services with different endpoints. These considerations played a role in our decision-making process when it came to extendability.

We would like to express our gratitude to everyone who attended this presentation. We truly appreciate your presence and the opportunity to share our project with you. Thank you all for joining us, and have a great day! Goodbye!