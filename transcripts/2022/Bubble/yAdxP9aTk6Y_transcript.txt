hi everyone welcome thank you for joining us my name is jessica and i'm here with my colleagues julia andrew and missy and today we'll be presenting bubble bubble is an automated open source solution for deploying dynamic front-end preview apps we're going to start with a brief overview of the history of web development to provide some context around the type of apps bubble supports then we'll get into the problem bubble solves and an example of an organization that may encounter that problem before explaining further what preview apps are and taking a look at existing solutions within the preview app space next we'll introduce you to the features bubble offers and give a brief demo on how to use it followed by a section on how we built bubble including the design decisions and tradeoffs we made finally we'll dive into challenges we encountered during implementation and how we like to expand and improve upon bubble in the future to understand bubble's use case we'll need to be familiar with the web development architecture a typical bubble users application would be built with let's take a step back and walk through a brief history of how web development approaches have evolved over time the traditional approach for building web applications was based on a process called server side rendering or ssr with ssr when a client for example a user's browser requests a page from a website the server is responsible for fetching any necessary data in regards to the specific requests from the database generating the html components with the retrieve data and assets and then sending back the fully generated html files to the client so they can be displayed to the user with every incoming request from the client the server is kept busy repeating the heavy lifting of retrieving data and generating pages as websites grew to serve more content it became clear that some of it didn't necessarily need to be completely dynamic meaning there would be little to no changes required for some pages on every request for example consider a company landing page or a blog post where the content of these pages can largely stay the same regardless of who's requesting it it would be inefficient to have the server dynamically generate these kinds of static pages each time a client makes a request this led to the rise in popularity of static site generation or ssg with statically generated sites html pages are pre-built before a user ever makes a request for them at build time a server is responsible for retrieving data and fully generating the html this process is very similar to server-side rendering but the key difference lies in when the server carries out this responsibility with ssr this happens at request time but with ssg the html is generated before it's ever requested the pre-built html and other necessary assets are then cached in a cdn a content delivery network a cdn is a geographically distributed group of servers that can quickly deliver content from a location close to the client at request time now that we have an idea of how each approach works we can take a look at what types of applications would be better served by each strategy both ssr and ssg are beneficial for apps that value search engine optimization or seo as the html sent back to the client is fully formed for web crawlers to parse and index from there the use cases differ only server-side rendering makes it possible to dynamically retrieve data without needing to make a public api call using client-side javascript this is necessary for apps that use secrets that shouldn't be publicly accessible server-side rendering is a good fit for apps whose page content needs to remain up to date since the server regenerates the page on every single request in contrast static site generation isn't well suited for frequent changes since a build and deployment process must be executed each time a page's content needs to be updated static site generation is particularly useful for sites that require fast page loads since pages are very quickly served by a cdn with server-side rendering even though initial page loads are typically fast there may be slower subsequent loading times in addition ssr can lead to servers being overloaded during periods of high traffic since they always have to generate the html at request time with ssg there is no need for a server at request time since generating the html was done beforehand finally ssg is a better fit for scaling for many users since cdns by default can handle increased traffic at scale an ssr architecture by nature does not have the same benefit historically applications could be categorized into using either ssr or ssg however modern web development frameworks have recently begun to blur the lines between static and dynamic applications in order to bring about more flexibility and allow developers to fully optimize how a user interacts with an application some examples of popular frameworks which support a hybrid approach combining both server-side rendering and static site generation are next js gatsby and vue for applications that are content-rich but only require frequent dynamic data retrieval for select pages it makes sense to use static site generation to pre-build simpler static pages in order to be able to serve those up quickly while employing server-side rendering for pages requiring frequently changes up-to-date content on demand a common real-world use case for this blended approach is with e-commerce applications let's consider a hypothetical company named giraffe as an example to better illustrate bubble's use case giraffe is an e-commerce application that sells giraffe-related merchandise they self-host an online storefront implemented with the next.js framework their application uses a mix of static site generation and server side rendering to generate content for example the product categories page is generated through ssg while product recommendation pages which are unique to every user are generated with ssr recently draft's been doing very well they've hired additional engineers to develop new features and bring a new look to their website but they're starting to experience bottlenecks during the development process since multiple developers often work on new features simultaneously and also need to collaborate with various other departments collecting feedback from different teams is starting to take too long or lead to a lot of back and forth even for very simple ui changes at this point giraffe's wondering what can they do to streamline this process prior to the recent expansions in their organization and additions to their site sharing progress was easier for developers at giraffe they use manual approaches like sending screenshots to each other or screen sharing for interactive features occasionally when non-technical stakeholders from other teams wanted to look at the progress more closely developers would take the time to help them pull down the code and run it on their local machine however with larger teams including remote colleagues and more non-technical stakeholders who need to approve changes it's no longer practical to spend increasing amounts of developer time helping colleagues download and run local versions of the application to review changes one tool that giraffe uses as part of their development workflow is a shared staging environment this is an environment shared amongst all developers collaborating on a repository a shared staging environment aims to mimic the production environment as closely as possible to ensure all new changes are working as intended before they are released live different types of testing can occur when code is pushed to this kind of environment for example load testing to simulate real-life traffic and determine a website's performance under such conditions using a shared staging environment gives non-technical stakeholders a way to examine changes without having to build and run the application themselves allowing them to examine in development ui and ux changes and give feedback so modifications can be made however having multiple teams adding different changes to a single environment presented another set of challenges to giraffe's workflow since there is only one staging environment for giraffes developers to use all newly developed features ended up living together intermingled within a single environment batching together multiple distinct changes in this way caused bugs to arise that were difficult to troubleshoot because they could have stemmed from conflicts between any of the coded updates pushed to the staging environment by different developers this type of workflow also led to less frequent and more bloated releases when there's one centralized environment for non-technical stakeholders to use review tends to happen in larger batches and when something went wrong and a release needed to be rolled back it was much more challenging since the releases weren't in atomic attempt to resolve these issues giraffe switched to queuing instead having only one development team at a time use the staging environment this avoided the bugs conflicts and bloated releases that occurred when distinct changes were all bashed together but in turn has added a different set of problems to their development workflow with only one team being allowed to use the shared environment at a time developers now have to wait for the environment to be freed up before they can use it one side effect of queuing is a higher risk of deploying unsafe code if a developer mistakenly rushes to deploy another colleague's work in an attempt to free up the staging environment for their own use another consequence of queuing has seen that valuable developer time is wasted long feedback loops have occurred since any previous changes need to be completed and moved out of the shared staging environment before the next in line change can be reviewed now i'm going to hand it off to missy who will introduce us to what preview ups are and how they can reduce some of these issues giraffe has encountered thank you jess because of the challenges associated with using their shared staging environment to iterate on ui ux changes giraffe is looking for other options that could allow them to shorten their feedback loop and reduce bugs preview apps are one way to allow non-technical stakeholders to look at ui ux changes faster so this feedback loop can be shortened let's take a look at preview apps in more detail preview apps are ephemeral lightweight and fully functional versions of an application that can be easily built and deployed and just as easily torn down with preview apps multiple versions of a site can be quickly deployed in isolation so non-technical stakeholders can more easily give feedback on ui ux changes and developers can more quickly iterate after receiving that feedback using preview apps every time a new change is ready to be previewed a giraffe developer can deploy a new preview app and share its url with all relevant stakeholders for evaluation here's an example of a development workflow using preview apps when a developer is ready to share their new feature they initiate a pull request for their feature branch a preview app is automatically built and deployed with the new feature code and a unique url is generated to access each preview app product managers and non-technical teams interested in the feature use this url for reviewing the changes the developer makes any necessary code revisions based on resulting feedback and then commits to the same feature branch a new preview app is deployed containing the new revisions and it has its own distinct url the changes can be previewed once more and different iterations of the feature can be compared side by side using their corresponding preview app urls this feedback loop using preview apps continues until all stakeholders are happy with the new feature at which point the code can proceed to the next step in the development pipeline once the developer merges their feature branch the pull request is closed and any connected preview apps are automatically torn down preview apps help to reduce some of the headaches that occur when stakeholders use a shared staging environment to review and discuss uiux changes each new feature can be reviewed in isolation from other app changes that are still under development eliminating the chances for hard to track down bugs that may crop up from code conflicts with other new features in addition since each developer can deploy and share a preview app for each new feature as frequently as they'd like they can receive feedback from all stakeholders faster leading to a more efficient development process with a shortened feedback loop while prevaps help to streamline the process for developing front-end features they may not be the right choice for everyone since they're intended for testing new features in isolation previoups aren't a good fit for testing how multiple changes would integrate with one another they also incur costs as additional infrastructure is provisioned for each preview deployment and since each preview app has its own url interested parties need to manage multiple links which could get unwieldy as more previews are deployed preview apps come with additional drawbacks depending on whether a team chooses a third-party preview app service or decides to diy their own the former racks up more costs in the form of usage fees and requires that the code and data are shared externally with the preview app provider which may be a concern for some organizations the diy solution adds labor and opportunity costs in the form of development time as the landscape of web development has changed and the lines between ssr and ssg have become blurred the requirements for preview apps have grown if only ssg static site generation is used all that a preview app would need is a cdn to deliver static assets for only ssr server-side rendering an application would only require a server however to support applications which utilize ssr and ssg together in a hybrid approach preview app architecture must include both an application server and a cdn and this adds significant complexity since giraffe's site uses both ssr and ssg we'll need to find a preview app provider that can handle this complexity to allow them to benefit from fully functional preview apps let's explore the existing solutions for preview apps and see how they might impact the development workflow of a company like giraffe one option would be the diy approach building their own system would allow giraffe to customize things according to their exact needs while maintaining full control of their code and preview app infrastructure the downside is that it's a time-consuming and complex task to make all the necessary decisions and build out all the components necessary to implement fully functional preview apps to construct their diy solution giraffe would need to examine multiple sets of trade-offs to decide where and how to build and deploy their preview apps with their design decisions made they would then need to implement their system which would include configuring building and deploying static assets routing and business logic as well as writing code to automate this entire process and integrate it into their development workflow given the time and resources it would take to implement their own system giraffe might prefer to look at already made options preview app solutions typically fall into two categories feature and service both offer a variety of features and provide dynamic front-end preview apps that support any combination of implementations including ssr and ssg the first category preview apps as a feature refers to preview app functionality that is included as part of a hosting platform preview apps as a feature are generally easy to set up and use and offer an abundance of functionality however they require a company's code and data to be hosted and deployed using that provider's infrastructure if a company is already using a platform like vercell or netlify it would be simple for them to leverage the preview app features they already have access to but changing hosting providers is a large and complex undertaking and it typically doesn't make sense to do so for the sole purpose of using preview apps the other category is preview apps as a service these are standalone options which can be used on their own without changing hosting platforms as a separate service these options require more setup time and configuration often requiring the user to write custom files before preview apps can be built and deployed these options are also typically subscription based requiring payment for the service regardless of how much or how little it is being used out of all the currently available preview apps solutions only one git lab is open source and it provides preview apps as a feature so it means that code has to be hosted on its platform to access its preview app functionality now andrew is going to show us how our solution bubble fits into the mix thanks missy bubble provides another way for giraffe to benefit from preview apps with a different set of trade-offs than existing solutions or implementing their own from scratch let's take a look at how bubble compares to the solutions we've already discussed bubble combines some of the benefits of both preview apps as a feature and a diy approach at the cost of supporting fewer features the benefits of using bubble are that a company like giraffe can have preview app functionality that's easy to set up and use like preview apps as a feature while maintaining complete control of their own code and data like a diy approach the trade-off is that bubble won't be completely customized in the same way a made from scratch solution would be nor does it support the range of languages and frameworks that a hosting platform would bubble has several important features it automatically deploys preview apps when a pull request is opened as well as when subsequent commits are made to a branch associated with the pull request each deployment generates a shareable url that will be posted on github as a pull request comment when the branch is merged or the pull request is closed all associated preview apps will automatically be torn down bubble also provides two user interfaces a visual dashboard where the user can manage preview apps across all their local repositories and a command line interface or cli where the user can interact with the preview apps for one repository at a time from its directory let's take a look at a few of bubble's features in action in order to integrate bubble with an application the user will need an aws account configured with the aws cli a github repository for an application built with next.js and a github token providing access to their repos the user will first execute bubble init in the project directory this command initializes all necessary local files sets up authorization information that's needed to provision the aws resources for preview apps and creates a dynamodb table to store preview app metadata once bubble is initialized in the project repository and its files have been pushed to github opening a pull request on a new branch will automatically trigger the deployment of a preview app whose unique url will be added to github the developer can then share this link and anyone can navigate through the fully functional app and preview the changes as needed additional commits to any branch with an open pull request will trigger deployment of another separate preview app with its own distinct url these preview apps will remain live until the pull request is merged or closed or the user elects to manually destroy their preview apps users can deploy as many preview apps across as many branches as they need bubble also includes a dashboard which provides preview app management across all bubble integrated repositories through the dashboard users are able to navigate to any of their preview apps as well as the build logs for each deployment the dashboard also provides an easy interface through which users can destroy all preview apps associated with a particular repository now let's take a deeper look at how we built bubble bubble consists of three main pieces of architecture a local user interface github and aws the first piece the user interface consists of two parts located on the user's local machine once bubble is globally installed as an npm package the user can then access the cli to initialize an instance of bubble in a repository directory this adds necessary files to the local repo and updates files for the dashboard to use the dashboard is a locally run web application that provides a user-friendly visual interface for viewing managing and destroying preview apps it combines a backend to make api calls to aws and a front head for the user to view in their browser the second piece of our architecture uses github bubble uses github actions to automate the build deploy and destroy process for preview apps these actions execute workflow files added by bubble which are triggered through initial pull requests subsequent commits on branches with existing pull requests or http requests to github servers sent via the bubble cli github actions run on their own servers so github takes care of spinning them up and down and executing the workflow code the final piece of our architecture uses several aws services in order to deploy the infrastructure for all preview apps each individual preview app consists of three aws microservices server-side rendering logic and api routes are deployed to lambda at edge functions as three buckets store static assets such as images and pre-built files and cloudfront serves both static and dynamic content by associating the functions and s3 buckets to each route of each preview all preview apps and repository share two additional aws services the aws commands executed by bubble are carried out through im users endowed only with the permissions needed in order to create manage and destroy bubble preview apps and dynamodb tables are provisioned to persist and store metadata related to users preview apps so they can be easily managed and later torn down now that we have a high level overview of the various pieces of our architecture let's zoom in further on the github and aws components to examine some of the trade-offs and design decisions we made in regards to where and how to build and deploy our preview apps the first major design decision we tackled was where the build process should take place bubble automatically builds preview apps on two triggers one is the opening of a new pull request and the other is subsequent commits to a branch with an open pull request since these events occur within the context of a github repository we had to decide where we would be able to execute the build process as an automated response to these events github actions proved to be well suited to our use case it's an automation tool that allows users to execute code written in files called workflows using github runners which are temporary virtual servers that github spins up and down here's how this process works a bubble workflow file in the user's repository is set to listen for pull requests when a pull request is opened the workflow is triggered and github automatically spins up a runner to execute that workflow which then builds and deploys the preview app after this process is complete the github runner is automatically spun down instead of having to provision and configure our own external build server to run each build process which would add unnecessary complexity and setup work to our architecture github actions provided a simpler way to integrate with github and carry out the build process directly within the context of a repository as with most engineering decisions there are trade-offs associated with using github actions one challenge with using github runners is that they are entirely managed by github and thus cannot be accessed directly making it difficult to extract outputs and other environmental artifacts in addition development is much more constrained than it would be if we were configuring our own build server since workflows can only be defined with yaml files however the benefits of using github actions ultimately outweighed these drawbacks when it came to bubble's needs github actions includes a free tier that we estimate provides enough compute to make building and deploying preview apps very inexpensive if not free for a typical midsize team using bubble relying on github runners is also much simpler than implementing and configuring our own build server and so it abstracts complexity away from our architecture finally since each section in a workflow file can be run on a separate github runner github actions allows bubble to deploy and tear down preview apps in parallel making this process more efficient after determining where our builds will take place we next how to determine how to build the preview apps and where to deploy them recall that the essential architectural component differentiating a static front-end application from a more complex dynamic one is the need for an application server to generate ssr pages at request time since bubble aims to let users share new ui and ux features quickly and conveniently we considered options that would allow us to build and deploy applications including their own servers in a lightweight and cost efficient manner one option would be to deploy the server side logic and static assets together in a container a container encapsulates both the application code and all run time elements necessary to execute it together in one package with containers we wouldn't need to set up and configure multiple nodes of infrastructure or implement routing logic to connect them instead we'd be able to deploy only one single entity for each preview app as the entire application could be spun up in the container as a whole since there's only one piece to consider containers can easily be moved around and deployed however containers are constantly running and would therefore incur cost even when no one is using application they also have longer build times since the virtualized os and runtime need to be built and packaged together on top of the preview app itself an alternative to containers would be deploying the server-side logic and static assets to separate services given our use case of providing temporary preview apps we found serverless functions to be the most compelling option for deploying server-side logic despite being called serverless these functions do actually run on servers but they abstract away the logistics of provisioning server resources there are no ongoing expenses developers are only charged for the server capacity that their application uses during the time it's actually being executed since they don't need to include system dependencies serverless functions are also very fast to deploy typically going live within milliseconds one downside for serverless functions is the added complexity of the architecture for preview apps as opposed to containers using serverless functions requires multiple nodes of infrastructure as well as routing logic to direct traffic between them another inherent drawback is what's called cold starts since serverless functions aren't constantly running they have to be spun up before beginning execution this can sometimes take several seconds which can lead to longer loading times for server side rendered pages ultimately we chose to use serverless functions rather than containers bubbles preview apps do not need to be highly performant so cold starts are acceptable in terms of the architectural complexity although serverless functions necessitate additional infrastructure being able to use separate services for ssr and ssg allows us to fully optimize for this hybrid approach as we delved further into utilizing serverless functions for our preview apps we considered three open source frameworks to help automate deployment now our teammate julia will dive more into these options as well as some challenges we encountered during implementation thank you andrew terraform is the first tool we considered terraform is an infrastructure as code framework used to manage the lifecycle of cloud components there are many existing modules of terraform for deploying front-end applications that are free to utilize and actively maintained compared to other solutions one of the most promising modules we found uses a more complex architecture to deploy apps the aws services used include cloudfront to handle incoming traffic a lambda and edge function that acts as a proxy handler to rail requests an s3 bucket for static content storage lambda functions for serving the dynamic ssr pages and an api gateway that balances traffic between the lambda functions the cost of this heavy underlying infrastructure is lengthy deployment times during our test runs using this module with multiple applications we found that deploying one simple app would take more than 15 minutes we also encountered a few deployment failures which were challenging to debug because of this complexity and ultimately led us to question the reliability of this option front and application bundle also called fab is another open source framework that enables users to deploy front-end applications through a cli fab zips up the entire application and ships static assets and server side logic separately thus the user has the option to choose separate platforms for serving static and dynamic content for example they could deploy static assets to aws s3 while deploying serverless functions with cloudflare cloudflare workers although it aims to be platform agnostic for serverless functions fab is currently only streamlined for cloudflare workers and aws lambdas when using fab to deploy a few test applications it took no more than five minutes to deploy each app which is significantly faster than other tools we considered especially terraform however unlike other options fab has not been maintained for more more than a year and a half the final option we considered was serverless framework serverless framework deploys apps using only three aws services cloudfront lambda at edge and s3 this is a simpler architecture in comparison to the terraform module which may be a contributing factor to its faster deployment time while provisioning the cloudfront distribution does take a few minutes it still took less than half the time to deploy compared to terraform one downside of using serverless framework is that unlike the flexibility of fab it currently only supports deployment on aws infrastructure moreover server side logic can only be deployed to lambda at edge functions however while fab is no longer actively maintained serverless framework has continued to be a reliable framework considering how many people use it the maintainers are still active and this latest version was released just a few months ago in march 2022 in the end we decided to go with serverless framework to build and deploy bubbles preview apps due to its reliability relatively fast deployment time and simplified architecture which would best serve bubble's goal of automating lightweight and convenient preview apps now that we've explored how bubble works and some of the design decisions we made let's dive further into two of the challenges we encountered during implementation one of these challenges occurred when we were deleting preview apps we decided to use the same mechanism to tear down preview apps through triggering github action workflow files the workflows can be triggered automatically by the closing of a pull request or manually with the bubble destroy cli command when the workflow to destroy a preview app is executed all aws resources provisioned for that preview app should be torn down as we've mentioned these resources include ds3 bucket storage cloudfront distribution and lambda at edge functions aws associates lambdas with a cloudfront distribution so the order in which we delete each resource is important in our bubble destroy implementation we first request the aws removed s3 bucket storage and then the cloudfront distribution and finally the lambdas however even when the cloudfront distributions are successfully deleted issues often occur when we attempt to delete a lambdas they often require additional weight before they can be deleted this amount of time can range anywhere from a few hours to a day upon further research we learned this this is an aws limitation when working with lambda and edge functions so we had to find a solution to work around this issue one solution we considered was polling repeatedly trying to delete the lambdas and checking whether or not the attempt was successful this would involve setting up a process often referred to as a crown job which enables developers to automatically and repeatedly execute scripts at specified times with this approach whenever the user executes the bubble destroy command bubble will set up a crown job which would try deleting lambdas periodically in the background until none remain the downside to this approach is that crown jobs run on operating system and thus will need to be configured differently depending on the user's os multiple implementations would have to be developed for different systems all of them including the crown job itself as well as manually setting up logging in case of errors monitoring these logs and adding additional logic to restart a job if the computer is rebooted rather than relying on the user's local machine another possibility would be implementing a crown job on aws however this would increase costs for the user and become yet another cloud component to manage we decided to take another approach for this specific task instead of crown jobs we decided to add an additional command named bubble teardown which users can run themselves sometime after running bubble destroy in order to remove any remaining lambda and edge functions to make this change we had to adjust how we maintained the information necessary to tell aws to remove these functions we decided to add an additional table to the dynamodb database to store metadata for each lambda which made which meant we also had to alter the workflow for building and deploying preview apps so that this lambda metadata was saved during each deployment this new table is now used when the user runs bubble teardown so the bubble can tell aws which functions to delete the table is then removed once all functions are successfully deleted modifying our build workflow and adding this additional table slightly increased the complexity of our application but we felt it was simpler than implementing multiple crown jobs and the logic it would take to monitor and eventually remove them from the user system or aws another challenge we experienced involved capturing the preview app's build logs and integrating them into our dashboard our initial plan was to capture and parse the logs so that we could include them in full on the dashboard but this turned out to be surprisingly difficult to implement as previously discussed we use github action to deploy and build preview apps but a downside of using it is the opaque nature of its runtime environment our first attempts to capture the logs during the build process were unsuccessful because the action run logs are only available via an api call after the entire execution had finished we ended up having to cache the run id for each workflow on github and then implement an entirely separate workflow which which was triggered immediately after each build action finished this allowed us to access the build logs in their entirety within the new workflow the next hurdle after retrieving the logs was cleaning and parsing them as part of displaying workflow execution logs on their site github injects a variety of metadata and special character sequences these sequences are useful for github's web app but they lead to numerous string parsing errors when handled within a workflow on a github runner trying to parse these logs with a painstaking process of manually going through thousands of lines of logs and attempting to eliminate these inserted characters without removing meaningful log data the number of edge cases that required special handling kept growing and growing with no end in sight with increasing engineering complexity for this feature in addition to the costs that would incur from storing logs we decided to reconsider this approach instead of processing the logs ourselves and making them available in full on the bubble dashboard we decided to take to add a link on the dashboard for each preview apps build log when followed this link takes the user directly to the github workflow run where they have the option to download the logs for that specific preview app although this option requires a couple more clicks for the user it significantly reduces the complexity of bubble itself as well as the storage needs and costs of the user's aws account now that we are well acquainted with bubble and the design decisions that went into building it we would like to briefly mention some features we want to include in the future at the moment bubble only supports applications built with the next.js framework we would like to eventually add support for other front-end frameworks such as gas b and view our dashboard feature can only be viewed by the developer who installed bubble in the future we would like the dashboard to be more distributed so that developers from the same team can share one dashboard to manage and view their preview apps in one one place finally bubbles preview apps are currently only deployed on aws infrastructure but we will be interested in exploring how to integrate our solution with alternative cloud providers such as cloudflare and google cloud now thank you to thank you for listening to our presentation we will now open up for questions okay looks like we've got one um carl says awesome job looks like an amazing project thank you carl would love to hear more about the cli feature how did you approach this for example did you use a cli framework like oh cliff and what were the challenges around that task i guess i'll go ahead and jump in um and answer that one so we did not use a um an oak cliff framework i think one of the um or we didn't use any frameworks including including that one that i've i've not heard of carl some of the challenges were kind of bouncing back and forth between using um github actions and just being able to program in javascript so um our command line interface is an npm package and for some of the there's a collection of um commands that we make available and we'll um we kind of outline those a bit more in detail on our bubble case study which we'll make available at some point in the future um and so for some of the commands we were able to kind of just write out the application logic um in javascript and we're able to use things like um the aws command line interface tool as well and so we kind of had to just bounce back and forth between sometimes um coding a bit more freely using javascript and sometimes needing to execute those workflow files that we mentioned via github actions and in that case the environment's a little bit trickier to deal with since like we said we kind of have to use those constraints that github enforces i'm not sure if any of my other teammates have anything to add to that question specifically before we move on to the next one yeah i'd echo that busy i think too we we also like talked a bit about just what commands like in general we should implement when setting up the cli and and how we could kind of just let the user do everything they would need to do um in regards to preview apps directly from the command line but but try to like make that process as easy as possible for them and automate that so we did have to kind of consider how to save down like the github access token and like the aws credentials and everything and where to store those whether locally or um in like the github secrets in order to be able to kind of automate that whole process so i think that was a bit challenging as well in addition to working with the workflows like missy mentioned oh yeah there was a we definitely had a lot of conversations around um basically where we were gonna store all that sensitive information that we need to um basically do anything um in aws on behalf of the user um so that was kind of actually one of the conversations we spent i'd say longer amount of time on okay um audrey's wondering what part of building bubble did you find the most interesting or exciting um maybe i would jump beyond that one i guess together with juan's question as well it might be a very similar answer i think there's two parts i found exciting interesting to do was when i was finding the open source looking at other open source projects that were deploying deploying in xjs framework applications specifically um i think partially is to look at the trade-offs between those projects and how other people approached it and if it was a good use case for our project um it partially verified our thesis on why people actually need it or what use our open source project and partially it was also a very agonizing process of trying out all these different frameworks and each one took a very long time some of them took a very long time to deploy and and didn't even work at the end and trying to figure out why it didn't work and perhaps what we could learn from all those failures ourselves um i think second part that was interesting to do was when we implemented the dashboard we were if initially very ambitious about different all those things we could add to the dashboard and maybe even have our own database for the dashboard um but one thing we learned from that when we discussed we are with our mentor was maybe stop making assumptions on what the user might need because all of these we were assuming oh they might need this they might need that but at the end of the day um maybe we were just adding additional work for ourselves without actually verifying it would that be a useful feature so that process was very interesting to me as well totally agree um i'd say one of the most interesting parts for me too was just um i think for all of us this was the first time collaborating uh on a technical team and so it was really it felt really good once we got into a groove um and kind of just knew what we had to do knew who who was doing what um and were able to like comfortably collaborate with each other i found that super enjoyable yeah i would echo that it was really uh nice to get experience on a larger scope of a project and um practice working together and you know integrating different tools like saying synced up on slack and i'm using github issues all these kinds of things um i think the the most exciting thing for me was probably seeing everything come together and it kind of felt like one of those things where we just kept crunching along and then all of a sudden things kind of seemed to almost everything just kind of came together and that was that was really really fun um it's also interesting talking about the like thinking of the complexity of just even if one single piece is relatively simple to work with on its own like putting together all these different things like a command line interface or then working with github or working with aws or this other framework it's interesting how much adding different pieces can really impact the complexity of your overall approach that really struck me yeah and i'd echo everything that you all just said um i i think like from a technical perspective something like really specific was just working with github actions like as tedious as it was to to work with and to be able to like test out our project with it um that was really interesting to kind of learn how to work with and then from like a non-technical perspective just learning how to work with a team i think capstone like kind of helped prepare us because we had like the request in project and um like the react weeks could kind of like figure out how how we work together as a group of four and then also like in pairs um and so we kind of like brought that over when we started working full time on our project so it was kind of really nice learning how to kind of collaborate with one another especially in different time zones and everything yeah okay so moving on uh audrey loves the giraffes thank you audrey arthur says love the idea for a table for storing metadata how did you arrive at that solution any future ideas for using that table for anything besides deleting lambdas so who wants to think we can all like pounce on that question but who wants to go for it uh we've actually used two different tables but mainly the tables are used for storing all the metadata related to each preview apps so that when we actually deleting them we have a mapping of where each resource is at is and then where what's the id for that resource um future ideas for using that table we initially when we wanted to distribute the dashboard a bit more widely so that different users can potentially share the dashboard together that might if we decided to go down that route we would have used table to store all kinds of user user related data as well um well that came up a lot of different trade-offs too because we weren't sure if the user would like that to begin with maybe they don't want to store their aws or github related keys in other people's database um but otherwise that would be something to do in the future in terms of the tables okay uh max is talking about the process max is asking about the process of deploying the serverless functions how did you parse the next js files to determine what functions to deploy um so i can i can jump in on that one thankfully we did not have to parse the next js files to determine which functions to deploy um because that's actually one of the amazing things about the serverless framework that we chose is that it actually does go through and determine what needs to be um what's service side logic and what can be um start from the cdn so um that was that was kind of a big decision for us actually in whether we were going to go through and manually um split up those two different types of logic ourselves and parsh through and do that um or whether we could get a framework to do it for us and so we were definitely hoping for the latter um just so that we wouldn't have to reinvent the wheel um and luckily serverless was able to was able to help us with that next.js um does i believe and and either just or andrew can jump in if i'm not doing this justice but um nextgs does i believe have a serverless mode that you can select to build so it will actually like um build out your files and more neatly sort of separate the server side logic from the uh the pages that would be statically generated um so if we did had to go through and parse them i don't think it would have been too too tricky but it might have just added a bit more of a extra step there okay um what was the most challenging part of working with aws um oh sorry go ahead okay just maybe a few points uh from me i find one is i actually don't think their documentation is that great every time we're looking for answers it seems to be answers are all over the place you would imagine them at one webpage but that's not really the case um i think second part is also even though it's such a large organization um you would assume their products are very complete has less holes but even like with that lambda situation we encountered we were really surprised about it because a lot of people had the same issues and it seems like an obvious thing to fix but they didn't really fix it um that was surprising yeah we were a bit surprised with that a specific issue i'd actually found at least a couple of instances where folks had to actually call an aws representative on the phone to delete their lambdas for them um so yeah definitely that was one that was a moment where we're like really aw aws doesn't like this provide the service or it doesn't work in this way that we're expecting it to and if you know of course we have um we're not we don't know all the complexity that's lurking underneath but it was a bit surprising all right well thank you so much everyone for coming and listening to our presentation encouraging us and questioning us it was a lot of fun um creating it and presenting it to you all 