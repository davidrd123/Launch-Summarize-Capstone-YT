[Music] hi everyone welcome and thank you for being here today today we're going to be presenting waypost an open source feature flag management platform that specializes in a b testing so my name is julia and i along with my colleagues sean and caleb have spent the last couple of months creating we post i'm going to start us off by giving an overview of the problem that waypoint solves and the kind of organization that will run into this problem and then i'll go in depth into the topics of a b testing and feature flags and the solutions for implementing them and after that i'll go over the pros and cons of each solution next sean is going to explain how he designed wave posts to solve the problem for our use case and he'll also give a demo of how to use weight post lastly caleb will talk about the engineering decisions and discussions we went through while designing weight post and finally we'll open the floor to any questions throughout this presentation we'll be using the terms feature and new feature a lot we define feature as a distinguishing characteristic of a software item like performance portability or functionality so a new feature can be thought of as some change to the functionality of an application whether it's an additional feature or just an upgrade to an existing feature this could be small and simple like a ui change or something big and complex like a new algorithm or way to log in as development teams create new features they want to have confidence that their design decisions benefit the business this means that they'll need to make data-driven decisions to do this they'll need to analyze the behavior of their application's users to gain insights on whether their design choices are helping hurting or having no effect at all this means that the team will have to run experiments that consist of serving their users two versions of the application the new one in the existing one and collect data from both versions wepost allows developers to use feature flags to deliver two versions of their application they can run experiments and view the results to help make informed decisions and if a new feature has bugs or performance issues they can easily toggle it off now to demonstrate why an organization would use waypost we'll take a look at a hypothetical solar panel company called solar flare one way solar flare generates sales is through a feature that estimates how much money a solar panel installation costs currently customers do this by entering information into a form and then hitting calculate but after collecting user event data on this process the solar flare dev team discovers that 80 of people who start filling out the form never finish it's theorized that the reason for this is that filling out the form is too tedious for customers to increase the odds that a user submits the form they design a new version which utilizes third-party software to calculate the quote this software only needs the user's address and uses satellite and climate data to make the calculation to know whether their new feature helps more customers complete the form they'll need a way to measure the difference between the old form and the new one let's see how they can do that one option is to roll up the new feature temporarily and measure how the metrics change but there are several problems with this one issue is that our new feature hasn't been tested in production and could have bugs so we don't want it rolled out to everyone at once another important problem is that it doesn't control for external factors like time for example users may be more likely to sign up at different times of the year without controlling for external factors the change in metrics might be attributed to the new feature when it was actually caused by something else therefore we need to make sure the only difference between the two user experiences is the different feature being served to them to do this we'll have to show both features during the same time period and randomize who gets which feature turns out that the solution we're looking for is experimentation also known as a b testing let's now explore the concept of a b testing and its challenges a b testing is a common method used by product development teams to test the impact of a new feature it's experimenting with two or more versions of a feature at once by random randomizing who gets which feature typically you'd show 50 of users version a and fifty percent of users version b then compare some metrics between the two groups you then determine whether there is a significant difference in the metric and how much the difference was we can use this information to make a decision on whether to ship the new feature keep experimenting or stick with the old version just a quick note we'll be using the terms a b test and experiment interchangeably going forward now despite being extremely useful eb testing comes with several challenges first we have to figure out a way to randomly assign users into a group and at the desired proportion then we have to keep track of which group the user is in for each experiment so that they're getting a consistent experience after the user gets exposed to an experiment events have to be logged in the solar flare example we're interested in the form completion rate so we need to log each time a user opens the form and when the user completes the form once the experiment is finished we need to analyze the results somehow this entails calculating the metrics from the user event data we then need to perform some statistics on them to determine if the experiment was successful or not from a statistics standpoint as it stands there are quite a few steps involved in performing a b testing later we'll dive into some solutions that companies currently use before we can dive deeper into how we can analyze experiments we need to first figure out how to implement the two or more versions of the site the best way to do this is using feature flags so what are feature flags a feature flag is a toggle that turns functionality on or off without needing to redeploy there will typically be a tool that allows developers to toggle the feature flag in the app's code it's implemented by writing a conditional statement that evaluates the current status of the flag and wrapping the code for one feature in the true condition while wrapping the code for the other feature in the false condition in the case of solar flare they would render the new form if the conditional returned true and they'd render the old form if the conditional returned false this is perfect for a b testing use case as you can see a company like solar flare would want to use feature flags to help them do a b testing let's look at how they would implement this first they'll want to start with the database to hold the feature flag data and a server that handles queries to the database they'll also need a front end so that developers as well as non-technical people like product managers and marketers can easily view and manage feature clouds using a ui but right now the application will have to query the database whenever a flag is encountered in the code which isn't very scalable so we need to store the flag data in the app and only update it when needed so we'll need a way to share flag updates to the app so that if a flag is switched off users will no longer get the feature this will require something like an sdk which is like a library of code that's imported into the app the sdk will communicate with the backend server to receive up-to-date flags that's the bare minimum for future flags but this still doesn't enable us to do a b testing before we talk about implementing a b testing with our feature flag app we'll need to clarify one term we'll be using which is user event data we will refer to user event data as any data collected about users interactions with a website or app whenever a user visits a site they're identified with an id like a session id or user id whenever they interact with the site data is collected to generate metrics which then get analyzed user events can consist of pretty much any action but some examples are page views clicks signups purchases purchase amount time spent on a page etc so continuing where we left off solarflare now wants to add a b testing capabilities on top of their feature flagging platform so user event data needs to be collected from the client and sent to a database with a data pipeline after we have the data in the database we'll need to calculate the metrics like completion rate and run statistics statistics on them this can be done on the backend server we already have or on a separate one after that the front end should show the results to the developer this is just the bare minimum architecture that a team would need to build and will likely need way more components to handle scaling instead of building your own platform there are also third-party services that you can use we'll go over the pros and cons of each building your own platform comes with many benefits such as having full control over the feature set and being able to customize it exactly to your needs this gives you the flexibility to deploy it however you wish it also allows you to keep your data in-house however the trade-off is that it takes a huge amount of time and resources to build the entire platform from scratch and you have to rely on your own infrastructure and as the ones who created the system you will also be the ones responsible for maintaining it into the future so it's a huge commitment the other option is to use a third-party feature flagging platform that handles the engineering aspects for you so that your team doesn't have to invest time into building and maintaining the system some well known players are launched darkly and optimizely which are both feature-rich and reliable since they were created by industry experts you can typically trust that they're reliable and work correctly they'll also take care of the maintenance and save your team time and resources however these can cost a monthly fee and can be out of budget for smaller companies they're also less flexible in terms of customization than an in-house platform and can end up being a black box where the developer doesn't know exactly how it works also since third-party services usually aren't self-hosted that means they'll be storing your data which not everyone might be comfortable with if solar flare was a bigger company with more engineers then building their own system would be a good option and if they wanted a large set of features quickly and had a larger budget then a paid solution like launch darkly would be a good choice but right now the diy option costs too much time and resources and the paid option is too costly and inflexible for them they also don't need many extra features they just need to run some simple experiments so we saw the opportunity to create a feature flogging platform that fits the needs of a small business like solarflare waypost is self-hosted and open source so it's completely customizable while still containing the core features our target user needs now i'm going to hand it over to sean who's going to talk about wapis architecture thank you julia now that we know how waypost addresses our use case let's find out more about waypost and its architecture first we'll give an overview of waypost architecture and how to deploy weight posts using docker afterwards we'll talk about the individual components of waypost and the roles they play in the overall architecture lastly we'll explain and demonstrate how weigh post allows developers to perform a b tests on their applications this is the full view of weight post architecture i know this is a lot but don't worry we're going to go in depth into each of these components how they interact and how they help our target user manage their feature flags and run experiments as you may notice we have two colors here red and blue the blue components are part of waypost architecture while the red components are something that you the developer are responsible for creating starting on the left here we have our manager application it's a full stack application that's responsible for managing feature flags and experiments the manager app sends copies of the flag data to the flag provider which saves the copy and forwards it to each application running the whey post sdk the sdk which is embedded into your application is responsible for evaluating flags at runtime and thus allowing you to serve multiple versions of your website to your users using your existing user events logging solution your application sends user events to an events database and when you're done running an experiment the manager's backend will query the events database it'll run statistical analysis and then display the results in the ui now i'll show you how to deploy weight posts with docker first you're going to want to clone the waypost docker repo on github then you'll run our docker compose file which will boot up instances of the manager app and the flag provider then go on to install the sdk into your existing application and afterwards you'll want to provide it with the address so that the flag provider and the sdk can connect we'll begin our component deep dives with the manager app the manager application is a full stack application made up of three components a ui a back-end server and a postgresql database it provides a store of your feature flags and allows you to create update and delete them it also allows you to start and stop experiments run statistical analysis and display the results and it provides updated flag data to the flag provider now i'll show you how to manage your feature flags in the ui this is the 5s dashboard you'll be shown this page when you first visit the manager app you can return here at any time by clicking the flags dashboard button located on the nav this dashboard displays all the flags being used by your application from here you can toggle and delete flags if we click create new we can enter in information for a new flat when creating a new flag the most important thing to do is to give it a descriptive name the rest of these fields are optional to view a flag's details you can click its name on the flags dashboard this page allows you to view its details like description and rollout percentage and edit the play this is our flag events page which shows you when any flag was created edited or deleted this page is particularly useful for keeping track of the changing state of all your feature flags and has a drop down menu that allows you to filter events by flagging as we mentioned before the sdk is responsible for evaluating flags so it's important that the sdk has up-to-date flag data but why then do we not just connect the manager app which stores the flat data directly to the sdk this architecture could send updates in real time but it's not very scalable because the specific functionality of managing sdk connections is intertwined with the flag manager's other duties scalability is important in this case because the number of applications running the sdk can fluctuate significantly for this reason we created the flag provider a service that's lightweight scalable it can send updates to the sdk in real time so how does the flag provider serve real-time updates to the sdks whenever there's a change made to the flag data the manager application sends an http request called a web hook with the updated flag data the flag provider then then saves that to its memory and forwards the data to the sdks using server sent events or sse connection and then the sdks save the up-to-date flag data later in this presentation we'll take a closer look into the specifics of how server sent events in web hooks work and the reasons we chose to use them the sdk is a package that's installed into your application it stores a copy of the flag data and it is responsible for evaluating flags to help you render multiple versions of your application and place users in experiments we currently have sdks for react on the client side and node on the server side you can install an sdk into your app using npm we'll now walk you through how waypost sdks render multiple versions of a website for server-side and client-side applications for server-side rendering first a developer installs weipost's node sdk into their application a request comes in the sdk evaluates flags as the application renders the site then the page is sent in the response for client side rendering the developer installs waypost's react sdk into their application the request comes in and the react app is served to the client the react app runs on the client and the sdk evaluates flags as the react application renders the page we know that the sdk is responsible for evaluating feature flags but what needs does it but what does it need to consider when evaluating the most obvious thing would be the flag status but what if you only want your flag to be on for some users and how do you ensure a flag evaluates consistently per user so they don't get served different versions of your application if they leave and come back to address these concerns wavepost passes in a user id into a hashing algorithm to determine how to evaluate flags with rollout percentages waypost itself doesn't assign user ids that's your responsibility as the developer however waypost will work with any user id system as long as each id is unique per user or visitor of your application some examples are a visitor's ip address if you have a login system you can store one's username in a session or if you store a random string in a cookie when someone visits your website for the first time now that we have a user id system we can consistently serve the same features to users when they revisit your web application but what if we want to customize how a flag evaluates for specific users like for a beta tester you would want to make sure that they receive the new feature so that they can test it waypost accomplishes this with its custom assignments allowing you to customize how a flag evaluates for specific user ids here's an example of three custom assignments on the quote form flag with these set up the flag will always return true and show the new version of the quote form for users julia m and caleb r s while sean r will always be shown the old version of the quote form here's how you can view and edit a flag's custom assignments in the manager apps ui way post evaluates flags based on the following flag data attributes the flag status a boolean value that's either true or false custom assignments a list of user id and status pairs and a rollout percentage a number that determines what percentage of users get the new feature now i'll show you how the flags are evaluated with an example first off we have a feature flag in our react component if evaluate flag returns true then the new quote form will be rendered but if it returns false then the old one will the evaluate flag method comes from the sdk client object this object also stores the flag data and the user id and uses both data points to evaluate a flag in our example someone visiting solarflare's website is assigned a random string as their user id to determine which version of the form they'll be served first we must check the flag status since the flag status is on we go right now we check if the user id matches a custom assignment which overrides all other logic we don't have a custom assignment for this user so we go left now we see if the flag isn't being rolled out to everybody it has a rollout percentage of 50 therefore we go right now we have the user id and we get 55. 55 is greater than our rollout percentage of 50 so we go right evaluate flag returns false so the old quote form is shown to integrate your application with the weight post sdk you first need to generate an sdk key you then need to copy the key and insert it into your application this sdk key will be used to verify connections between the flag provider and the weight post sdk that's in your application now i'll show you how to integrate your react app with waypost's react sdk before adding any feature flags to individual components we first have to add some code to your top level app component first you'll want to import config and wait plus provider from the npm package next call the config constructor passing in your sdk key and the address of the flag provider service this will return a config object then inside of your main app component wrap everything in the return statement inside of the waypost provider component which was imported from the sdk you'll need to pass in the config object as a prop with this set up the rest of your react app can access the sdk client and its methods using react context now whenever you want to serve a feature flag in your code or whenever you want to serve a feature in your code using a feature flag you'll want to add the following code to the relevant component import waypost context from the npm package then instantiate the sdk client object using react's use context hook call its evaluate flag method to get the status of a flag passing in the name of the feature flag which was set up in the ui and a default value to return if the data isn't available for some reason you can then use this boolean to return one feature or another in your code now we'll get into running experiments with weight post first i'll show you what components and event tracking must be set up before experimenting then i'll demonstrate how to set up an experiment in the ui and last i'll detail how waypost helps you determine when to end your experiments how to run statistical analysis and view the results to run experiments with weight post an organization must already have their user event data stored in a postgresql database which we refer to as the events database and they must give read access to webpost the developer must send data from their application to this database each time a user is exposed to an experiment in addition they must also send data each time a user performs an action that the developer wants to measure for an experiment an example of this would be when a user signs up for a quote before starting an experiment the developer must connect the manager app to the events database then they must create the metrics they want to measure and finally they can create and start the experiment on one of their flags now i'll demonstrate how to set up your experiments in the ui the first thing you must do to perform experiments is connect the manager app to your events database this button will tell you whether you're connected or not and allows you to connect or disconnect depending on your current connection status now you'll input the credentials to connect to your events database in addition you have to provide a query string that posts will use to query your events database for data pertaining to the experiments this query must return a table with four columns named experiment id user id time stamp and treatment once you click submit and the manager app verifies the credentials and query your connection will be saved before you create an experiment you must set up some metrics that will be used to determine whether your experiment was successful to show you how to do this let's visit the metrics page you can open the new metric form like so there are four types of metrics to choose from which you can read more about in our docs just like the database connection mypost needs a query string to clear your database for the analysis we include specific instructions on what columns the query must return over here once you've set up the necessary metrics you can create an experiment on the flag from the flags dashboard click on the flag you want your experiment to run and then click create experiment the percent of users tested will determine what percentage of your users will be placed in the test group and receive this new feature you can also set a duration for the experiment but note that waypost will not automatically be stopping your experience lastly you can select the metrics that you want on the experiment then just click start new experiment and your experiment will be set up we now know how to set up an experiment with weight post but after you start one how do you know when to stop it the most common way is to wait for enough people to be exposed to an experiment since the more people in experiment the more likely you can trust your results that's why the manager app provides regular updates on the amount of users exposed to an experiment the manager app accomplishes this with this exposures pipeline this pipeline runs once every night to aggregate the amount of users bucketed into each cohort of the experiment and it stores this aggregated data into a table in the manager apps database this data then gets displayed on the front end as a line chart essentially depicting the sample size of each cohort over time the developer can use this chart to determine how much longer the experiment should run once the developer is ready to end the experiment and view the results they can click on the refresh results button on the manager apps ui this triggers our statistics pipeline which queries the events database for the metrics being tracked for this experiment it then analyzes this data using statistical tests using different tests depending on the type of data if all goes successfully it stores the results in the manager apps database which will then be displayed in the ui as a table with one row per metric attached to the experiment the most important column on the results is the p-value which will tell you if the difference in your metrics was caused by the new feature or if it was more likely caused by random chance this value lets you know if the new feature was successful in changing user behavior now i'll hand it off to caleb who will talk about some of the engineering decisions we made while designing weight post designing and building wave posts came with a number of engineering challenges the ma the major challenges we faced were communication between flag manager and flag provider communication between flag provider and sdk and how to efficiently run statistics first we'll discuss the communication between the manager app and the flag provider to unders to understand why we need communication between the two services it helps to understand why we need the flag provider in the first place in the earliest implementation of weipost the sdk clients connected directly to the flag manager however there are two main issues with this approach first waypost's api will need to handle two major functions handling requests from the sdk clients also and also handling api requests from the flag manager ui the sheer volume of requests creates a potential bottleneck that could have adverse effects on either the clients or the users interacting with the feature flag manager second services must now scale up together instead of separately because the number of external users is likely much greater than internal users it makes no sense to scale the two functionalities at the same rate due to these concerns we decided to implement an intermediary service whose primary purpose would be to provide feature flag data to the sdk clients essentially acting as a cache for flag data we named this service the flag provider the addition of the flag provider allows us to separate the functionality of providing clients with flag data from the functionality of managing feature flags also by creating a separate service developers can horizontally scale the flag provider if the volume of sdk clients is too large for just a single instance to handle this also allows for allows an organization to reduce latency to the sdk clients by creating new flag provider instances in availability zones closer to their users the drawbacks to this approach are that we now have to perform maintenance on an extra component this also adds to the architecture's complexity because now we have to move flag data twice instead of just once we decided that the drawbacks of added maintenance and complexity did not outweigh the benefits of being able to scale the application for more clients so now that we've established the need for the flag provider service we need a way for the flag provider to receive updated flag data from the flag manager so that it can forward the data onto connected clients there were three ways we considered doing this through polling a message broker or web hooks polling is a method of communication that uses http requests sent at a predefined interval here's how it would work if the request interval was 10 seconds the flag provider sends a get request to slash flags the flag manager immediately sends a response with all the flag data and the flag provider saves the flag data to memory the flag provider then waits for 10 seconds and then sends another get request though polling is a viable and simple way to consistently share updates to the flag data it comes with a few downsides many of the polling requests will be unnecessary traffic for example even if the flag data hasn't changed since the previous poll a request will still be sent not only is this extra work for the flag provider but also the flag manager which has to process each request also flag data won't update in real time it will update every 10 seconds you won't be able to quickly toggle a flag status in situations where it's beneficial to implement quick changes considering these trade-offs we decided to look for a better solution for communicating between services a message broker is a commonly used tool that allows services to communicate with one another without going into too much detail a message broker exchanges information through a system of publishers and subscribers within the context of waypost here's how a message broker would work in the event that the flag data is updated a message containing the flag data is sent to the message broker the message broker forwards the message to the flag provider who then saves the flag data to memory here are the trade-offs to this approach communication between the two services will be event driven and happen in real time the message broker gives some degree of fault tolerance if the flag provider goes down for some reason any messages sent from the flag provider will be available once it's up and running again it also eliminates the need to create api endpoints and instead uses the message broker despite the benefits there are some trade-offs with this approach first this would increase the complexity of our architecture we would now have another component we would need to maintain and secure and second message brokers can make debugging difficult as you know as you now have to rely on its logs in addition to the other services for these reasons we decided to investigate web hooks as a possible solution a web hook is an http request that gets sent in response to an event here's how it works within the context of waypost when an update is made to the flag data an http request whose body contains the flag data gets sent to the flag provider an endpoint on the flag provider receives the request and saves the flag data to memory the flag provider sends back a 200 okay response to the flag manager two of the main benefits of this system are simplicity all we need for web hooks to work is to add an endpoint to the flag provider and some middleware on the flag manager that sends a web hook when flags are edited also this architecture becomes event driven meaning that communication happens in response to events instead of request driven some downsides to web hooks in this scenario is that they are not necessarily fault tolerant if the flag manager application is unavailable for any reason we could potentially miss any important updates to the flag data which could disrupt the entire system also using web hooks means we lose some control over the data flow between services for example if a huge amount of edits are being made to the flag data on the flat on the manager application then the flag provider would need to handle a request for every single edit potentially overwhelming the service we ultimately decided that we were okay with these risks because we expect the amount of edits being made to flag data to be relatively small similarly we also had to decide on the best way for the flag provider to send updates to the sdk after the flight provider receives the flag data from the flag manager application the data needs to make one final move to applications running the waypost sdk the communication between the flag provider and sdk is different from the communication between the flag provider and flag manager in two important ways communication is server to client instead of server to server the amount of communication between the two components is much greater because now we're interacting with a production application which may have thousands of concurrent users this means that the method of communication we choose must be able to support lots of traffic and also be able to communicate with users browsers there were two methods of communication that we considered to ensure that the sdk client has up-to-date flag data websockets and server send events websocket is a communication protocol that allows bi-directional communication through a single tcp connection here's a simplified three-phase version of how the websocket protocol would work if we were to use it during the first phase an initial get request with some special headers are sent from the client to the server this allows the server to establish a connection using the websocket protocol the second phase is when the client and server communicate with each other messages can be sent back and forth using the websocket connection the connection is closed during the final phase when either the client and server call a closed connection method websocket is useful because only one connection needs to be made and communication between the two entities is real time the main downside of websockets for our use case is that we don't ever need to send messages from the client to the server in other words we don't need two-way communication a minor concern of using websocket is that it adds some development overhead the typically it typically requires more code than other methods and it bars us from using useful http functionality the other means of communication we considered was servers and events or sse opposed to websockets sse uses http to establish a persistent connection that can then be used for one-way communication between the server and client here's how it works within the context of waypost first the client sends a request to the server the server responds confirming that the connection has been made the server can now send messages to the client in response to events a challenge associated with sse is how to handle job connections connections can get dropped either when the client surpasses six open connections where after 30 seconds of inactivity we remedied these concerns by making it so the sdk reestablishes these lost connections sse works well for our use case and we ultimately chose it because it allows for real-time event-driven communication it's simple and opposed to web sockets communication is one-way from the fly provider to the sdk an additional challenge we faced was how we wanted to implement the statistics pipeline a crucial piece of our architecture was the statistics pipeline it consists of three steps first we query the organization's user event database for the metrics being tracked it then analyzes this data using statistical tests if all goes successfully it stores the results in the weigh post db we estimated that this pipeline could take a long time if a company had a lot of user event data so we had to decide how often to run this pipeline and whether it deserved its own server or not if we ran the pipeline frequently the developer could quickly access ex experiment results without having to wait however this would take up a lot of computing resources we realized that frequent updates uh weren't necessary given that it's not recommended for experiments to to look at results before an experiment is finished that meant there wasn't a need to consistently refresh results we decided to implement a button on the experiments page that would run the statistics on command instead this saved us a huge amount of computing resources we also timed how long it took with a large data set of about 10 000 users in the ex in the experiment with multiple metrics and there was hardly any delay therefore we decided to keep the statistics feature on the same server as the manager app so now that we're acquainted with waypost and the engineering decisions that were involved we'd like to briefly mention a few of the features we'd like to include in future versions of waypost as waypost currently exists applications running the sdk receive all the flag data regardless of whether the application pertains to that app in the future we'd like to separate flags so that applications only receive the flags that pertain to them also we'd like to include a login functionality so that users can add permissions to individual users or groups this functionality would also allow waypost users to track who makes edits to the flag data so thank you for listening to our presentation if you like to learn anything else about waypost you can follow these links to either our github page and our case study will be posted within about a week um so again thank you so much really appreciate it and we would like to just open up the floor to anybody that has questions about waypost so we have what we have one question in the chat um it's it's asking in your statistics pipeline what time of statistic what time of statistical analysis is being conducted i um what type yes so what type of statistical analysis being conducted i think um i think julia could probably julie or sean could probably speak a little bit better to this than i can yeah um sure i can take this one um hey lydia um so um our statistics pipeline does two tasks depending on the type of metrics so there's like continuous metrics which are things like um like total like amount of time spent on site um and so for that we used a t-test i believe and then for the other type of metric like binomial um also called discrete metrics um so that would be like kind of like a rate kind of metric like a sign up rate or conversion rate we use a chi square test for that all right another question here um says uh so a few questions are feature flags the only way of implementing uh the splitting required for a b test or are there other ways um excellent question um sean i don't know if you want yeah yeah i i got this um so feature flags are by and far like the best way to do this like technically you could also split um with like a canary deployment style so you would have like uh one version of your entire infrastructure on one server and like one infras and then another copy on another server and then you would route users to one server or another but with that um you know you'll have a lot of duplication you won't be using your resources well and then i think there's one other way like an api based way for a b testing where you like a user visits your website and then like some api requests get sent out to put them in the experiment and then like re-render the website um but those are only usually like done for like very small ui changes um so if you want anything big or like an entire new feature it's not really a good option um and then i i can i can answer his next one okay um see so on your second question you asked could the new could the new version users ever notice that they're being redirected to a different url or anything like that uh this purely depends on how you're implementing the feature flag um and it kind of also depends on how you're rendering these pages um so yeah it's just that's just like how it all depends because you know if you're using react you can kind of specify those urls a little bit differently um so it just yeah that just mostly depends um stephen asks does waypost add any additional load to the existing event database if so are there any considerations for users to keep in mind when configuring a waypost in their infrastructure uh we can go back around to julia if you want to answer this um yeah um so it i guess is asking whether there's any load added to the like that existing event database um so not really i mean we're querying it uh like we're querying one table which is the the one that's bucketing users into like in experiments of the exposures table that's getting queried once per day and we timed it so that it's like in the middle of the night like once every 24 hours and it only takes like a second so it's not really much load and then the other pipeline which is querying for the metrics that also only takes like a second um obviously if they have like billions of rows it could take a little longer but our product is geared towards small businesses which we're kind of assuming like don't have billions of users so um so with the uh amount of data that we tested with um it was very very quick so it was not really any like any like a significant load we have another question here could you talk more about how you kept the sse connection open between the flag server and the app running the sdk um so i think julia had a little bit more hand in uh the sdk and kind of how that sdk how the sse connection works but like um so julia you might need a chat yeah um so we use the um at least in javascript we use the event source api which um does the sse connection for you and they actually automatically will reconnect if they like detect that the connection is lost so that was all handled for us by the api that was baked into the javascript language so we didn't actually have to worry about that um i think we missed that uh wes's last question he asked us how how do we have time to do all this oh this is because we have some some super incredible coders here yeah i mean we went hard for sure but um we based um our project off some like existing projects um like pioneer which hit a feature flag manager so we were kind of able to see what the gist of a future flag manager looked like and then for our a b testing we were inspired by a company called growthbook um and like they they showed us how to do the architecture where like you use this uh this separate events database instead of having it in-house so just using those two and you know lots of time spent coding yeah yeah for sure oh and shout out to our mentor as well for helping answer our questions thank you max uh julio has a question um he asks when queering the event database to run statistics does waypost expect any particular schema for the data and the answer is yes uh it is it went pretty quick but yeah like we do expect it to be in a certain format like in the demo that we showed it was just like a simple select statement but that's just because our dummy data was already like formatted really nicely but like in reality that that statement could be pretty complex because they will have to get that into the correct format uh to to work with white post so yes thanks for coming to view our presentation um you know if you're an employer feel free to reach out um and thank you to launch school for you know kind of giving us this this platform and allowing us to you know make something great 