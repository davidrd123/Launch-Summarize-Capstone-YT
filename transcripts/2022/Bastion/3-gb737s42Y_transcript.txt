hello everyone thanks for coming to our presentation my name is adam and my teammates are alejan pavlo and riley and we'd like to tell you about bastion which is the project we've been working on for the past few months we'll start off by discussing what a back end as a service is and where bastion fits in relative to current back-end as a service offerings next we'll give you an overview of bastion including its components and features and then we'll talk about the design decisions that we made when designing and building bastion we'll give you an overview of bastion's architecture and talk about some of the interesting challenges that we encountered while building bastion next we'll do a demo we'll talk about future work we'd like to accomplish and we'll end with a question and answer session okay so let's dive in so first i'll give you a two sentence summary of bastion bastion is an open source customizable backend as a service solution that gets deployed with aws resources bastion is flexible and extensible integrating with aws lambda to provide cloud code functionality for custom use cases so basically bastion is a pre-built back-end that front-end developers can use for their application so that they don't have to spend time building their own back end letting them get their product to market faster so before we talk more about bastion's use case and features i want to back up and provide the context for our project a web application can be thought of in two parts the front end and the back end the front end is the client facing code that runs in browsers and mobile apps that's responsible for the user interface the backend stores the information needed by the front end in the database and keeps track of changes that result from user interactions on the front end the backend is also responsible for user authentication and for connections to external services so as an example let's consider fortress io a small company with a handful of engineers developing a new application their application is focused on customer facing features so they're going to be mainly focused on the front end code but they still need some kind of back end for their application specifically they need a relatively simple backend that keeps track of their users data and files and handles user authentication but they have a couple of other requirements too their application makes use of external apis so they need a way to integrate their back end with those apis and like many new companies they want to prototype quickly and get their product to market as fast as possible so what are fortress io's options for their back end in the past they might have developed their back end themselves by developing a back end from scratch and purchasing their own hardware to host it on this would give them complete control over every part of their back end but it's prohibitively expensive and time consuming for a new company with a small team of engineers instead fortress io can take advantage of a cloud hosting service there are several types of cloud hosting services that abstract away the back end to varying degrees an infrastructure as a service product like a digital ocean droplet would have the highest degree of control with the lowest degree of abstraction this type of provider would host the server infrastructure in the cloud so fortress io engineers wouldn't have to purchase configure and maintain back-end hardware but they would still need to configure and maintain the operating system and application code alternatively a platform as a service provider like heroku would handle all of the hardware and the operating system letting the engineers at fortress io focus on the back-end application code this is a good option but fortress io primarily needs common back-end functionality so coding a back-end application might be considered inefficient another option for fortress io is a back-end as a service product like google firebase that generates a pre-built backend so that the fortress io engineers don't even have to worry about the back-end code at all this provides the highest degree of abstraction and will let fortress io get their products to market the fastest but the trade-off is that fortress i o engineers are no longer in control of their back end not even the code this means that the engineers at fortress io can't customize their back end if they need to implement a new feature in the future one way that baz providers try to address their limited customizability is through a feature commonly known as cloud code although it goes by other names cloud code allows your application to automatically run functions on the server side in response to events triggered by http requests letting users take advantage of the benefits of a bas provider even if they need functionality that isn't natively supported by that baz provider one specific use case for cloud code is integrating with third-party apis which is something that fortress io needs to do for example fortress io might decide to use stripe for their payment system if they hard code the stripe secret api key in their front end code then anyone who inspects their front-end code will be able to access their api key if fortress io decides to use a baz provider without cloud code then they won't be able to securely integrate stripe into their application but if their baz provider does have cloud code then the fortress io engineers can define a custom function in the back end with access to the stripe secret api key and then they can call that function from the front end using an http request so using the stripe scenario i just described as an example here's how the cloud code functionality could work first the engineers at fortress io define a custom function called charge customer that uses stripe to request payment from a customer in this function they import the stripe client library and make the api key available either by hard coding it or as an environment variable this function and its dependencies then get injected into the back end provided by the baz since the code gets injected into the back end the api key is secure it no longer lives in the front end where it could be compromised now when fortress io processes a customer payment on the front end using stripe they have the front end code make an http request to the back end this request will invoke the charge customer cloud code function that was previously injected into the back end once the charge customer function is invoked on the back end it will make an api call to stripe then the backend forward stripes response to the front end that originally made the cloud code request this is just one example of how cloud code is a useful feature for a backend as a service provider so the engineers at fortress i o have decided to use a baz provider with cloud code but they still need to decide whether to use a managed or a self-hosted baz service with a managed baz product like google firebase or aws amplify the back-end code and infrastructure is hosted and maintained by the baz provider and so the code and infrastructure isn't accessible to the team at fortress io on the other hand with an open source self-hosted baz product like app right or parse consumers download the entire code base and deploy the back end themselves for these providers the fortress i o engineers would be responsible for deploying and maintaining the back end so what kind of bass provider should fortress lio choose a managed or a self-hosted one let's look at the pros and cons of each a managed bass is easier to deploy than a self-hosted bass so they will get their product to market more quickly with a managed bass a self-hosted baz though will give them more control so they'll be able to modify the back-end code or infrastructure if they need to which isn't possible with the managed baz a managed baz requires essentially no configuration and provides support for their product while a self-hosted baz requires configuration and offers no support finally a self-hosted baz will give them ownership over their back-end which lets them avoid vendor lock-in which is one of the most common complaints about managed baz products vendor lock-in occurs with managed baz providers because you have to design and implement your application around the interfaces that they provide locking you into their services this makes it difficult if you ever need to modify your application or migrate your application away from the manage baz service for example if the baz provider ceases to exist then you'll have to create a back end from scratch or figure out how to migrate your application to a new baz provider this has happened several times in recent years including when facebook dropped support for parse in 2017 and when microsoft retired their mobile backend as a service in 2020. so if fortress io wants to keep control of their back end avoid vendor lock-in and still get their product to market quickly what should they do this is where bastion comes in bastion is an open source backend as a service that gets deployed to the cloud using aws we design bastion for small companies like fortress io that want to get their product to market quickly while still keeping control of their code and infrastructure bastion also supports cloud code letting users define custom functions that get executed using aws lambdas allowing users to more easily integrate with third-party apis we also made sure to make bastions secure and scalable out of the box so to get bastion up and running first need to install the aws cli on your local machine and connect it with your aws account then install the bastion cli and enter the command bastion deploy to deploy the admin app to your aws account so now you'll have access to the admin dashboard which will let you create a backend for your project for example you can create a backend for your restaurant app as seen here this backend also gets deployed to your aws account and will handle the back-end functionality that you need for your restaurant app with bastion you can deploy multiple back-ends from multiple projects if you wanted to deploy a separate back-end for your shopping app you can do that and then have two separate and independent back-ends operating in your aws account to interact with these back-ends in your front-end code you can download the bastion client sdk and use the methods that it provides for database operations user authentication file storage and cloud code functions now i'll pass it off to pavlo who will give a more detailed overview of bastion thank you adam we're going to start with this diagram which we will revisit a few times as we go over to different parts of bastion in the following slides we're going to walk through the process of how they are created and discuss each one in more detail starting with the cli deploying your infrastructure starts with the bastion cli this is a downloadable npm package which provides several helpful commands once it is installed the bastion help command will list all available commands as well as other helpful information which you should see in just a moment to deploy bastion to your aws account you first need to download and log into the aws cli which will verify the aws account to which bastion will be deployed once logged in you can enter bash and deploy and file the prompts to get started you will need to provide a domain where bastion will be hosted as well as some additional information you'll be prompted to choose a username and a password will be generated that can be used along with that username to log into the admin application once you have followed all of the prompts a cloud formation script will run which will automatically provision the infrastructure in aws needed to run the administrative part of bastion or the admin application you can use the bastion show command to see a list of your deployed infrastructure and the username and password for each instance if you forget to write that down you can find that information here and when you are finished with a particular bastion account entering bastion destroy allows you to tear it down the next part that we will cover is the admin application which is made up of the admin dashboard and the admin app server and is used to manage and deploy bastion back-ends like the shopping app back-end and the restaurant app back-end shown here here we see a more detailed overview of the infrastructure of bastion we'll cover the architecture in more detail later but this diagram illustrates how bastion is deployed to aws the admin application is the part that's in focus now when bastion is first deployed a cloud formation script creates a new virtual private cloud which contains the admin app and any individual bastion back-ends that are created from there all traffic coming from outside the dvc is first routed to an application load balancer which then routes it to its next destination requests from the admin app dashboard running in a browser are routed to the admin app server which is a node.js application build with express and a mongodb instance for data storage both the express application and mongodb run in docker containers managed by aws elastic container service with fargate here we can see the admin dashboard and once you log in you are presented with information about each of your bastion backends such as when they were created their names and api keys the keys are essential for the bastion sdk which is used by front-end applications to communicate with the bastion backhands we will cover the sdk in more detail later from this screen we can create new back-ends delete existing back-ends or see information specific to each one creating a bastion back-end will run another cloud formation script which will once again provision infrastructure on aws to create a back-end for your front-end application clicking on a bastion back-end in the sidebar of the dashboard will show you details about that instance the links on the sidebar will change to allow you to navigate between collections users cloud code and files and when you are done you can log out of the dashboard the collections tab shows all the collections that exist in that bastion backhand this is where collections are created and destroyed manipulating the data within those collections can be done using the sdk the users tab allows user management to help you decide who has access to your front-end application here you can see a list of all existing users delete users and create new ones the cloud code tab allows you to see all the cloud code functions that you have created it allows you to create new ones and delete any that you no longer have a need for creating a cloud code function requires uploading a zip file containing the code you wish to run as well as any dependencies that it requires doing this will create will cause the admin app to create a new aws lambda function which can be invoked quickly and easily using the methods provided in the sdk these functions can provide additional functionality that your backend requires such as communicating with third-party apis or filtering or transforming your application data there is also a files tab which allows you to view uploaded files associated with each bastion back the admin application consists of a front-end interface the dashboard we just looked at and a back-end which handles basic create read update and delete actions from the dashboard and stores data about existing bastion backends the purpose of the admin app is to create and manage those backends application 1 and application 2 in this diagram represent two separate bastion backends created by the admin user creating a new backend from the dashboard creates a new cluster on aws ecs which pulls docker images from aws elastic container registry to create the necessary tasks to run a bastion backend any actions on the admin dashboard concerning collections users files or cloud code functions are forwarded to the appropriate cluster all the necessary infrastructure is created using a cloud formation script next we will dive a little deeper into the structure and function of the bastion back-ends created by the admin application and here we have a slightly more complete look at the bastion infrastructure the parts in orange represent bastion app servers and database servers running on ecs fargate each backend running on their own ecs cluster each cluster runs two services one of which is an express server providing the back-end api for our clients front-end projects and the other is a mongodb server for data storage the server and mongodb instances run as separate services allowing the app server to scale independently of the db server aws cloud map provides service discovery between server instances and db instances data in the database server is persisted using docker volumes and the aws elastic file system file storage is provided using s3 and cloud code functions are deployed as aws lambdas so the bastion back back-end provides basic bas functionality it handles requests both from the admin application and the front-end applications built with the bastion sdk providing services such as authentication execution of cloud code functions file storage and database operations one of the most basic actions of the bastion backhand handles is creating collections and storing and manipulating collection data if we create a collection named examples from the admin app a request is sent to the bastion back-end the collection is created and stored in that instances database server and api endpoints are dynamically created on the app server providing basic crud functionality file storage is initiated using the bastion sdk files are uploaded to the app server which uploads the file to its designated s3 bucket the bucket returns an object which includes the file's url which is stored in the database server this way when a read request comes in for a particular file the server only has to return the url instead of returning the file in its entirety the final part of bastion is a client sdk which is what connects front-end applications to their respective bastion back-ends using the client sdk a developer has access to methods which provide crowd actions on collections in the database login sign up and log out functionality methods that run custom cloud code and grant access to file storage now this snapshot here from the admin dashboard shows one of the main pieces of information needed for the sdk to connect to a bastion backend which is the api key each backhand has its own unique api key using the sdk requires downloading and importing it into the file where it'll be used the initialize method returns an object that grants all the methods necessary to interact with the bastion back end this method requires the domain name that is chosen when first deploying bastion and the unique api key and here we see a list of some of the methods the sdk provides that allows developers to interact with the bastion backhand for example to get all the items in collection you can use the db.getall items method passing it the name of the desired collection with that basic overview bastion i will now pass it to elijah who will cover some of the design decisions that we made when building bastion and its architecture thank you paolo ambassadors cloud native is designed to be flexible resilient and manageable considering these it was an easy choice to use docker containers to build our backend servers and the admin application to understand what containers provide we can compare them to one of the alternatives the key difference between virtual machines and containers is the need for the hypervisor layer and guest operating systems docker containers do not need their operating system and the hypervisor layer they share the host operating system's kernel through the darker daemon this this makes sakurai's applications lighter and faster overall more resource efficient the crisis applications are not perfect they require the deployment management and scaling they can fail and require provisioning so we need a system that can take care of these this is one docker the container orchestration comes into play in aws environment we could have used two services amazon's elastic container service ecs or amazon's managed kubernetes service eks kubernetes is an open source solution to container orchestration it is very popular because it allows building highly scalable applications kubernetes is also platform agnostic this is a difference maker in a scenario where you are considering multi-cloud deployment deployment or flexibility of changing your cloud provider however kubernetes require a good understanding of its underlying principles and lack of experience could cause higher cost and performance inefficiencies ecs however is an aws managed container orchestration service it has better integration with aws and is simpler to use another important factor for consideration here is our target users fortress io is a relatively small team with minimal to no infrastructure experience in a scenario where fortress io team wanted to make changes in their bastion infrastructure working with ecs will be easier now we've chosen to use acs let's look into ucs modes for launching applications with ec2 mode your own servers which you manage and maintain since you own the infrastructure you pay for the infrastructure for the period you run the instances with fargate mode aws allocates you the resources compute resources as you need them you don't control the infrastructure piece and the spring certain advantages firstly fargate has a pay-as-you-go pricing you pay for the resources you consume and another advantage of fargate is that you don't have to choose an instance type at the start aws recommends ec2 for institute mode for large workloads optimized for price and it recommends far gate mode for large workloads optimized for low admin overhead and for any mid to small workload for bastion we needed a way to easily deploy or tear down back ends and fargate was a better choice for this let's look into different ecs configurations we've used in bastion to solve different problems on the left you can see our admin application and on the right there is the bastion backend configuration which is deployed for each backend you create for the admin app the expected traffic is relatively low a single administrator or a small development team will use this application when they want to add new backends or new features to one of their existing backends because we aren't expecting high traffic on the admin application there was no need to configure auto scaling due to the same reason the database and the application containers can run in the same task for the bastion backend however it is expected to receive high traffic since hundreds or thousands of clients could send requests to the backend infrastructure assuming this the application server will be the first performance bottleneck we first separated the application server and the database server into separate ecs services next we enabled auto scaling for the service that the application server is located in this will scale the application servers horizontally by adding more instances when is needed we haven't done this for our database server since databases can handle higher traffic in our case we use mongodb and mongodb can handle more than 50 000 concurrent requests for bastion we decided to use a document database over a relational database because we didn't want to force our users to define a schema and the relationships between models before they use them this way users can create a collection and start manipulating data straight away we also chose over aws managed dynamodb due to the ease of local development this brings us to our current configuration where we run database servers as docker containers inside ecs tasks that you can see in the slide there is one problem with running containerized applications in the cloud your ecs target tasks can crash or need to be reprovisioned in this case aws does not guarantee that your containers will be deployed on the same host this would cause data loss to solve the data persistent problem we use docker volumes and aws elastic file system efs mount points will be attached to the docker volumes we defined this way even if you stop start or reprovision your instances your data will be there another common feature of past solutions is a dedicated file storage if fordress io decide to implement a social media for example they need a storage solution where they say media files like profile images or videos for file storage we could have used mongodb with grid file system which divides large files into multiple parts however we opted for s3 duty simplicity when the client application sends a file to an app server first this will be uploaded to a public read aloud history bucket that is dedicated to a single bastion by account the s3 url of the uploaded object will be saved to the database in files collection when the client application sends a read request for the same file later on our application server will retrieve this file information from the database and return this s3 url instead of streaming the entire file back then the underclient application is responsible for using the s3 url according to the application logic this could be displaying the image or creating a download link this way we don't send these large files back and forth and we reduce the load on our application servers let's look into how we split responsibility between different parts of bastion we already know that cli deploys these bay the base infrastructure and runs the admin application naturally the admin application handles creating managing bastion backends it's important to understand the shared responsibility between the client client applications hence the client sdks and the admin application the admin application is responsible for the functionality that we would like to hide from client applications for collections this means client applications can create read update delete data from an existing collection but creating deleting collections are constrained to the admin for cloud code functions we want the client applications to be able to trigger the execution of these cloud code functions for example running the charge customer function but the management of these functions are handled by the ethernet cloud code is one of the key features of bastion any custom functionality of your app application will be defined as a cloud code function we discussed some of the details earlier when designing bastion we considered two ways of implementing cloud code functions we could either deploy to tear down small containerized applications each time a cloud code function is created or removed however this would create a lot of configuration overhead in addition to being being more expensive and resource inefficient instead we decided to use lambdas provisioning lambdas is easier they are cheaper as you pay for per execution with a significant amount of free allowance lambdas are a better fit for running specific well-contained tasks which cloud code functions are by definition before we move on and talk about bastion architecture there is one one last thing we want to mention briefly we talked about the relationship between bastion cla and the admin application previously when you deploy your bastion vpc using the cla application your configuration information along with your admin username and password will be passed down to the admin applications environment variables this way the admin app can be aware of the configuration and login settings and use them when creating and managing bastion backends now we will talk about some of the decisions we made at a higher level than talk about bastion architecture after a user creates their bastion vpc let's assume they logged into their admin dashboard and provisioned two bastion backends with a bunch of cloud code functions on each bastion backend this is what their bastion vpc would look like as a whole now we will zoom into some of these parts and talk about some of the components first let's focus on the initial state of your bastion vpc as it's provisioned by the cla application without any passion backups while designing bastion vpc security was one of our main considerations bastian uses four subnets each serves to a specific purpose one private subnet called database tier contains bastion backend database servers one private subnet called application tier contains bastion backend servers admin application and cloud code functions basically all the main complete components lastly we have two public subnets containing internet-facing networking components this way by default there will be no public access available to your key components and this will be handled by the networking components explicitly another key consideration behind bastion's design is future growth bastion is designed for small teams scalability considered up to a certain degree we expect our users to employ their own backend and infrastructure engineering teams in case they start growing really fast and we design bastion vpc in a way that it can be taken over by these teams without the need for redeploying an infrastructure from scratch we use a single az to deploy our infrastructure considering cost in mind you've done the ip design in a way that in total bastion uses 25 of the available ips in your vtc this way if you decide to add more functionality in the future by taking over the bastion vpc or if you choose to achieve higher availability by deploying your servers into multiple availability zones you will have the room available we deploy your bastion vpc into the hosted zone that you provide for this you need a domain that you own and an aws hosted so if your domain is registered by other registrars this is completely okay you can use aws route 53 dns hosting to get your hosted zone or if you are registering a new domain you can just use r53 both for registration and for dns hosting we imagine that we deploy your admin application to the app tier private subnet now let's look into how we allow traffic to your admin application initially we create an application load balancer configured so that by default it forwards the traffic to your admin application by simply accessing to your domain you can log into your admin dashboard with your username and password and start using bastion at this stage this is a very straightforward configuration but what happens when you add a bastion back-end when you log into your admin app with your username and password and click create stack first cloud formation will initiate a stack creation the cloud formation script uses the image from a public ucr repository that we created this will deploy your bastion back and into the same app to your subnet and you can repeat this step as many times as you want one advantage of using cloud formation is to is the control over the various resources you provision as part of your stack our app servers are now configured but we have a problem how are we going to allow traffic to these servers from client applications that we're going to build in addition to deploying your instances cloud formation also configures our application load balancer rules we use path based routing to direct incoming traffic to the relevant batch in back-end server request url will be checked and using the matching listener rule routing will be handled we talked about incoming traffic but what about the outgoing traffic earlier in our presentation we discussed cloud code functions that you can deploy these should be able to connect to payment apis messaging apis or other services that exist in on the public internet additionally your ecs tasks would require access to public uci repositories where we hold our docker images so that the containers can be provisioned we use an app gateway to achieve this first all the outgoing traffic from your private subnets will be routed to the web to your subnet here and that gateway takes care of the rest let's see how that gateway is a smart networking service that uses a process called ip masquerading it takes outgoing iv packets that are sent by components with private ips and replaces these with its own public ip then it forwards down to the targets when a response is received it forwards these back by replacing the receiver ip with the original sender ip we have a few other interesting architectural and code level challenges we tackled while building bastion now riley will talk about these and give you a demo of what fortress iocan built using bastion uh great thank you alijan uh throughout the process of creating bastion we experience many challenges but some of the most prominent we're handling user authentication figuring out how to get database servers and application servers to communicate with each other and also in our implementation of our cloud code functions for our bash and back-end servers we wanted to make sure that each user's data is secure and only accessible to those that have been authenticated for this we decided to use session cookies to uniquely identify users so when a user initially logs in they are given a cookie from the server that is stored in the browser at the same time the server creates a session token in our database that can be later be used to check if a user session is valid now when a request is sent from a user to a server the cookie sent in the request is authenticated against the token in the session store if there is a match the session is considered valid and the server returns the requested resource to the client in order for cookies to be sent to the client we need to make sure that they are secure for these to be secure they must be sent over https this is necessary so that malicious actors cannot access them to perform actions on a client's behalf because we had to use https that meant we had to be able to create and issue ssl certificates for our users if our load balancer forwarded requests using https each backend server in our application tier would also require an ssl certificate using https at this layer is also unnecessary as all of the traffic is between our private services so all of the extra encryption is a waste of resources so what we can do instead is to create and issue just one ssl certificate for our load balancer from here the load balancer can forward all requests over http instead of https using a process called ssl offloading now we won't have to worry about issuing more certificates and we have the benefit of relieving our server from the burden of encrypting and decrypting secure traffic each time it receives a request saving valuable resources for our server one significant challenge with using https to secure our cookies is in how our load balancer talks with our application server internally on our private network we convert all of the https requests to http in ssl offloading that i mentioned before the issue with this is that requests with cookies would be sent to our load balancer over https and then would be routed to our app server over http this process would cause cookies to be refused even though they were still technically secure to solve this problem we were able to configure our server to use something called a trust proxy this basically tells the server that it can trust the request that is one network jump away which is where our load balancer is located since we know that the load balancer receives requests over https we know that it hasn't been tampered with and that the server can trust it this will in turn allow the cookie to pass through and to be accessible to our application server another challenge we faced was determining the best way for application servers and database servers to communicate with each other each application server stores the data in a separate database so that we can separate concerns this means that each app server has to know which database to talk to there are several ways to achieve this but we mostly consider the following options option one is to use an internal load balancer which would serve as a centralized location for managing all connections between each service app servers will be able to route traffic through this load balancer which then decides on the database server to route the request to the other option is to use service discovery using aws cloud map which allows for direct communication between application and database containers cloudmap allows you to register container tasks with a custom name which gets resolved to the internal ip address of the container when a new backend bashing backend is created the user gives it a name which is then used to create a new private dns namespace for the server we can then use that name and other services to refer to it we ended up choosing this option since we wanted to avoid the extra infrastructure and complexity of the internal load balancer option it would lead to higher costs and increased maintenance so we decided to go with cloud map figuring out how to properly implement our cloud code functionality was also a pretty big challenge we had to figure out how we would go about creating our functions along with all of their dependencies we also didn't want just anyone to be able to create these since they can have far reaching effects so we limited the creation of cloud code functions to our admin application we also had to figure out how our customers would be executing these bits of functionality and how we would get them to be able to interact with resources within their aws infrastructure as well as being able to interact with resources available through the public internet like external apis for creation of our cloud code functions since we decided to go the route of zip files we didn't want to go the route of inserting inline code which cloud formation allows though it is a more direct way to create lambdas it makes it hard to add dependencies and inserting code as a string can get messy very quickly the other option was to upload a zip file with all its dependencies to an s3 bucket first from here lambda can pull all the necessary files that it needs this is a much cleaner process but it did involve adding another piece of infrastructure to our project by adding the private s3 bucket for the invocation of our cloud code functions we ran into the challenge of making sure our functions can interact with other private aws resources as well as resources available through the public internet the public access method which you can see on the right is straightforward no configuration is needed and it uses default internet access unfortunately while it is able to reach out to external resources like third-party apis it isn't able to interact with your own aws resources to allow our cloud code functions to interact with existing resources would take some configuration we would have to make sure we configured our functions with the correct security credentials to work within our vpc and we would also have to give them the correct subnet information so that access to the components within our infrastructure this is the option you see on the left with this configured correctly we were able to make sure that our cloud code functions could add as much functionality as possible while staying secure so now i will demonstrate an example application that has been created to integrate with bastion it utilizes our sdk to communicate with created bash and back-ends so all the functionality you will see interacts with the bastion backend servers created from the admin dashboard once again you initialize it in your front end code like so by downloading and importing the npm package and using your server information as the input so that you can access all the relevant resources for your application as you can see here this front end application created by a client can use our sdk modules to easily integrate the functionality that they need here i am able to create new users as well as log existing users in and out dealing with database collections is straightforward as well as i'm able to perform all necessary credit actions on items in my database here i'm creating a new record to add to our database collection and displaying all available entries users also have the ability to easily upload files which creates an entry in the database that has the relevant url url for retrieving that file to handle in any manner that a friend or developer chooses so this could be creating a download link or simply displaying an image if they want to get this file by its id and display it it's as simple as displaying the public s3 url retrieved from the database that you saw previously before i show you how cloud code functions are used take a look at how at how fortress io is implementing them in their front end you'll see on line 6 they're using bastion.ccf.run to use our sdk to interact with the bastion backend they pass in the name of their function and any parameters they might need on lines 14 through 16 you'll see that they can run their cloud code functions that have been previously defined in the admin dashboard to interact with stripes api here you will see that although our application doesn't natively support ticking payments from users it is possible to add that functionality yourself to our back end from here you can then use our sdk in the code you saw previously to execute that functionality in the front end that you're looking at now the cloud code functions demonstrated here are hitting a real stripe api endpoint to make charges to customers they also allow you to hit the stripe api to display your real stripe account balance and to hit the stripe api again to list your current customers you can see all three of those functions here the important thing to note is that the stripe api key lives in our cloud code functions within our backend so it never gets exposed to those trying to get access to your stripe account through your stripe api key obviously this is a time box project and work never truly feels finished so here are a few things that we have thought about for further development of bastion one thing we'd like to add is the ability to whitelist front end domains it's one way we'd like to improve the security of client applications interacting with bastion we'd like to provide the ability to waitlist domains that are allowed to communicate with the bastion backend that men can make a list of domains that are allowed to access each server drastically reducing the danger of api key exposure currently our sdk only supports javascript for front-end web developers we'd like to add support for other languages if possible like java and swift and others for mobile developers um we'd also like to add the ability to use redis for session storage we currently use mongodb and while it fits our use case pretty well currently redis is able to handle session storage a little more efficiently at scale and another way we'd like to improve bastion is to deploy it in another availability zone an availability zone going down and aws isn't unheard of so if we were deployed in multiple bastion could be more available to our customers and more resilient against outages um and yeah this is the end of our presentation thank you for coming and we hope you enjoyed it now we'll take some time to answer questions from the audience so you can put those in chat or in the q a all right so we have a question the question is i'm wondering how you ended up going in this exciting direction how did you arrive at this idea so i guess we we were pretty interested in back end as a service i think pretty early and we were looking at different ways that they were implemented and different features we could implement and how to differentiate ourselves and we kind of stumbled on this version of it where it's cloud hosted and we made sure to use cloud code as a key feature because that seemed to be something that people really wanted and a lot of their backend as a service providers so i think it kind of evolved just from the very beginning from our just general interest in back end as a service i could also add to that in that i i think i like the topic of backend as a service because it touches so many other topics and you get to touch data working with data user authentication working with a little bit of front end a little bit of back end and getting everything to communicate in the right way so i think solving like a multitude of problems across the board is something that interested me at least okay so the question is for the fortress i o application is that an app that just developed the developers at fortress io would use internally could you be a bit more clear on how bastion would provide back-end services for the front-end if that makes sense uh yeah i can answer that um so i guess that was more of um a prototype just to kind of show off how any kind of functionality could be used um in theory it would be something that a front-end developer builds and they could have their users use that application so then that user could sign and interact with data in any way that they saw fit if that answers your question hopefully but we have another question what's the benefit of running an open source spas on your own infrastructure yeah so having it be open source lets you have control over the code and infrastructure and that might not matter in the beginning when you're just using sort of simple functionality but if you're if your application grows and you want to scale or you want to make any kind of modification if you're in control of the code and the architecture then you can actually just jump in and make the changes you need to like for example if you wanted to modify say you wanted to modify your bastion back-end server you could just access the code from our repository and then just make whatever changes you want create a container and then just switch out that container for the one that's running in ecs which is something that we did many many times during development so it's not a very difficult process and it lets you have fashion be a functional part of your infrastructure for longer essentially instead of like a managed bad service where if you need to change something or if there's some functionality that you don't have you're kind of out of luck because the entire code is completely obfuscated uh could you talk more about how you use cloud map to connect containers in private subnets so cloud map essentially is like an internal private dns so when we create a bastion backend we give it we create a new namespace which is just a like a place for it to live and a name you can use to access it and then when you use that namespace in another container like if you're you need an url you can just use that like um like the url you can just say like name dot or db.name and then that'll resolve to the address of another service that you registered with so it's a lot like dns for the public internet but it essentially lives in aws oh we have another question uh would have as like bastion be suitable for running a micro service architecture like have multiple bastion instances communicating with each other to form a system i can answer that um i guess um the use case of bastion is not to have a microservices architecture um the other part is because by definition back-end instances are not modifiable um like our current configuration doesn't allow that but if some if if someone takes over our architecture and in and and modifies our docker images this is this is completely possible but the the use case of backhand as a service is not something like microservices architecture the the users of users are small teams with mostly uh front-end developers that that they don't want to build back-ends they just want to focus on the front-end part so they just need a server basically uh thanks thanks for watching our presentation hope you enjoyed it yeah thanks everyone yeah thank you all for coming thank you 