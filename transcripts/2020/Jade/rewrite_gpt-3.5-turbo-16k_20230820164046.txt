Thank you for joining our presentation on Jade Framework, an open-source deployment environment for Jamstack applications. Today, we will cover the basics of the Jamstack architecture, the infrastructure required for a Jamstack web app, and the core functionality of our framework. Additionally, we will discuss the evolution of Jade and highlight the valuable experiences and lessons we have learned throughout its development.

Before diving into the details of the Jamstack architecture, let's briefly examine two common web app architectures. On the right side of the screen, you can see the architecture for static websites. This architecture is simple and efficient at serving static content to clients upon request. However, it lacks the flexibility for dynamic functionality, requiring an expansion of the architecture to incorporate such features. On the left side, we have the architecture for standard web applications, which can handle dynamic content due to advances in browser capabilities and the introduction of SQL databases. Despite these improvements, challenges related to security, scalability, and performance persist in both architectures.

Regardless of the architecture used, web pages are built in a similar manner. Initially, the client makes a request to the web server for the HTML file or any static file. Once the client receives the HTML file, it discovers references to other assets such as CSS, images, or JS files. Consequently, the client makes additional requests for these supporting static assets. After obtaining all the necessary assets, the client assembles and renders the page. To illustrate this process, imagine visiting a friend's blog. Upon requesting their blog site, the web server returns an HTML file. The client's browser examines this HTML file and identifies references to styling and images. Subsequently, the client makes subsequent requests for these assets, which are then displayed as part of the blog site. However, when it comes to dynamic content, an app server becomes vital. For example, if you wanted to view comments on the blog, your request would be sent to the app server. The app server retrieves the raw data from the database, applies business logic, and filters the comments based on criteria such as date or author. Finally, the app server returns the filtered comments to the client's browser, allowing them to view the desired dynamic content.

Now, let's explore an alternative approach to building web pages called the Jamstack architecture. This architecture aims to pre-build the pages ahead of time, eliminating the need for clients to make multiple requests for static assets. Instead, the pre-built pages are served directly to the client upon request, reducing round-trip requests, improving page load speed, and minimizing client-side rendering. The primary tool used to achieve this efficiency is a static site generator such as Hugo, Jekyll, or Gatsby. These generators compile, minify, transform, and bundle source code and data from a content management system to produce the build files. During the compilation process, the data is applied to templates, resulting in static HTML files.

By leveraging static site generators and pre-building the pages, the architecture of a web app can be optimized. Instead of having the web server solely responsible for serving static assets, a CDN can also fulfill this function. This substitution reduces costs and improves response times, as CDNs are geographically distributed and closer to the clients than web servers. Moreover, the backend functionality provided by an app server and database can be abstracted into APIs and serverless functions. This restructured architecture, known as a serverless model, has gained popularity and is actively utilized by numerous websites today.

This leads us to the concept of the Jamstack architecture. JAM in Jamstack stands for JavaScript, APIs, and Markup. Within this architecture, the browser takes on the role of orchestrating dynamic functionality. The browser, empowered by advancements in technology, can now handle the backend logic and invoke APIs and serverless functions. In the words of Matt Billman, CEO of Netflix, the modern browser is no longer limited to displaying downloaded content from the web. Instead, it is capable of running full-fledged web applications. This paradigm shift allows for greater flexibility and responsiveness, making the browser the orchestrator of dynamic functionality.

Now that we have a comprehensive understanding of Jamstack concepts, let's delve deeper into its attributes. With Jamstack, the entire website is served from a CDN, ensuring that all client requests are handled by the CDN. This standardized approach offers several advantages. Firstly, it significantly reduces latency, as CDNs boast multiple edge locations that are closer to the clients. Secondly, CDNs are easily scalable, allowing for seamless addition and removal of CDN resources. Additionally, CDNs provide enhanced security, as they minimize the attack surface area and are less prone to malicious activities, such as DDoS attacks or hacking attempts. Lastly, CDNs typically require less maintenance, as the responsibility for maintenance and security lies with the third-party CDN provider.

The dynamic functionality in the Jamstack architecture is abstracted into reusable APIs and serverless functions. APIs handle data management, allowing the client to coordinate and manage data sourcing. Furthermore, serverless functions are employed to address situations where certain tasks need to be performed securely, rather than on the client-side. Examples of serverless functions include authentication, form handling, and event processing.

Given the flexibility and advantages of the Jamstack architecture, a wide variety of websites can be created. On the screen, we can see three examples of real Jamstack websites. The first is a static Nike ad campaign, followed by an FBA catalog that allows users to search for products and retrieve relevant data, likely leveraging a database API. Lastly, we have a website called Rye and Beyond Cottages, where users can search for, view, and pay for rentals in England. This website likely employs a payment API, authorization, authentication, and database integration to offer these features. These examples highlight the dynamic functionality and broad possibilities available when using the Jamstack architecture.

Now that we have discussed the basics of the Jamstack architecture, let's focus on the implementation process. Initially, for simple Jamstack websites that do not require frequent updates, a three-step workflow is sufficient: code development, pre-building of files, and distribution to a CDN. However, for websites that require frequent updates, automation becomes necessary to streamline the development process. The Jamstack community has identified several best practices for automating the Jamstack workflow, including version control, automated builds, atomic deploys, and instant CDN invalidation.

To provide a general overview of the Jamstack workflow, let's consider the steps involved in manually provisioning the required services. This breakdown highlights the complexity of the process. Firstly, you need storage to host the site, a CDN for content distribution, serverless functions to handle dynamic functionality, and a server to listen for webhooks from Git repositories. Additionally, a build server is required to compile source files, transform data, and send the built files to a hosting environment. All of these services necessitate proper role and permission management, both for inter-service interactions and user access control. This stepwise process emphasizes the intricate nature of manually setting up a Jamstack application.

To achieve automation, the workflow can be simplified through the use of version control systems like GitHub, Bitbucket, or CodeCommit. These systems not only facilitate collaboration between developers but also employ webhooks to trigger events such as code commits or merges with the master branch. For example, when making updates to a blog site, a developer can push the code changes to the source code repository, triggering a webhook that notifies the build server of the updates. The build server then pulls the updated code from the repository and initiates the pre-building process. Automated builds ensure efficiency and accuracy.

Once the build is complete, the built files are uploaded to storage. It is crucial to perform atomic deploys, ensuring that the entire site is either fully built and deployed or not deployed at all. Partially built files can cause inconsistency and downtime, which can be detrimental to user experience. If an error occurs during upload, it is essential to roll back the build and attempt the upload again at a later time.

With the built files successfully uploaded, the CDN can deploy and serve the pre-built pages to end users. To maintain the integrity of the site, instant CDN invalidation is necessary. This process ensures that old content is invalidated whenever a new page is built. This can be accomplished through a service function or a build server that communicates with the CDN, guaranteeing that the latest content is always delivered to clients.

In conclusion, the Jamstack architecture offers a powerful alternative to traditional web app architectures. By pre-building pages, utilizing static site generators, and leveraging CDNs and serverless functions, the Jamstack architecture provides improved performance, scalability, and security. Although not suitable for all websites, Jamstack is ideal for sites that can source data pre-build time. Moreover, with automation and the integration of best practices such as version control, automated builds, atomic deploys, and instant CDN invalidation, the Jamstack workflow can be efficiently managed. Thank you once again for joining our presentation on Jade Framework and the Jamstack architecture. The Jamstack architecture has its drawbacks, particularly when it comes to error handling. If there's an error, the build needs to be rolled back and re-uploaded later. This can lead to inconsistent states and potential downtime if users are streaming or browsing the website. Once the build is uploaded to storage, a CDN can deploy the pre-built files and serve them directly to end users. It's important to note that the entire site should live on the CDN. Additionally, instant CDN invalidation is crucial to ensure that users are always seeing the latest content. This is usually done with a service function or build server. However, for this project, we will assume that a service function is responsible for invalidating the CDN cache so that the server always receives the most up-to-date content with each new page build. It's worth mentioning that the Jamstack is not a perfect solution for all websites. It is most useful for web pages that can source data at build time and pre-build pages accordingly. With that explanation complete, I will now hand the presentation over to Jeremy.

As Granola mentioned earlier, the Jamstack is a web application architecture that prioritizes pre-runtime building of pages as much as possible. This approach offers advantages in terms of performance, security, and scalability. It is particularly beneficial when content can be sourced before runtime. With this in mind, let's explore the requirements for launching a Jamstack application manually.

To provision the necessary services manually, you would need storage to host the site, a CDN to distribute it, serverless functions for invalidating old content on the CDN, a server to listen for webhooks from git repositories and build the site, and a hosting environment to deploy the built files. Additionally, you would have to configure roles and permissions for each service and user accessing them. Though we've outlined 16 high-level steps here, each step has sub-steps, making the process time-consuming and requiring in-depth knowledge of the cloud provider's services.

Furthermore, after provisioning the infrastructure, a Jamstack application requires specific procedures for deploying updates. In addition to committing changes to a git repository, developers must initiate the build process through a static site generator. After the site is built, the developer needs to upload the files to a hosting environment and invalidate the previous build on the CDN to ensure users always see the latest version. Automating this workflow is essential to save time and reduce the potential for errors.

To automate the workflow effectively, you need systems to detect changes and pull code during updates, build the site, deploy it to hosting and distribute it via a CDN, and invalidate old content. While some organizations might choose to build these systems themselves, most front-end developers and teams prefer to focus on application development rather than provisioning and implementing infrastructure. This is where Jamstack as a Service (JaaS) comes in.

JaaS providers manage the build and deployment processes for developers, enabling them to focus mainly on writing code and committing it to a git repository. The provider handles everything else, including provisioning infrastructure and, in some cases, offering additional features beyond the build and deployment processes. Providers such as Netlify, Gatsby Cloud, AWS Amplify, and Vercel are already available in the market. However, aside from Vercel, these providers are proprietary, charging set fees and limiting developers to their specific architectures.

To address these limitations, we developed Jade, which stands for Jamstack Deployment Environment. Jade is an open-source solution that allows developers to take control of their infrastructure without having to provision it themselves. It leverages AWS resources for provisioning and charges developers based solely on usage. Jade also offers customization options for all underlying AWS resources, making it a suitable choice for developers who want full control over their infrastructure.

Now, let's delve into what Jade is at its core. During the initialization process, Jade provisions six AWS resources, configures services, and sets permissions and roles for interaction between services and users. It establishes a connection between a public Github repository and AWS services to automate the build and deployment processes. This setup ensures that every time a commit is made to the repository, Jade handles the build and deployment, ultimately delivering the application to the end-user.

Jade's build process, which is where the Jamstack architecture differs from traditional web application architectures, is particularly crucial to understand. The core of Jade's build process resides in its EC2 instance, which stores user configuration, acts as an nginx reverse proxy, hosts a Node.js application to handle the build process, and maintains copies of the latest source code from the repository and the most recent build of the application.

The Node.js application in Jade comprises four components: a server to handle request routing, a build process component to gather resources and build the application, a logger to record build results, and an update component to send the built application to the deployment process. This setup ensures that the build process occurs seamlessly within Jade.

Now, let's explore the build and deployment processes in detail. Once a developer commits to their Github repository, Jade's EC2 instance receives a webhook notification. The Nginx web server within the EC2 instance validates the request's port and responds accordingly. If the port is incorrect, an HTTP 502 error response code is sent as a bad gateway indication. If the port is correct, the request is proxied to Jade's Node.js server.

The Node.js server then routes the request to the build.js component. Any requests sent to routes other than the web hook route result in a 404 not found error. If the request is sent to the correct route, the server proceeds to pass the request to the build.js component. build.js checks if the master branch of the repository has changed since the last build. If there are no new changes, a 202 response code is returned, indicating that the request has been accepted but not completed. However, if there are new changes in the master branch, a 200 response code is returned, triggering the build process.

In the build process, Jade utilizes the user configuration stored on the EC2 instance to access information such as the build command for the chosen static site generator (in this case, Gatsby) and any required data from external sources, such as a content management system (in this case, Contentful). The resources necessary for building the application are gathered, and Gatsby compiles the source code from Github with data from Contentful. It minifies and transpiles the code, bundling the assets into a static web application. Once the site is built, Jade retrieves AWS configuration information from the EC2 instance and proceeds to send the files to the deployment process via an S3 bucket.

The deployment process involves several AWS services: an S3 bucket to store the built application, a Lambda function to invalidate the previous build on the CDN, and a CloudFront distribution to act as the CDN. When a new build is uploaded to the S3 bucket, an event is triggered, executing the associated Lambda function. This function is responsible for invalidating the previous build on the CDN. It's important to note that assets distributed by AWS CloudFront typically expire after 24 hours by default. However, Jade's approach leverages how the static site generator versions most files and allows individual file invalidations on the CDN to update specific files. By utilizing these cloud technologies, Jade ensures efficient deployment of updated applications.

In summary, the Jamstack architecture has advantages, particularly in cases where content can be sourced before runtime. However, managing the build and deployment processes manually can be time-consuming and prone to errors. Jade, as a Jamstack Deployment Environment, offers an open-source solution that automates these processes, providing developers with full control over their infrastructure while leveraging AWS resources. By reducing the burden of provisioning and implementing systems, Jade streamlines the workflow, empowering developers to focus on their application development while delivering robust, performant, and scalable Jamstack applications to end-users. In this video, we will discuss the process of building the application using Jade as our framework. Jade utilizes the user config stored on EC2, which contains information such as the build command for the static site generator. It also utilizes the source code pulled from GitHub and can reach out to external data sources like a content management system. These resources are all needed to build the application.

Now, diving deeper into the build process, Jade is configured to use Gatsby as the static site generator and Contentful as the content management system. While there are many options available for both static site generators and content management systems, we chose Gatsby and Contentful due to their prominence. However, other tools can be used with further configuration by the developer. Jade is designed to out-of-the-box compatibility with Gatsby and Contentful.

When the build process starts, Gatsby compiles the source code from GitHub with data received from Contentful. It then minifies and transpiles the code to ensure compatibility with all browsers. Finally, it bundles the assets into a static web application. Once the site is built, Jade utilizes the AWS configuration, which contains the S3 bucket information, to send the files for deployment.

Moving on to deployment, the key components involved are an AWS S3 bucket, an AWS Lambda function, and a CloudFront distribution. The S3 bucket stores the built application, while the Lambda function invalidates the old build on the CDN. The CloudFront distribution acts as the CDN, distributing the application to end users.

Let's walk through what happens when a new build is received by the S3 bucket. The bucket has an associated event that triggers an AWS Lambda function whenever a new build is uploaded. This function is responsible for invalidating the previous build on the CDN. We want to highlight that CDN invalidation can be challenging. By default, assets distributed by AWS CloudFront expire after 24 hours. This means that if a new build is uploaded, CloudFront won't pull those files until 24 hours from the last build upload. To ensure users see the current version, Jade invalidates only the index.html file, which references the newest version of all other files. This forces the CDN to pull the most up-to-date files from S3, ensuring users always see the most recent version of the application.

And that's how the new files are distributed to the CDN, completing the deployment process.

Now, let's talk about the features of Jade and its architectural evolution.

We wanted to address a limitation of the framework, where only one user could control Jade at a time. To solve this, we introduced multi-user control by allowing cloud-based permissions and configuration files stored on AWS. Each user can be registered to access and update the Jade framework. The configuration files are stored in DynamoDB, AWS's NoSQL database, serving as Jade's single source of truth.

To support multiple Jamstack applications, we needed to address the issue of limited memory in EC2 servers. By horizontally scaling, each Jade application now has its own dedicated server, preventing memory constraints and reducing cluttered environments. Additionally, we introduced a "freeze" command that allows developers to halt EC2 instances temporarily, saving costs when they aren't actively developing.

To address compatibility with different Node versions, we containerized build environments using Docker. This allows developers to specify their desired Node and Gatsby versions, decoupling the build from the EC2 server's configuration.

To enable easy version management and atomic deploys, we introduced separate buckets for live and historical builds. Each new build updates the live bucket and the old version is zipped and stored in the historical builds bucket. This allows users to easily revert to previous versions for testing or debugging purposes.

Furthermore, we implemented a staging branch that enables developers to preview their site before deploying it to the CDN. Once satisfied, they can push the changes to the master branch, triggering the deployment process.

To simplify the management of versions on AWS, we created an admin panel. This panel abstracts the complexity of accessing S3, DynamoDB, and CloudFront. It provides a user-friendly interface to view previous builds, preview sites, and manage all relevant information.

With these features and architectural improvements, Jade empowers teams and developers working with the Jamstack to efficiently build and deploy applications. As a developer, it can be frustrating not being able to preview your site before it goes live. When you push your code to GitHub using the command `git push origin master`, your code gets sent to GitHub, and the files are automatically built. The built files are then uploaded to an S3 bucket, and the final site is pushed to a CDN (Content Delivery Network). However, if you make a mistake or accidentally change something, you won't realize it until after the site is already deployed to the CDN. At that point, it's too late, and your end users will see the error.

To solve this problem, we introduced a staging branch. When you push your code to the staging branch using `git push origin staging`, your code gets built and deployed to a staging bucket instead of the live bucket. This allows you to preview the site and ensure everything works as intended before pushing it to the CDN. Only after you've verified everything on the staging branch, you can push it to the master branch, and the distributed site will be pushed to the CDN.

Managing versions on AWS, however, became complex with the introduction of the staging branch. You not only had to keep track of historical builds but also the staging and master branches. This complexity was undesirable, so we decided to create an admin panel to abstract away this complexity. The admin panel allows you to easily manage and preview your site versions.

To access the admin panel, you can spin up a local server running Express.js using the command line. This server communicates with AWS on your behalf and generates a React dashboard for you. The dashboard displays relevant information such as the project name, links to the production and staging sites, the GitHub repository, and the workbook address to connect your GitHub with the EC2 instance. It also stores the build history, allowing you to download and compare different versions before committing to the latest version on your master branch.

In summary, the key steps in our Jade framework for managing site versions are as follows: the Git repository is connected to a build server, which pulls information from the Content Management System (CMS). The build files are then sent to storage, which updates the CDN. The function-as-a-service component invalidates the CDN, ensuring the end users can access and download the files directly from the CDN.

In terms of future work, we plan to add the ability for users to select the live site from the admin panel, allowing more control over version deployment. We also intend to implement a feature to manage serverless functions directly from the console, similar to other JASS providers. Additionally, we plan to support sourcing from other Git hosting providers, such as GitLab and Bitbucket, and automate the setup of webhooks for each JApp. Finally, we aim to expand language support in the build step by incorporating additional Docker containers, enabling the use of languages such as Ruby with Jekyll or Go with Hugo. This versatility will accommodate a wider range of Static Site Generators (SSGs) and build file types.

Thank you for listening and attending our presentation.