Hi everyone, and happy new year! Thank you for joining us today. My team and I are excited to introduce you to Haven, an open source solution for managing application secrets. Haven aims to simplify and secure the process of secrets management for software engineers while prioritizing security. 

To provide some context, let's discuss the complexity and overhead involved in secrets management. Secrets are sensitive pieces of data that authenticate or authorize access to a system. For example, a connection string used to authenticate a session with a database or an API token used to interact with a cloud provider. These secrets grant access to perform specific actions within the system. It is crucial to keep them confidential and protect them from unauthorized access.

It's important to clarify what should not be considered a secret. While other sensitive data like credit card information should be kept secure, they are not secrets in the context of application secrets management. Application secrets specifically refer to data that directly authenticate or authorize access to a system.

Now, let's discuss the risks associated with mishandling secrets. The principle of least privilege states that any user, developer, program, or process interacting with an application should only have access to the resources they require to perform their function. When secrets are mishandled, it can lead to costly mistakes. For example, a misconfigured automated testing process led to the deletion of DigitalOcean's primary database. This highlights the potential consequences of giving developers access to secrets they don't need. 

Moreover, mishandling secrets can also create opportunities for malicious actors. Capital One experienced a significant data breach when an attacker exploited misconfigured secrets related to AWS S3 buckets. Even unintentional mishandling of secrets by third parties who lack understanding of their sensitivity can lead to data leaks and compromises. It only takes one leaked secret to potentially unlock more secrets or expose sensitive data.

To ensure proper secrets management, it is essential to have answers to questions like where the secrets are stored, how they are accessed, updated, and revoked, who can use them, and what steps to take in case of a compromise. Unfortunately, while secrets are highly sensitive, they still need to be accessible to the application and its developers, which can create challenges in maintaining security without hindering accessibility.

Now, we'll discuss some common practices for handling secrets and their limitations. One common approach is to hard-code secrets in plain text within the application code or a separate file. However, this exposes the secrets to anyone who has access to the code, including version control systems like GitHub.

Another approach is to store secrets in environment variables. While this provides separation between code and configuration and allows for easy changes, it still presents security risks. Environment variables are accessible to the entire process, making it challenging to track and control their access. They are often logged or printed in plain text, which can further compromise security.

Encrypting secrets is another step in the right direction, but it's not a complete solution. Encrypted secrets still require an encryption key, which itself becomes a secret. Protecting this encryption key introduces its own challenges.

These common practices lack structure, process, and security. Secrets become susceptible to misuse, are error-prone to manage, and are challenging to propagate or revoke. When working in teams, managing secrets becomes even more complex. Enforcing the principle of least privilege and securely distributing secrets to team members becomes a challenge.

The result is often "secret sprawl", where secrets are spread across code, configuration, and communication channels. This can include sending secrets over insecure channels like Slack or email, resulting in a loss of control and visibility over who has accessed the secrets.

Secret sprawl also occurs within the infrastructure, with secrets scattered across CI tools, artifact repositories, and other cloud services. This further complicates the management and security of secrets.

To address these challenges, Haven provides a solution by abstracting the complexity and overhead of secrets management. Haven offers a centralized and secure platform for managing secrets, enabling software engineers to focus on development without compromising security. In the next section, we will discuss best practices and existing solutions in the secrets management space. After that, we will introduce you to Haven and its role in simplifying and securing secrets management.

In summary, secrets are sensitive data that authenticate or authorize access to a system. Mishandling secrets can lead to costly mistakes and compromises. Common practices for secrets management lack structure and security, resulting in challenges such as secret sprawl. Haven aims to address these challenges by providing an open source solution for managing secrets securely and efficiently. How do you effectively manage your environment configuration files while controlling access to them? What happens if you are on vacation when an update needs to be pushed? And once you've solved those challenges, how do you securely share secrets with team members who need them? For example, when onboarding a new team member like Bob, how do you ensure he has all the necessary files and credentials? Do you send them over Slack or email? Or maybe Alice has containerized everything, but still needs access to certain passwords on your machine. Do you simply ask her for them? Should she post them somewhere like Basecamp? And if Alice were to leave your team, how would you know which secrets she accessed, and therefore update them? A logical starting point would be your AWS credentials, but how do you propagate these changes? What's the downtime if you need to stop your application, find and replace the credentials in multiple places, recompile, and redeploy? 

As you can see, if you don't have structure, process, and security around your secrets, problems will continue to compound. What may seem like just a password or token here and there for the sake of convenience can lead to a much larger issue known as "secret sprawl". Your secrets end up scattered everywhere: in code, configuration files, and communication channels. You may be familiar with this problem yourself. It's so easy to send a database password or an API token over Slack or other communication channels. You might even get clever and split the secret across different channels, encrypt it, or take a screenshot of the encryption key. But even with these measures, your secrets are still sprawled everywhere. How do you keep track of them, see how they're being accessed, and control their use? And let's not forget that secrets are also sprawled across your entire infrastructure, from CI tools to artifact repositories. This problem only becomes magnified as more applications adopt serverless or microservice architectures. 

Ultimately, you lose visibility and control over your secrets. You can't answer basic questions like where they are, who has access to them, and what happens if they are compromised. While it may initially feel convenient to access secrets from anywhere at any time, especially when starting out or working in a small team, it's important to prioritize securely handling secrets early on to avoid headaches in the future. With that said, I'll now pass it over to Adam who will share how you can achieve this and discuss existing solutions that can assist you.

Now that we've seen the challenges of managing secrets and the risks of secret sprawl, let's explore how we can improve and securely manage secrets. I'll outline some principles to follow, considerations when choosing a secrets management system, and existing solutions that can help. Centralization is crucial for effective secrets management. The goal is to establish a single source of truth for all secrets and a consistent way of sharing them. Without centralization, we resort to inefficient and potentially insecure methods of sharing secrets, as mentioned earlier. However, with a centralized system, we gain visibility and control over who has access to what secrets.

Previously, we discussed how secrets can be sprawled across your infrastructure and passed between services. After centralization, only the necessary services have access to the secrets they require, minimizing the attack surface area of your application. Let's consider some common scenarios and compare how they are affected by secret sprawl versus centralization. Imagine Alice leaves the team. With secrets sprawled everywhere, it becomes difficult to determine which secrets she had access to and revoke them if necessary. However, with a centralized system, revoking Alice's access is straightforward. 

Now, let's consider the onboarding process for Bob. Without a centralized system, he may struggle to obtain all the necessary secrets to perform his work effectively. He might have to spend time requesting credentials from various team members. In contrast, with a centralized system, the secrets can be organized by project, and Bob can quickly gain access to all the secrets he needs with just a few clicks. This ensures that secrets do not become a roadblock to his productivity. Lastly, let's look at updating a secret, such as an API token. Without centralization, it can be challenging for Charlie to track down all the places the old token is used and ensure everyone knows about the change. However, with a centralized system, when Charlie updates the secret in one central location, any service or person requiring that secret will automatically receive the updated version, eliminating the need for manual updates. 

To achieve effective secrets management, you need a secrets manager, which is a centralized system designed to securely store and manage secrets while providing visibility and control over them. Let's now explore some key aspects of a secrets manager. When considering a secrets manager, the first question to ask is how it keeps your secrets safe. A crucial aspect is the encryption scheme it employs. You should also inquire about how it handles multiple users and shares access securely. Additionally, it's essential to understand how the secrets manager integrates into your application. How do applications retrieve secrets? This may require adjustments to your workflow depending on the chosen secrets manager. 

Let's dive into these three aspects in more detail and examine some existing secrets managers along the way. Regarding encryption, it is best practice to encrypt secrets on the client-side before transmitting them across a network. This ensures that secrets are never sent in plaintext, providing an additional layer of security. It's important to choose a secrets manager that implements client-side encryption, such as Enki, to protect your secrets effectively. One example is Enki's approach, which encrypts all data in transit and at rest. Their security model ensures that even in the unlikely event of a compromise of their servers, an attacker cannot read or modify an organization's secrets. This real-world example demonstrates the importance of selecting a secrets manager with robust encryption capabilities. 

Another encryption best practice to consider is key wrapping. This involves using a two-layer key system, where one key encrypts another key or secret. Key wrapping provides an additional layer of security by individually encrypting each secret with the recipient's public key. Secret Hub, for instance, employs key wrapping in its encryption scheme, encrypting secrets with the recipient's account public key. This layered approach enhances security and control over shared secrets.

Next, let's examine how secrets managers allow for safe and controlled access sharing. Doppler, for example, provides access management on a per-project basis, allowing users to be assigned access privileges in different environments like development, staging, and production. This ensures that access is granted only where necessary, following the principle of least privilege.

Finally, we need to understand how applications can retrieve secrets from a secrets manager securely. There are two primary ways this can happen. First, the secrets manager can be a passive component that applications query for their secrets. Developers would need to write code to fetch the secrets when needed. An example of this approach is using a .env file, where the application code imports a module to load the secrets stored in the file. Another approach is to store secrets in encrypted form within a git repository, as demonstrated by Mozilla's SOPS (Secrets OPerationS). However, this method lacks fine-grained access control and separation of concerns.

The second way applications can retrieve secrets is when the secrets are already available to the application's runtime environment. For example, orchestration services like Puppet or Docker Swarm provide built-in mechanisms to inject secrets into the environment. Similarly, Secret Hub runs applications as child processes and injects secrets into their runtime environment. This approach allows for monitoring and redacting of sensitive information to prevent accidental exposure.

There are a variety of existing secrets managers available, categorized as lightweight or heavyweight solutions. Lightweight options, like Doppler and Enki, prioritize ease of use and quick setup. Meanwhile, heavyweight solutions, such as Secret Hub and Vault, offer more advanced features at the cost of increased complexity. Vault, in particular, is popular among larger companies but requires a significant commitment to learning its complex system.

Regardless of the chosen secrets manager, it's important to remember that all commercial solutions require placing trust in a third-party provider. Consider factors such as encryption, access control, ease of integration, and alignment with your specific requirements. By prioritizing secure handling of secrets early on, you can set a strong foundation for growth, longevity, and reduced headaches in the future. The first approach to securely storing secrets in your application code is by importing a module and calling a method on that module to load the end file. Another method involves storing your secrets in encrypted form in your git repositories using an open source tool called sops by Mozilla. However, this git-based approach has some downsides, such as lack of fine-grained access control, logs, and a violation of the separation of concerns principle as secrets are closer to config than code. Another option is to make an API call in your code to fetch secrets. AWS provides a service called AWS Secrets Manager that allows you to interact with secrets through SDKs. However, using AWS Secrets Manager alone requires familiarizing yourself with AWS and setting up permission groups and policies manually. 

These approaches all require writing application code to fetch secrets. However, another possibility is that your application may already have the secrets it needs available. For example, if you use an orchestration service like Puppet or Docker Swarm, there may be a built-in method to specify secrets that are made available in the environment where your application runs. Another approach falling into this category is the Secrets Manager Secret Hub, which runs your application as a child process and injects the secrets into the environment. This provides some level of control as Secrets Manager Secret Hub can monitor the standard output and standard error streams of your application, redacting any accidentally logged secrets. This is the approach chosen by the Haven team, which will be discussed in more detail later.

Existing solutions for managing secrets can generally be categorized as lightweight or heavyweight. Lightweight solutions prioritize ease of use and quick setup, while heavyweight solutions offer more features at the cost of greater complexity. In the lightweight category, there are different options, such as Doppler, which emphasizes usability and has a growing list of integrations, and Enki, which prioritizes security by using client-side encryption. However, Doppler does not encrypt secrets, so they remain in plain text and rely on the security practices of Doppler. On the other hand, heavyweight solutions like Secret Hub and Vault offer more features but are more complex to set up and maintain. Vault, in particular, is popular among larger companies but is known for its complexity, requiring time and effort to learn and maintain.

All commercial solutions for managing secrets rely on third-party trust. The Haven team saw an opportunity for an open-source solution that is easy to use, has an interactive UI, and provides full control over secrets. While there are other open-source solutions available, they often require extensive setup or are designed for specific use cases like Docker. As a result, the Haven team built a secure yet straightforward solution that allows users to get started in minutes.

Now, I will hand it over to my colleague, Dan, who will introduce Haven and discuss its architecture in more detail.

Haven's architecture can be divided into two components: the client-side and the corresponding AWS infrastructure side. On the client-side, users, whether developers, admins, or application servers, use the Haven application to interact with the secrets managed by Haven. Each user has Haven installed on their personal machine and uses it to interact with the AWS infrastructure, with varying levels of permissions. In this section, I will focus primarily on the client-side, while my colleague, Aram, will delve into the AWS side in the next section.

To understand how Haven works, let's explore the different roles involved. There are two main roles: Haven Secrets Admin and Haven User. The Admin is responsible for creating projects, assigning permissions to users, reviewing access logs, and adding and updating secrets. The User has limited capabilities, such as creating, reading, and updating secrets, depending on their assigned permissions. Let's begin by discussing how the Admin can integrate Haven with their project.

As an Admin, you start by installing the Haven Secret CLI package from npm, which includes the CLI tool. Haven also offers a separate UI that you can download. Both the CLI and UI use the same Haven core package behind the scenes, issuing commands to AWS, so there is no functional difference between them; it's a matter of personal preference. Then, you run the Haven setup command, which creates your Haven account file containing your credentials and sets up your AWS account for provisioning Haven resources. These credentials authorize you to perform actions like creating projects, setting permissions, and managing secrets. It is important to note that Haven does not have an external server; instead, it utilizes your AWS account as the centralized storage for secrets. Haven also ensures that secrets are encrypted during transit and at rest in your AWS account. The initial setup only needs to be done once.

Once you have Haven set up, you can integrate it with your project. For example, you have a project called "BlueJ" where secrets are not managed properly. Haven allows you to provision resources for this project in your AWS account. As the Admin, you have full control over creating and deleting projects within your account. It is recommended to use the same project name to simplify management. When creating a project with Haven, it provisions the necessary resources for the project, environments, and predefined access control groups. These groups can be used to determine user permissions. For example, you can add a developer to the "BlueJ" production read group, granting them access to read production secrets. As the Admin, you have full access to all secrets added to your AWS storage. You can add secrets to the project environments using Haven, and Haven will encrypt and decrypt secrets based on user permissions.

Now that you have integrated BlueJ with Haven, you can add other users to work on the project. Creating a user is an Admin-only capability. When a user is created, Haven generates temporary credentials for them, which are saved on your computer. You then send these temporary credentials to the user. The user, in turn, installs Haven and saves the temporary credentials in their Haven account file on their personal computer. Users do not need an AWS account since they will be working as a user in your account with permissions you grant them. Haven provisions the necessary resources in your AWS account. The user then runs the user setup command to connect with your AWS account, and Haven generates their official credentials, replacing the temporary ones in their account file. If the temporary credentials are not used within an hour, they become void, and you, as the Admin, would need to generate new credentials for the user. Once the official credentials are generated, the temporary ones are deleted. The user can now interact with Haven, create, update, and read secrets based on their permissions. Permissions can be granted on a per project and environment basis.

To summarize, Haven allows multiple users on different machines to access secrets through the UI, CLI, or application integration. Each user has Haven installed on their personal computer, and all secrets, permissions, and encryption keys are stored in your organization's AWS account. The Admin manages, creates, and assigns permissions for projects, environments, and secrets. Developers and applications use Haven to interact with the centralized AWS account set up by the Admin. When a user no longer has permissions, Haven notifies you to rotate the secrets they had access to.

Now, I will pass it over to Aram, who will explain the underlying design and architecture of Haven.

Haven's design and architecture rely on several AWS services. Identity and Access Management (IAM) is used to manage user permissions and define who has access to watch secrets and perform operations. Key Management Service (KMS) is used to generate a master key and handle encryption and decryption of secrets. Lambda, a functions-as-a-service platform, is used to enforce the validity of temporary credentials. DynamoDB, a NoSQL database, is used to store secrets, logs, and other metadata on a per-project and per-environment basis. Finally, CloudFormation is utilized to easily set up and tear down AWS infrastructure, such as DynamoDB tables and permissions.

In conclusion, Haven provides a user-friendly, open-source solution for managing secrets in your applications. It allows users to securely access and manage secrets, with an interactive UI or CLI tool. Haven's architecture utilizes AWS services to ensure secure storage and access control. The Haven Secrets Admin is responsible for creating and managing projects, assigning permissions, and adding secrets, while users can interact with secrets based on their permissions. Haven integrates seamlessly with your existing AWS account, providing a centralized and secure storage location for your secrets. The Haven user, in this case, has limited permissions to create, update, and read secrets. We should restrict the server's access to only have the necessary read permissions for a specific project environment. When creating a server, Haven will generate temporary credentials for it and save them to the user's computer. These temporary credentials will be used later. As the admin, you will give the server read permissions for the desired project environment. After SSH-ing into the server where your app will be running, you need to install Haven globally or as a dependency in your project. Then, you will place the temporary credentials in a Haven folder on this server. Since Haven servers are considered users, you will run "Haven user setup" on this server. This command connects the server with your AWS account. These temporary credentials work the same way as when setting up a developer. This server is now ready to run your application with Haven. Using the command "Haven run" followed by the project name, environment, and your application's run command, you can run your application. Haven will fetch all the secrets in this project environment, decrypt them, and inject them into your app. Haven also redacts all secrets from standard out and standard error for added security. 

To summarize, multiple clients on different machines can use Haven to access their secrets through the UI, CLI, or in their applications. Each client has Haven installed on their personal computers. Every secret, set of permissions, and the master encryption key is stored on your organization's AWS account, set up by the Haven secrets admin. Both developers and applications use Haven to interact with this single central AWS account.

Now let's take a closer look at Haven's design and architecture. Haven uses various AWS services. We utilize AWS Identity and Access Management (IAM) to manage permissions for accessing secrets and performing operations. Key Management Service (KMS) is used to generate a master key for encryption and decryption. AWS Lambda enables serverless functions to enforce the validity of temporary credentials. DynamoDB is used as a NoSQL database for storing secrets, logs, and other project-related data. CloudFormation simplifies the codification of AWS infrastructure, making it easy to set up and tear down DynamoDB tables and permissions.

Moving on, let's discuss Haven's encryption scheme. We want to ensure that secrets are encrypted to prevent them from being in plain text. We use symmetric encryption, where the encryption key is used to both encrypt and decrypt secrets. However, the encryption key itself is a sensitive secret that can unlock all the other secrets. To address this issue, we use AWS Key Management Service (KMS) to create and store a master key. This master key is used to encrypt and decrypt data encryption keys, ensuring the security of secrets. Haven leverages envelope encryption, where each secret is encrypted with a unique data encryption key. The data encryption key is then encrypted with the master key, providing an extra layer of security. Secrets are stored alongside their encrypted data encryption keys in DynamoDB, ensuring secure storage.

Now let's explore how Haven handles multiple users and access control. IAM permissions are used to limit access to secrets based on project, environment, and action (read-only or read-write). In the Haven UI, access to secrets is displayed for a specific project environment. Each user can have different permissions, and permissions for existing users are controlled easily. The challenge arises when creating new users, as creating credentials for a new Haven user means creating a new secret. To address this, Haven uses temporary credentials that are valid for one hour. These temporary credentials are only allowed to request permanent credentials. An AWS Lambda function enforces the one-hour limit. The process involves the admin adding a user, downloading a Haven file with temporary credentials, and the new user running the user setup command, which connects the new user to their AWS account.

Finally, let's discuss how Haven injects secrets into applications. The goal is to provide an easy way to integrate secrets into applications without contributing to secret sprawl. One approach is to write secrets to a .env file on the application server, but this contributes to secret sprawl. Another approach is to store encrypted secrets in GitHub or another file and decrypt them during a pre-deploy script. However, this approach adds complexity and blurs the separation of code and configuration. The idea of manually fetching secrets within the code was quickly discarded as it requires changes to the application code. The most suitable approach is the technique of secrets injection, where secrets are stored externally (in Haven), and the application is invoked with a command that includes Haven, which fetches and injects the secrets as environment variables. The child process technique is used, where the application is run as a child process with standard in, standard out, and standard error all handled accordingly. Haven intercepts the logging of secrets, redacts them, and passes the redacted output to standard out and standard error.

In conclusion, Haven is a secure secrets management system designed to handle multiple users and provide access control to secrets. It utilizes encryption and access management services provided by AWS, ensuring the security of secrets. Secrets can be easily integrated into applications using the child process technique, where Haven injects the secrets as environment variables and intercepts any leaking secrets. Haven plans to further expand its features, such as supporting more runtimes, implementing per-secret access control, integrating with credential providers, and introducing email and notification systems for better control and management. The Haven team appreciates your attendance at this presentation and invites any questions you may have. In the upper middle of the diagram, Haven fetches the secrets for the project environment combination. It then spawns a child process using the command passed to it. The spawn method from the Node Child Process library is used for this purpose. The secrets are injected into the child process as environment variables, making them available for the application to use.

As the application runs, Haven intercepts both standard out and standard error. It redacts any log secrets and logs the redacted results. This can be seen in the lower middle section of the diagram.

In terms of future plans for Haven, there are several features that the team would like to add. First, they aim to support more runtimes besides Node.js for the child process. This would allow for greater flexibility in running various programming languages.

Secondly, the team plans to implement per secret access control to provide more granularity. This means that different users or roles would have different levels of access to different secrets.

Thirdly, Haven aims to have direct plug-ins and integrations with credential providers. This would simplify the process of accessing and managing secrets from external sources.

Lastly, the team wants to incorporate email and notification systems into Haven. This would enable users to have greater control over when and how they are notified about security events or secret management activities.

The team expresses gratitude to the audience for attending their presentation. They also invite any questions from the audience and allow a couple of minutes for queries.

One of the audience members, Rodney, asks why the team chose encryption as their area of study. In response, the team explains that they came across a Hacker News article about secrets management, which piqued their interest. Encryption is a crucial aspect of secrets management and had been a pain point in their previous projects. Therefore, they saw it as an opportunity to explore and address this problem.

Sena asks about establishing trust for the code among end users. The team explains that their project is open source and hosted on AWS. This allows users to review and verify the code for themselves, providing transparency and assurance.

Daniel inquires about other encryption techniques or methods considered by the team. The team shares their exploration of end-to-end encryption, inspired by Signal's messaging app. However, they found that there were varying definitions and complexities associated with this concept. As a result, they decided to focus on other encryption methods that would be more practical and effective.

The team mentions their initial desire to achieve true end-to-end encryption but highlights the challenge of storing the master key in AWS, which introduces a potential vulnerability. They briefly discuss encrypting secrets on the client side using public and private keys, but ultimately deemed it too complex for the user.

A question is raised regarding the impact of having four members in the group instead of three. The team acknowledges that having four members can lead to more extensive discussions and decision-making processes. However, it also allows for work to be divided among team members once the architecture and plans are established.

Austin refers back to an earlier statement about allowing admins to go on vacation or take a break without compromising the management of secrets. The team explains that their centralized secrets manager, Haven, addresses this issue by providing access controls and levels that can be distributed among other team members. This ensures that the responsibility for secrets management is not solely reliant on one individual.

One audience member asks if any bottlenecks were identified during the project and how the team resolved them. The team identifies the storage of secrets as a potential bottleneck. To address this, they chose to use DynamoDB as their storage solution due to its low latency.

The team is asked about the most challenging problem they encountered during the project and how they tackled it as a team. They mention the complexities of handling encryption with AWS and the extensive research required to determine which services to use. They emphasize the importance of thoughtful consideration and planning before beginning the coding and prototyping phases.