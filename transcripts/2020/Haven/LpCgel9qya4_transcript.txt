so hi everyone happy new year and thanks for coming out my team and i are very excited to share haven with you today haven is an open source solution for easily and securely managing your application secrets it abstracts away the complexity and overhead of secrets management for software engineers so they can get back to development without compromising security before we talk more about haven we'll build some context around that complexity and overhead itself we'll wrap up your knowledge about secrets why you should handle them properly and what can happen if you don't then we'll cover best practices and existing solutions that can help you in this space and last but not least we'll introduce you to haven and you'll see where it fits into the picture so let's dive right into it first you might be wondering to yourself what is a secret a secret is something you want to keep secret more specifically it's a sensitive piece of data that authenticates or authorizes you to a system for example you may have a connection string that you pass to a database so you can authenticate a session and request data from it or you may have an api token that you supply when you make a call to your cloud provider so you can read and write from its storage and you may have a private key related to a tls certificate that you present to your clients so you can authorize yourself into an elevated position of trust each of these things is a secret because they are in and of themselves some mechanism of access if your database password falls into the wrong person's hands it can be used to authenticate or authorize that person to perform dangerous actions they shouldn't so at least in the context of your application that's a secret and you don't want it to leak before we go on we should clarify what a secret isn't you probably have other sensitive data you'd like to keep secret to like credit card or protected health information but they're not secrets if they don't directly authenticate or authorize you to a system yes a credit card number matters and yes it should be stored securely if you're storing it for whatever reason but it's not in scope when we talk about application secrets however you can add a layer of protection over it by protecting your application secrets in the first place such as database passwords secrets are often confused with configuration too configuration is important because it influences how your application operates but not all of it is really private let's say your configuration defines parameters for a database connection like an adapter and a password we already mentioned why we have to keep the password secret but it's not so critical to keep the adapter secret too while it connects your application to the database it doesn't authenticate or authorize you in any way and your data won't be compromised if it were to leak so in that sense it's not a secret now hopefully that gives you a hint about why things that are secrets are important after all they're called secrets for good reason the principle of least privilege states that any user developer program or process interacting with your application should only have access to the things they need to perform their function the absolute fair minimum let's pause for a moment then and ask if someone has just a bit more access than they really need or one or two secrets happen to leak here or there what's the risk according to the principle of least privilege anyone working on your application should only have access to the secrets necessary for their work but maybe you don't want to bother controlling access to your secrets you're on a small team you know everyone personally you trust their intentions however people make mistakes over privileging developers and giving them access to secrets they shouldn't have access to can lead to honest but costly mistakes for example in 2017 digitalocean had an outage due to their primary database being deleted the root cause was a developer misconfiguring automated testing with production credentials as a result digital notion digital ocean sorry announced they would have to drastically reduce access to the primary system now even if developers could be picture perfect security wouldn't be such a great concern if there weren't bad actors out there mishandling your secrets can give attackers the wrongful ability to elevate themselves into positions of trust where they can do great harm and this can be very costly where customer data is concerned for example you you may remember capital one making headlines in 2019 when they had a data breach that affected over a hundred million individuals that was due to vulnerability around configuration secrets involving aws s3 buckets the attacker previously worked as a developer for aws and was able to explore a misconfigured firewall to extract files in a capital one directory stored on aws servers in fact the misconfigured firewall had too many permissions it could list and read any file in any bucket of data when i shouldn't have been able to and still data can be compromised even without human error or malicious intent data can be leaked via third parties that simply don't understand your secrets are sensitive and how to handle them with care that's because they shouldn't have had access to them anyway and it's hard to say what they'll do with that unintended access it can take just one leaked secret to unlock more secrets or very important sensitive data compounding any data leak so not only do you break the principle of least privilege you also break the principle of these astonishment and that your software may not act the way you expect it to if you take away one thing here it should be that secrets are the keys to your kingdom so it's imperative to handle them properly among other things you should be able to answer questions like where they are where they end up how their access how they're updated how they're revoked who can use them when they use them how they use them and what happens in a compromise but the conundrum is that while secrets are extremely sensitive they must be accessible to you and your application and in your day-to-day accessibility will often feel like a more pressing concern it's convenient but it's dangerous on that note let's break down some common practices you may use in your day-to-day if you have keys to the kingdom how do you handle them maybe you don't after all your code and scripts probably need secrets to do their work interact with other applications or tools in the tool chain and access cloud resources so the happy path may be to simply hard code your secrets in plain text but that means anyone who has access to your application can read and probably edit them and if you check them into a version control system like github anyone anywhere can read them that's regardless of whether your secrets are in your application code or a distinct file if they're in a configuration file well you may be violating a separation of concerns and you still may check the file in by accident a secret style dedicated to holding your secrets is no more foolproof it may sound like a simple mistake to avoid but data leaks via github are actually pretty common in 2019 researchers scanned nearly 13 of github's public repositories and found that over a hundred thousand of them contain exposed secrets and thousands more are leaking new unique secrets every day they also noted that it wasn't just inexperienced developers leaking secrets and hobby projects several large prominent organization's word too including a popular website used by millions of college applicants in the us and a major government agency in europe both exposing their respective aws credentials maybe you set your secrets in the environment instead then heroku's 12-factor methodology for building sas applications made popular the practice of storing configuration in environment variables and since secrets are often spoken about in the context of configuration it may follow to store your secrets and environment variables too heroku actually recommends doing so with credentials to external services such as aws s3 and twitter if you have a node.js application you probably store your secrets like that in environment variables via a dot m file like you see here and it's not illogical to do so a primary reason is that your environment configuration file is separate from code so the environment variables are easy to change between deploys without touching code and less likely to be checked into a version control system by accident there are many downsides of storing secrets in plain and simple environment variables though to keep it short they're leaky and susceptible to misuse if you use an environment configuration file anyone who has access to your application can still read and probably edit your secrets like in any other coder file on top of that the environment is implicitly available to your entire process so it's nearly impossible to track how your environment variables may be accessed or exposed for example they're commonly logged or printed in plain text for debugging and error reporting and since environment variables are passed to children processes your secrets are made available to anything your application calls including third-party tools then maybe you encrypt your secrets first that's a good start but while encrypting secrets protects them from immediate thread it isn't a complete solution for starters rotating or updating secrets is critical for your application security but whether you store your encrypted secrets in a dedicated file or in environment variables they're awkward and error prone to change at regular intervals and functionally impossible to change between deployment in addition you now have an encryption key that unlocks the encrypted secrets but that encryption key is a secret in itself so how do you secure it without kicking the can down the road this is a challenge we'll revisit later in the presentation already we can see problems with the common ways you may handle secrets in your day-to-day there's a lot that can go wrong when other developers bad actors or third-party applications have access to secrets that you didn't intend for for one your secrets become susceptible to misuse at best it may be hard for a developer or third party to grasp the sensitive nature of secrets they're not supposed to have access to in the first place their implicit expectation will probably be that there's nothing special about these things they can freely access but that doesn't align with the with the requirements you may have for tightly controlled access surrounding them and that can result in something like an entire database being deleted as with the digital ocean example when secrets aren't overlooked they're still awkward and error-prone to manually configure manage and rotate and since you don't really know or can control things like where your secrets ends up or who's accessed them they're not trivial to revoking a compromise all too often though secrets are misunderstood and mishandled as a result it's pretty difficult to maintain them properly but it's sort of a chicken and egg problem is it difficult to handle your secrets because you lack visibility and control over them or do you lack that visibility and control because you haven't handled them properly in the first place and these problems are only exacerbated when you're working in a team how do you decide on and maintain access levels that make sense for your team's workflow you know now about the principal least privilege but how do you enforce it if charlie needs an api token but not the database password how do you split up your environment configuration file and control what he accesses or what happens if he's ready to push a new update but you're on vacation even once you figure that out how do you securely distribute secrets to team members who need them when you onboard bob how do you get his necessary files and credentials to him do you send it to him over slack email or maybe alice has containerized everything but still needs a bunch of passwords to work on your machine do you just ask her for them will she post them somewhere like base camp then do you store them locally and if alice leaves your team how do you know which secrets she's accessed that you now have to update maybe your aws credentials are a good starting point but how do you propagate the changes what's the downtime if you stop your application find all 10 instances of the credentials in 10 different places replace them recompile and redeploy you can probably see by now that if you don't have structure process and security around your secrets the problems can and will keep stacking and stacking while you may feel like it's just a password here or token there for the sake of ease and convenience eventually you'll find you end up with a big headache called secret sprawl your secrets are sprawled everywhere or at least they can be sprawled anywhere they're sprawled across code configuration and communication channels maybe you're familiar with this yourself after all it's so simple to just send a database password or an api token over slack maybe you're more clever than that though and you only send half of it over slack and the other half via email that way someone would have to access two of your communication channels to get the full secret right maybe you even encrypt the secret first and send the encryption key via third communication channel like sms and add it onto that you take a screenshot of the encryption key so you can send a photo of it instead of pasting it in plain text but the encrypted secret and the encryption key which is yet another secret are still just sprawled aren't they how do you keep track of them see how they're being accessed or control how they're being used and if that's not enough of a headache secrets are sprawled across your infrastructure too from ci tools to artifact repositories this can quickly be made worse as many applications shift towards serverless and or microservice architectures and secrets need to be shared in the cloud or between services in any case you lose visibility and control over your secrets you can no longer answer questions like where they are and end up how they're accessed updated and revoked who can use them when and how and what happens in a compromise it may feel more convenient or worthwhile to simply be able to access your secrets from anywhere at any time especially when you're first starting out or working on a small team quite frankly our team gets it we've felt the confusion frustration and inconvenience around secrets ourselves but if you want growth and longevity plus less headache later you'll thank yourself if you shift your focus to securely handling your secrets now so with that i'll hand it over to adam he'll share with you how you can do that and existing solutions that can help you do that thanks rebecca so now that we've seen what a secret is and how we get secret sprawl if we're not careful let's see how we can do better and securely manage our secrets i'll go over some principles for doing that as well as some considerations in choosing a system to manage your secrets and some existing solutions that do that centralization is critical to secrets management you need to go from this to this you need to establish a single source of truth for your secrets in a single way of sharing secrets when you don't have that you do weird things to share your secrets as rebecca alluded to but when you do have a centralized system you don't have to do weird things and you gain visibility and control over who has what secrets previously rebecca showed secrets might be sprawled across your infrastructure you might even be passed down service to service in your pipeline but after centralization only your app needs to have its secrets or rather whatever service needs secrets will get only the secrets they need thereby reducing the attack surface area of your application as a whole to drive it home let's look at some common work scenarios and contrast what they look like when you have sprawl versus how they're improved with centralization so let's say we have secrets all over the place and alice quits what secrets does alice have does she retain access we may not know with the centralized assistant it may be straightforward to revoke her access i won't say that bob just joins the team without a system in place he's not likely to get all the secrets that he'll need to do his work in a complete or controlled manner instead he may plug away at his work and then find he needs a credential of some kind and have to ask around by contrast with the centralized system we may have our secrets organized by project and be able to give up all the access he needs with a few clicks and secrets won't be a roadblock to him doing his work finally let's say charlie updates an api token which will be the most common scenario of these three which would be updating a secret so the old token is no good anymore and applications will crash if they try using the old one what does charlie need to update to make sure everyone has the new token it may be a chore just for charlie to hunt down places that need to know uh the people that need to know and uh by contrast with the centralized system if he updates it in the one centralized place the next time any service or person needs that secret they'll grab it from the same place and automatically get the updated version we're now ready to discuss secrets managers which are centralized systems for your secrets they are systems that help you securely store and manage your secrets and give you visibility and control over them in the next several slides after this one i'm going to mention these existing secrets managers to illustrate some particular points so a few players of the players in this space as you'll see are key secret hub doppler and vault and with that let's consider key aspects of the secrets manager and let's say that you're sold on using a secrets manager what do you need to look for in one first the secrets manager must keep your secrets safe to do that it should encrypt your secrets so the first thing you should ask about a possible solution is what is its encryption scheme how does it keep them safe and second how does it accommodate having multiple users how does it let you share access safely this won't necessarily apply if your project will always be a solo one but most of the times that you'll reach for secrets manager will be when you're working on multi-person projects and third you need to know how to actually use it in your application how do applications actually get secrets you might have to significantly adjust your workflow depending on the secrets manager that you pick in the next few slides we'll look at each of these three aspects in more detail and we'll also look at existing secrets managers along the way and by the way the mini map in the top right shows we're on the first of the three key aspects we're going through and to get started with that let's go over a few encryption best practices first you should encrypt client-side this means speakers are encrypted before being transmitted across a network so secrets never leave your machine unencrypted that way you don't have to trust the party you're sending it to or the communication channel that you use still when it comes to security it's best to have a multi-layered strategy so that if one layer fails the system as a whole is still secure and with that in mind you should use an encrypted communication channel which is called encryption and transit description in transit and giving you temporary stopping points between the client and the final destination finally your storage device should also be encrypted this is called encryption address something to keep in mind is that not all secrets managers will implement client-side encryption although encryption and transit and arrest are universal one of many existing secrets managers is the nfk and let's see what they have to say about encryption taken from their home page and their security docs so we never see your secrets in plain text they say and apart from providing client-side encryption and key follows best practices all data is encrypted in transit interest it's great and in their security docs they lay out their security model and they say even in the unlikely scenario of a compromise of nvkey servers it should not be possible for the attacker to read or modify an organization's secrets this is just one real world example of a company that implements client-side encryption encryption and transit and encryption at rest there is another encryption best practice to look for that falls along sort of a different dimension than the ones previously discussed and that's the idea of key wrapping the basic idea is to have a two layer key system where a key is something that encrypts something else secret hub uses this idea of key wrapping to create individually encrypted secrets one layer of key is the individual's account public key a public key for each person that will have access to secrets and the second layer of their key wrapping scheme is the encrypted secret itself which is encrypted with the individual's account public key you can also use this idea of key wrapping in a different way which haven ended up doing in which we will discuss later in this presentation after you've figured out the encryption scheme a secrets manager uses to keep your secrets safe you need to know how it lets you safely share access how can other members of your team get access and how can applications get access in a way that respects the principle of least privilege one new player in the secret space is doppler and they let you manage access like you see here at the top left we see these red box shows access is on a per project basis and we're looking at a project called yoda speak on the bottom right we see that access is given on a per environment level so that you can assign someone to have access in the development environment staging environment and or production environment so let's say that both the encryption and the ability to safely share and control access seem solid for some solution you're considering then you'll want to know how do i actually use it to provide secrets to my applications at a high level either your applications has to fetch the secrets that it needs so you have to write some application code to do that or your application is run in a certain context such that it already has the secrets it needs let's look at the first way where the secrets manager is a highly decoupled and passive component using a dot n file falls into this category in node.js applications you would import a dot and module in your application code and then call a method on that module to load the end file another approach that falls into this category is storing your secrets in your git repos encrypted mozilla has an open source tool called sops that lets you do this the downsides with this specific git based approach is it doesn't permit fine-grained access control or logs and it doesn't adhere to separation of concerns as secrets are much closer to config than code finally you might make an api call within your code to fetch secrets aws has a service maybe we should call it a product called aws secrets manager and they provide sdks to interact with it a downside of using aws secrets manager alone is that you need to get familiar with aws and you have to set all the permission groups and policies yourself what these approaches all have in common is that you must write application code to fetch secrets on the other hand your application might also be run with the secrets it needs already available for example if you use an orchestration service such as puppet or docker swarm there will likely be a built-in way of specifying secrets which will then be made available in the environment your application code executes in another approach that falls in this category is what the secrets manager secret hub does secret hub actually runs your application as a child process and injects the secrets into the environment of that process this gives secret hub some level of control you can monitor the standard out and standard error streams of your application which lets it redact secrets that you might accidentally be logging this is the approach the haven team ended up taking which we will go more in depth in this presentation later overall existing solutions can be broadly categorized as lightweight or heavyweight where lightweight emphasizes ease of quickly getting started using it and heavyweight emphasizes features even in the lightweight category there's some diversity for example doppler emphasizes usability and has a growing list of integrations but arguably enki emphasizes security more as they use client-side encryption whereas the doppler doesn't so that your secrets are stamp plain text and you trust doppler that they securely handle them after that the heavyweight ones such as secret hub and vault tend to offer more features but at the cost of greater complexity vault is far and away the most popular solution for bigger companies and they do have an open source version too but ball is complex their own docs even say and i quote alt is a complex system that has many different pieces using vault means committing to learning a new vocabulary one that is particular to them is a lot of work setting up and maintaining it so it can be overkill for many teams ultimately all commercial solutions here are third parties that you have to trust we see room for haven an open source solution that is easy to get started with and has an interactive ui something simple and usable but something you have full control over other open source solutions exist but none of them are ideal for getting immediately productive either there's a lot of setup required or they are really built for a specific use case like docker so our team built any solution that is secure but also straightforward and lets you get started in minutes now i'll turn it over to my colleague dan who will introduce haven thanks adam let's take a look at what haven has to offer the architecture of a haven instance can be roughly split up into two components the client side and the corresponding aws infrastructure side on the client side each user be it a dev admin or application server uses the haven application to interact with the instance's secrets all of these users have haven installed on their personal machines and are using haven to interact with the same aws infrastructure albeit with varying levels of permissions in this section i'm going to predominantly focus in on the client side and in the next section my colleague arum will mainly hone in on the aws side how does haven work we'll see how you as a single user can get haven set up as an admin and integrate your project with haven then we'll take a look at how you can add another user to haven to work on your project and finally you'll run your app with haven on a production server before we go any further i want to explore the roles when working with haven you could be a haven secrets admin or a user with haven permissions the first person who needs to get up and running is the admin this is the person responsible for creating every project every user assigning permissions to said users and reviewing access logs the admin can also add and update any number of secrets for their project's environments we'll discuss haven users in more detail later on now let's run through how you as an admin would get started integrating haven with your project in order to manage your secrets securely first as the admin you'll need to install the haven secret cli package from npm which comes loaded with our cli tool we also offer a ui that you can download separately you can use either tool to interact with haven both use the same haven core package behind the scenes issuing the same commands to aws so there's no functional difference between using the ui or cli it's all a matter of which workflow you prefer you will then run haven setup this initial setup only happens once here haven creates your haven account file which contains your haven credentials and places it in a haven folder on your personal computer it also sets up your aws account to provision the proper haven resources for creating projects in their environments adding users setting permissions and adding and updating secrets these credentials authorize you to perform the actions described above running setup assigns you as the haven secrets admin which gives you complete control over anything you integrate with haven you'll be able to add project secrets to your aws account through haven now what does that mean there's no external haven server with your secrets your aws account is the single centralized storage haven also takes care of the process of ensuring that your secrets are encrypted in transit as well as when they are stored at rest in your aws account in this scenario since you're working on a solo project this might not seem like a big deal but it will come into play later in other scenarios now that you have havens set up on your computer it's time to start integrating projects with haven here you have a project called bluej currently the secrets are not managed properly either by being hard coded stored in dot m-file etc and it might not seem like any harm but we can recall from earlier just how easily this can spiral everywhere leading to secret sprawl let's see how you can start using haven to secure blue jays secrets since haven can be used for multiple projects we need to have haven provision the proper resources for this project on your aws account as the admin you are the only person who will be able to create and delete projects under this account it's a good idea to give the projects the same name for the sake of simplicity when we create a project with haven haven will provision the proper resources for their project the project's environments and the groups with predefined access levels when we create users in the future we can easily add and remove them from groups to determine their permissions for example we can add a developer to the bluejays production read group which will give them access to read any of bluejay's production secrets since you're the admin you'll have full access to all secrets added to your aws storage next add all your secrets to whichever environments you wish to include haven encrypts every secret and will only decrypt the secret based on the user's permissions now that you have haven set up and have integrated project bluej let's add a new user going back to this role comparison we could see that haven dev users have a lot less capabilities than the haven secrets admin they will only be able to create read and or update secrets per project environment depending on their permissions creating a user is an admin only capability when you user haven will provision temporary credentials for this user that will be saved to your computer you'll then send these temporary files to the intended developer your developer will also need to install haven from npm on their personal computer here the developer has received the temporary credentials you sent them and has stored them in a haven file on their personal computer haven users don't need an aws account since they'll be working as a user in your aws account with only the permissions you grant them all the haven resources have already been set up earlier by you in your aws account however the developer cannot interact with any projects and secrets just yet they'll first need to run user setup on their computer this command connects them with your aws account haven uses the temporary credentials to create their official haven credentials and replaces the temporary ones in their haven account file stored on their personal computer once their official credentials are generated the temporary ones are deleted and won't be able to fetch the user's official credentials again also to add another layer of security if these temporary credentials are not used within an hour they will become void and you the haven secrets admin will have to generate a new user for this developer the developer will now be able to interact with haven by creating updating and or reading secrets based on their permissions you'll be able to grant them read and or write access for secrets on a per project environment basis granting permissions is an admin only capability to see this all at a higher level let's walk through this example earlier you put some secrets into your central aws database through haven haven encrypt them in transit and in storage then the developer we just created was able to use haven on their client side and since they have read permissions they can access your organization's organization's central aws database and decrypt the secret giving them access to the same secret you added to this centralized storage both the admin and the developer are using haven on their own computers to access the same aws account set up by you the haven secrets admin when it's time for your developer to leave your project for whatever reason you can completely revoke them or if they're just switching teams you can revoke them from only certain project environments we can see that the revoked user can no longer access these secrets in your aws account whenever a user loses permissions haven will notify you to rotate the secrets the developer once had access to by flagging them we've seen how you as the admin can get up and running with haven we've also seen how to integrate a project with haven then we took a look at how to add other developers to work on your projects finally let's look at how you can add a production server to run your app with haven this process is fairly similar to adding a user as the admin you're the only person who is able to create and delete servers under this aws account every server you create will be considered a haven user and will at most be able to create update and or read secrets based on its permissions we should limit the access of these servers to only have the read permissions they need for a specific project environment when you create a server haven will provision temporary credentials for this server and save them to your computer you'll be using these temporary credentials soon so hold on to it as the admin you'll give the server read permissions to a project's desired environment next ssh into the server where your app will be running and install haven globally or as a dependency in your project you'll then place the temporary credentials in a haven folder on this server since haven servers are still considered users you'll run haven user setup on this server this command connects the server with your aws account that was set up in the previous example these temporary credentials operate the same as the developer getting set up this server is ready to run your application with haven using the command haven run followed by the project name and environment and ending with your application's run command you can run your application haven will fetch all the secrets in this project environment decrypt them and inject them into your app haven also redacts all secrets from standard out and standard error to provide a greater degree of security here's a zoomed out picture of everything we've covered multiple clients on different machines can use haven to access their secrets either through the ui cli or in your application each client has haven installed on their personal computers every secret set of permissions and the master encryption key is stored on your organization's aws account set up by the haven secrets admin every developer and every application is using haven to interact with this single central aws account now i'm going to throw it over to aram to show you how haven manages to achieve all these features under the hood thanks dan now that we've seen the core functionality of haven let's take a deeper look at its design and architecture let's revisit the architecture diagram we saw earlier and go over the aws services we used in the right side of the diagram we used identity and access management also known as iam to dictate who his permissions to access watch secrets and perform which operations key management services kms to generate a singular master key and perform encryption and decryption lambda which allows a user to run functions as a service on aws to enforce validity of temporary credentials dynamodb a nosql database to store secrets on a per project and environment basis as well as logs and we chose to use dynamodb due to its low latency in cloud formation which allows one to codify aws infrastructure easily set up and tear down dynamodb tables and permissions now that we've seen the architecture of haven let's take a deeper look at some of its key aspects first we'll take a look at the encryption scheme used by haven from there we'll see how haven handles multiple users and access control and finally we will go over how haven injects secrets into applications now ideally we want secrets to be encrypted so they are not in plain text with regards to encryption and secrets however a problem arises assume you use symmetric encryption so the encryption key both encrypts and decrypts your secrets but that encryption key is a secret in of itself and a particularly sensitive one since it can unlock all of your secrets you might try to encrypt that key with another key but that would be yet another key you have to encrypt and this chain would keep going ad nauseam one way to solve this problem is to have a trusted third party service store a master key that you don't have physical access to instead you dictate who has permissions to use it to perform encryption and decryption operations in the case of haven we use the battle tested aws key management service to create and store this master key and limit encryption decryption access to it via aws iam policies we don't need to worry about safely storing this master key since aws handles that now we've decided to use a master key how is it actually used in practice you could encrypt your secrets directly with the master key or use the common technique of envelope encryption this is very similar to the keywrapping technique adam mentioned earlier envelope encryption involves generating a unique data encryption key for each secret and encrypting the secret using that data encryption key then the data encryption key is encrypted by the master encryption key the encrypted data encryption key and encrypted secrets are then stored until they are decrypted later to decrypt your data you simply perform this process in reverse decrypting the data encryption key with the master key and then using the decrypted data encryption key to decrypt your secret data there are some advantages to this first it's harder to brute force than encrypted data since each is encrypted using a different key second you can store the encrypted data encryption key alongside the data and encrypts meaning you only have to worry about the security of the master key let's take a look at how haven implements envelope encryption so haven utilizes the aws encryption sdk an aws service that lets you perform encryption and decryption using your kms master key first a unique data encryption key is generated and is used to encrypt the secret on the client side as seen in the top right there then as shown in the top left that data encryption key is encrypted using the singular master key stored in kms both both of these encrypted pieces of information are encrypted in transit via tls and sent to dynamodb to be stored alongside each other as shown in the bottom of the diagram thus we can see that haven encrypts your data client side in transit and at rest up on dynamodb when dealing with a centralized secrets manager handling multiple users and ensuring the principle of least privilege becomes very important haven handles this using iam permissions access to secrets is limited on three dimensions by project environment and action where an action is read only or read write here in the haven ui we are looking at the secrets for the dev environment for project bluejay we can see that the user sue has read and write access to these secrets handling permissions of existing users is straightforward enough but the creation of new users posed a challenge for us because creating credentials for a haven user means creating a new secret our solution was to create temporary credentials that are only good for one hour additionally these credentials don't have permissions to do anything except request permanent credentials this draws heavy inspiration from temporary password policies that many websites employ where the temporary password expires after a short time in our case an aws lambda enforces this one hour limit taking a look at the flow first the haven admin adds a user either in the ui or cli as we saw earlier a haven file with temporary credentials is then downloaded and the admin sends this to the new user next the new user places the haven file in their home directory and runs user setup haven invokes the aws lambda using the temporary credentials which in turn checks if it is still valid and updates the haven file finally the new user tells the haven admin that they set up their account and the haven admin is free to add that new user to projects and environments after seeing how haven encrypts secrets and sets up new users the question becomes how do you get secrets from haven into your applications any solution should fulfill the following requirements first and foremost it must not contribute to secret sprawl if you're going the distance and using a centralized secrets manager you don't want to fall back into secret sprawl for that final step of getting secrets to your applications and second it should be easy to integrate the solution shouldn't be a burden that causes developers to not want to use it now let's briefly recap some possible techniques for getting secrets to an application that adam mentioned earlier and some of the problems with them we could retrieve the secrets from haven and write them to a dot-n-file to be used by the application the problem with this approach is that we're back to secret sprawl since our secrets are sitting in a dot and file out on a server and plain text we could store the encrypted secrets and say github or a.n file and then decrypt those secrets as part of a pre-deploy script but this is approaches a bit more work for the user and also muddles the separation of concerns between code and configuration another approach that briefly came to mind was to require the developer to manually fetch the secrets within their code and use them accordingly we quickly passed on this approach since it requires changes to application code and is not as easy for a user to set up there was one existing solution that stuck out to us however secrets injection you might recall adam talking earlier about the technique the secrets manager secret hub uses in a nutshell you store your secrets in secret hub and then you seek it up to run your application passing in the command to start your application as an argument secret couple then fetch your secrets run your application as a child process and eject the secrets as environment variables this technique comes with some key advantages that we can use in haven first your secrets aren't stored on the application server so you don't need to worry about contributing to secret sprawl second due to the nature of child processes haven can reject any secrets leaking out on standard out or standard error this leakage can often be yet another source of secret sprawl finally it's easy to implement in an application we can simply install the haven package and change our application start command to include haven run so let's briefly cover how child process works a process can be simply thought of as a running program many programming languages allow for the creation of sub-processes while running a program and often times there are several options for how to create that sub-process but in our case we will focus on the spawn method from the nodejs child process library when using the spawn method you specify the program you want to run and that program is ran as a child process the standard io of the child process is pipe 2 and from the parent process that is standard in is piped into the child from the parent and standard out and standard air are piped from the child to the parent this is what allows us to both provide a simple wrapper to fetch secrets and call any arbitrary run command a user might have as well as let us intercept any logging of secrets on standard out and standard air and redact them so how does this child process technique fit into our architecture first all you need to do is place the haven file for the application in your home directory install the haven cli npm package as a dependency in your application then as seen in the console you will use the haven run command to run your application specifying the project environment and command you want haven to run in the example shown here blue j is the project prod is the environment and nodebluej.js is the command that will be ran by haven as shown in the upper middle half of the diagram haven will fetch the secrets for the project environment combination and then spawn a child process via the command you pass to haven using the spawn method from the node child process library the secrets are injected into this child process as environment variables making them available for the application then as the application runs haven intercepts both standard out and standard error redacts log secrets and then logs the redacted results as we can see in the lower middle half there now there are some features we would like to eventually add to haven first more runtimes besides node.js for the child process we inject secrets into second per secret access control to allow more granularity third some direct plug-ins and integrations with credential providers and lastly email and notification systems to permit greater control and with that this is the team that brought you haven uh thank you for coming to our presentation and we'll give it a couple minutes for any questions you might have so feel free to ask away so it looks like we have a question here from rodney um what made you guys choose encryption as your area of study so kind of while searching for a topic um there's a lot of stuff that was on the table but there was a hackard news article about secrets management that sort of um caught our attention and that's sort of what kind of led to us digging deeper to the section just to add on to that i'd also say encryption is just a part of this whole secrets management thing um as we were building this and in previous projects in capstone 2 we found that secrets management really was a problem and a pain point that we experienced so it was great to explore that area further okay i guess we got one here from senna about uh how do you establish trust for your code for end users for this type of software so this is open source so and it is all hosted on their aws so they're free to check through our code take a look at all of it and that's sort of how the that's it's resolved i guess i'm seeing that we have a question from daniel were there any techniques or methods you considered around encryption before you settled on the solution you used that was interesting because one thing that we all saw mentioned was this concept of end-to-end encryption if you use the signal app you may have noticed that they say they give you end-end encryption as we dug into that we found that it's kind of a loose term more of a marketing speak um that essentially means client-side incorporation or encrypting on your site before it goes anywhere else although there are varying definitions for that so we thought we wanted to do intend encryption we uh we decided to get more concrete um and that just sort of abandoned that that idea another interesting thing that we looked into with encryption was the idea of encrypting a different secret um for every user um and i'm trying to recall what the challenges would have been with that ultimately we decided that it wasn't worth the much greater complexity for doing that it comes back to me i'll let you know um just adding on to that i guess with end-to-end encryption we are getting pretty pretty close to that and i remember i was stressed for a period of time where i really wanted to make that happen but um beyond the client-side encryption encryption in transit and encryption at rest the thing that kind of distinguished antenna encryption from all that is that like for whatever reason if we really had to decrypt those secrets well the master key is stored in aws so aws could technically go in there and decrypt the secrets which prevents it from being end to end um so we did consider some solutions around that such as encrypting the secrets on the client side using uh the client's public key and having them keep their own private key but that that would have just added too much complexity on the user side so we have one here that i think we can all sort of address it's about how our capstone group had four as opposed to three and uh can you talk about how those both an asset and liability and for our team dynamics i guess one thing i would say is uh with four people you do sort of run into where some even a small decision sometimes turns into kind of a big conversation a lot of time is used trying to come to a consensus among four instead of just kind of taking the you know immediate best idea and just sort of going from there i don't know if anyone else wants to follow up on that of course some assets are you know we can split the work once we are all comfortable with the architecture and our plans to move forward we could really delegate you know one person to a different corner and work a little faster that way um next question austin said you mentioned early in the presentation that you want the admin who must manage the secrets to be able to go on vacation slash take a break did you find a solution for a service that should necessarily be so centralized and still allow some flexibility for admins um so that point was earlier in the presentation when we were addressing the problem of secret sprawl and you not having that kind of visibility and control over your secrets where they are and who can access them which makes it a lot more difficult when you're in a team setting so if you're the admin and you are the person controlling these secrets and you go and go away on vacation or you want to take a break it's more so how do you control access levels or distribute these secrets to other team members but with a centralized secrets manager such as haven that problem is addressed because you'll have you'll have such access controls and actual access levels built in already and to add on to rebecca's answer in our research we noticed that vault was popular for big teams um but they really you really need as an organization to have the bandwidth to manage that so we're more targeting smaller teams who wouldn't have a multiplicity of admins necessarily yeah and also just the last part of that question um a solution that centralized and allows our flexibility i would say that it's actually that centralization that allows for such flexibility because otherwise it would be the hassle and overhead of how do you get i'm sorry these notifications are going off right now how do you get these um secrets that aren't centralized to someone in a secure manner and we have a question from justin uh was there a new bottleneck you identified in your system and how do you address them so i guess one bottleneck sort of is with the storage you decide to use for your secrets up on aws there's plenty of different services they've dozens and dozens of services up there and there's several storage ones and since if you're injecting these secrets at runtime you don't want to be the bottleneck for retrieving these secrets so dynamodb has very low latency so that's why we ended up going with them for our storage solution uh we also have a couple here that are what was the most challenging problem he had to deal with for the project and kind of how we had to deal with it as a team um there's a lot of i guess trying to figure out the way we're gonna handle encryption with uh aws and also all these services um just figure out what services to use so there was a i guess a lot of research looking into that and i mean a lot of the project was just a lot of research before you kind of start um coding it up and prototyping and just you know like i mentioned before there's dozens of aws services so looking through and going okay we can use this one for this but what trade-offs come with that and sort of just figuring out how to put all these together in a cohesive unit well i don't see any more coming on through here so uh thank you again for coming out to our presentation and a good rest of your day thank you 