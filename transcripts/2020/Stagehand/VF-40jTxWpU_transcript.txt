hey everyone thanks for joining us for our presentation today we are stay chan my name is cody along with daniel and emil we're happy to show our project with you today um so stagehand makes getting to production as painless as possible um staychan is a drop-in solution that provides review apps for modern front-end applications and we'll explain uh everything we mean by that as we go along general overview of what we will be talking about today we'll look at what review apps are as long as as well as their value some existing solutions for review apps we'll look at stagehand and where it fits in and how we built it along with some challenges we faced along the way and some future work we hope to get to um before we dive in let's into what review apps actually are let's look real quick at where they generally fit in within the various environments of a production application so any code changes to an application like with adding a new feature occur in a development environment like on a devs local machine and then once those are complete the changes are moved to a testing environment usually which is optimized for testing specific requirements and then prior to going live the changes are typically moved to a staging environment which is supposed to match the production environment as closely as possible for any final checks and then finally the code is pushed to the production environment itself to go live review apps generally fall under the same category as staging environments which we'll look into now so what are staging environments tommy mcclung says the staging environment sometimes also called a pre-production environment is the environment where your code is staged prior to being run in front of users so that you can ensure that it works as designed a staging environment can be used for automated end-to-end testing quality assurance teams and even for product managers and other stakeholders to be able to validate that new features and functionality work as they're supposed to so let's look at an example of this let's say you're a developer working on a front-end application the product manager wants a responsive navigation bar added to the application and you're assigned this task after coding up and testing your new navbar feature you deploy the changes to a staging environment and here the product manager and other stakeholders can view your changes in this production lock environment they can play around with the new feature like your navbar making sure that it's what they want and that everything works properly and then once approved your new navbar feature can go live into production but what if you're part of a dev team that's assigned a wide variety of features so now you alice and bob are all working on different parts of the front end app at the same time you're working on the navigation bar while bob works on the page content and alex works on the foot or alice works on the footer all these features will have to be deployed to a shared staging environment where your changes can be verified by the product manager and other stakeholders before they can go to production but because this environment is shared between all the devs maybe you and alice will have to wait until bob's done using it and furthermore you and alice may have to clean up that staging environment or make some changes to your own code if there are now conflicts with bob's code after he's finished this type of bottleneck is in the development cycle is one of the many scenarios in which review apps are incredibly helpful so what actually are review apps review apps are ephemeral fully functional versions of a production application that can be easily deployed and shared with others by ephemeral we mean that review apps are temporary environments that can be automatically torn down at any time fully functional means that review apps have end-to-end production-like functionality easily deployed means that review apps can be instantly built and deployed whenever there is a change in the applications code and then review apps are self-contained in that they exist in oscillation from the main production application so let's revisit our dev team with review apps each developer now has their own isolated environment where they can easily deploy and share their new feature now you and your team no longer have to fight over that shared staging environment just to be able to do something as simple as deploy and share your new features for others to check out each review app can be accessed even by non-technical stakeholders via a unique url that you can share with them this also enables greater collaboration even within your dev team itself as you can now quickly show each other your work without having to pull down and run each other's code locally so no more fighting over that shared staging environment just to quickly deploy test and share your new features as they're being developed so let's zoom in and see what review apps actually look like in action so here on the left you have opened a pull request for your new navigation bar feature on the github repository this triggers a review app to be automatically built and deployed and a shareable url uh to be posted so now you can easily check out your work yourself as well as share it with others like the product manager as seen here or the rest of your team so the product manager wants you to move the navigation bar to the other side of the page when you make this change with a new commit to the pull request a whole new review app with this change is automatically deployed with a new url in this new review app exists at the exact same time as the previous review app allowing them both to be viewed at the same time and even compared side by side so you share this new version with the product manager who after comparing the two versions in the review app sadbassad is now happy with your latest change and now you can merge a new feature code with the main application where it can be promoted to production and then after your code is merged and your pull request is closed both of these review apps will be automatically torn down for you as they're no longer needed freeing up resources so why front-end review apps review apps are an incredibly helpful tool for developers of all types of applications but their benefits are particularly helpful for developers of front-end applications why is this so first because front-end apps deal heavily with end-user experience more visual testing and verification in a deployed environment is needed second review apps are more lightweight so they don't need to spin up as much infrastructure and resources as a full stack app third because front-end apps are decoupled from data level concerns front-end review apps mimic the final production environment much more closely than a full stack application and then finally because the functionality of review apps are more user or consumer facing there may be need for more sharing of new features and functionality with non-technical stakeholders so review apps fit all of these front-end applications needs extremely well so now let's look at what exactly we mean when we say front-end applications in order to understand what we mean by front-end applications it'll be helpful to contrast it with a full stack web app so here we have a conventional three-tier web app architecture first a request comes in from the client and then second all the assets for our app are built once that request is received third the response is then served back to the client in the form of html css and javascript so the key thing to remember here is that the assets for our app are built at the time the request actually comes in from the user with the front-end application things work in the opposite direction uh first when a change is made to the code or content of the app that's when all the assets for it are actually generated and then those pre-bill assets are pushed to a content delivery network or cdn for hosting so when a user makes a request they are instantly served the latest pre-built assets for the cdn so when we say that stagehand is for front-end applications we mean that that it's applications that can be pre-built and instantly served from a cdn like this and we also support a more dynamic type of front-end application so here's a front-end application that works just like the one in the previous slide in step one there at the top the pre-built assets for our front-end application are instantly served to the client from a cdn but some front-end applications like single-page applications and jam stack applications have some more complex client-side javascript that gets served back this means that after the client receives the response from the cdn data can then be fetched from the client from an external api via that client-side code so this allows modern front-end applications built like this to have more dynamic functionality similar to a full stack app stagehand also supports review apps for this dynamic top front-end application now let's look at some existing solutions that provide review apps for developers there are generally two types of review app solutions one is reviews as a feature and the other reviews as a service reviews as a feature offers review app functionality as part of a larger hosting service like netlafly for cell and heroku and then reviews as a service exists only man only for managing and hosting your review apps and examples include feature peak release and tugboat let's look at some trade-offs with these two types of review app solutions neither of these are fully open source so you don't actually control the infrastructure or code used to manage your review apps both are convenient options as they automate um review apps for you and because your views as a service specializes in review apps uh they're tech it's typically a more flexible solution for a multitude of needs and you're not tied to a larger hosting service like netapp flaw both solutions host your review apps for you and both are feature-rich right out of the box but what if we don't want a hosted solution what if we want the extensibility and control of an open source solution one option is to do it yourself to manually develop a solution for um deploying and managing your review apps yourself in a self-hosted way you'll have to provision and configure a rather large number of resources so you'll need a cloud storage solution to store all the assets for each of your review apps you'll have to provision and configure a cdn service for hosting you'll need to write and deploy serverless functions for processing needs such as routing and then you'll need to provision and configure a build server to automate the building deploying and tearing down of your review apps as well as any interaction with your code repository on github and then finally you'll need some services to secure your review apps according to your needs so let's revis revisit the trade-offs table and include the do-it-yourself approach do-it-yourself gives us all the benefits of open source but it can now as we last saw be very labor and resource intensive to set up and a bit of a headache it's flexible as we're not tied to a larger service and we can now self-host our own review apps ourselves but we don't have a lot of features out of the box so we'll have to develop any that we want ourselves but what if there was a non-hosted open source framework that doesn't require all the work of the do-it-yourself approach this is where stagehand fits in stagehand gives you the same trade-offs as the do-it-yourself approach but we automate this whole process for you stay chain is fully open source we conveniently automate all the infrastructure you need for your review apps we're flexible and that we're not tied to a larger hosting service we allow you to self-host all your review apps on your own infrastructure and like the do-it-yourself approach we're not feature-rich right out the box so now let's dive in and see how stagehand works and how we built it and daniel's going to walk us through that thank you cody so stagehead gives you review apps for any frontend application that can be pre-built and served from a cdn so we're including frameworks such as react gatsby hugo next and so on once stagehand is installed you only need one command to set up your repository with it after you push your code to github each pull request and any additional commit you make will automatically create a review app for you it's that simple we'll show you what it looks like in action after your repository is already set up so first a pull request on the stagehand demo branch is created this will trigger a review app to be created and a shareable url will be posted to the comments section this review app has the stagehead dashboard logo on top and it's open with the stagehand logo in the top left-hand corner it will display a banner giving some context information about the review app and reminding you that you're not looking at the production environment after a commit is made off-screen on the same branch this will trigger yet another review app to be created reflecting those new changes a new url is posted and now you can have multiple review apps to share and compare so stagehand is made up of three parts with a command line interface to pull it all together we combine aws cloud infrastructure github actions and client-side code while this is a lot to throw at you all at once we're going to keep this pretty high level right now and then focus on each piece as we progress through the presentation so first we'll show you how stagehand deploys review apps on aws cloud services then we'll walk you through how stagehand automates the deployment and management of the review apps with github actions and finally we'll go through some client-side code we use to handle routing and to create a dashboard for users review apps so the first piece we'll go over it says aws components we pick aws due to its popularity especially among individual developers so there's two flows of our aws components if you look on the left when a user makes a request to retrieve a review app asset and if you look at the top when a review app is being created or torn down we're going to zoom into each of these pieces and walk you through what they are in more detail next so the s3 bucket is our storage solution you can think of it as a database for files this is where we store each of the review apps in its entirety and to distinguish review apps from one another we use the current branch name and the current commit identifier as its path cloudfront is our cdn or hosting solution so all http requests coming into our infrastructure will first hit cloudfront which will forward it to the s3 bucket to retrieve the correct asset cloudfront also handles securing requests to the bucket and provides us with an out of the box domain to use the last infrastructure piece to add is identity and access management or iam this enables us to tightly secure the access to cloudfront and s3 bucket it also ensures that the credentials can't access anything else in the aws account where all this infrastructure is located the last step is how to deploy our aws infrastructure so we use cloud formation to take care of this it allows us to use a template with listed resources configurations and outputs and it'll spin up all the infrastructure we need and we didn't need to customize each aws stack to each stagehand app so a template was a perfect approach we could then use the outputs to automate aspects of setup later for a smoother user experience another bonus of having all your resources grouped together is not only that you can tear spin it up easy but you can also tear it down easily so we've seen how aws helps us serve the review apps now let's look at how those review apps are managed with github actions so we're going to talk about why we use github actions and what it exactly is and then we'll walk you through one of our workflows and to understand why github actions exist let's talk about a very common scenario for a github user you want to build your gatsby application every time a commit to your code base is made and for those who don't know what gatsby is all you really need to know is that it's a framework to build front-end applications so to make this happen what would you have to do the repository itself can't run code we need some place for the gatsby build to be executed we can solve this by having a server somewhere which will receive a notification from github letting us know when to start the build process then we'd have to pull down the code from the repository onto the server and then run the build command github noticed that this was an incredibly common flow of events that people would do so they wanted to devise a way for you to run code directly within your repository eliminating the need to spin up or configure your own server so this is what inspired github actions you now have a way to run code within the context of your repository so github provides each repository with its own server so that you could run code on it in response to github events and if you recall the events we're concerned about pull requests and commits are repository level events so github actions is perfect for our use case we can leverage the server github provides to build our review apps as a user of stagehand you don't even need to be aware of what github actions are or how to use them we handle setting it up entirely for you so now that we know the use case for github actions there's one final piece to explain how does our repository know that we want to run an application build on every commit the workflow file is the only piece of information we need to provide github in this file we'll have all the configuration and the logic of running the application build these workflow files must be located within your github repository and a single repository can have many workflow files so we're going to shift back to the context of stagehand walking through what github actions does when a pull request occurs on a stagehand app so starting off the process first the pull request is created in your repository this creates a pull request event github will see that the create review app workflow file inside your repository is listening to when pull requests open this will trigger the workflow to begin github will then read the workflow file and provision a server for you set up with all the appropriate environment credentials the final step is where all the meat of the logic happens the github server will execute the contents of the create review app workflow and this in turn will build the review app copy that bill to the s3 bucket and publish a comment containing the url of the review app and that's all asides from the create review app workflow we also have one for teardown so now we have a better understanding of how github actions manages the review apps let's take a look at the client next so in this section we'll explore how stagehand client uses an iframe to give us a dashboard and use a service worker to handle routing after that we'll take a walkthrough of how we get from the dashboard to the review app so there's two fundamental pieces to our client side code the stagehand html file which includes an iframe and the javascript file which includes which installs a service worker while you may not be familiar with either these two pieces yet we're going to walk through what each of them provides for us so the the stagehand html file provides a scaffolding of a dashboard the stagehand dashboard visually sits on top of the review app to give extra context to the viewer of the review app and reminding them that they're looking at a review app and not production while the information that our dashboard gives at the moment is a banner this setup allows the user of stagehand to easily build out a custom dashboard to do and say whatever they want how do we get this overlay on the review app though we use an iframe and the iframe represents a nested browsing context embedding another html page into the current one so you could just think of it as a web page within a web page it's just a simple html tag so if you look at the image on the right while we separate the main window from the iframe visually here you can style the iframe so that it can be indistinguishable from the main window so next we'll dive into what a service worker is and how we can use it to handle routing so we could have an entire presentation about the power of a service worker so we're going to try to contain the scope of what's important for you to know to understand how we're using them so they essentially act as a proxy server that sits between the web application the browser and the network so a service worker is a browser feature it is not infrastructure it is code that runs inside your browser and once it's registered to a domain it intercepts all the requests going in and out of that domain and the service worker is able to alter both the request and the response so in our case we're going to intercept the http requests there's two important takeaways here thinking of them as an in-browser proxy and they are able to send and receive messages from the browser but before we start walking through what the client request cycle looks like we're going to visit the re the github server so on top of adding the review app to the correct location in the s3 bucket we're also adding the appropriate stage client files with them at the same time so each review app will have its own version of the saging client files and now the browser is ready to fetch the stagehand html file the html file will provide the scaffolding for the dashboard and the review app it will render both the dashboard and the iframe that will later house the review app and to populate the iframe we need to first grab the service worker and the javascript file that will register the service worker and here we receive the javascript file and then the service worker file and the service worker will begin installation remember a service worker is code run in the browser not cloud infrastructure and it intercepts events coming in and out of the browser so after the service worker is installed all http requests coming out of the iframe will be intercepted by the service worker the service worker will make sure it has the correct path to the correct review app and then forward the request to cloudfront this gives us a one-size-fits-all approach to managing the routing and this occurs for not only html pages but all other assets like css and javascript the service worker will then forward the response to the iframe so the review app will be populated with all the assets it needs now that we've walked you through all the pieces that make up our architecture we can take another look at what this all looks like together so github actions automates the management of the review apps aws handles storing securing and retrieving the assets and the client handles the dashboard and routing emma will take over and walk you through how stagehand cli is used next thank you daniel so now that we understand how stagen is built we can discuss how it works from a user perspective we provide a straightforward cli tool to the user to manage their stage end apps it's a node npm package so setup is just one command in the cli npm install dash g stage hand dash framework so the init command forms the meet of our command line tool you use it by navigating to the root directory of a project you want to use stage and on and then when you run the command a list of easy to use prompts are provided app configuration details are obtained then various local files are added such as the github directory which is provided to all github projects and that is populated with our github actions workflows a dodge station directory is also created or updated in the user's home directory and it holds persistent information about the local staging apps the user has access to uh this command also runs the aws cloud formation template to provision all necessary aws infrastructure the process also automatically adds required secrets to the user's repo via the github api so all in all this process makes sending up review apps as simple as running this command and waiting for the process to finish before continuing with the normal developable workflow like commits and pull requests the list command is used to list all stage and apps you have access to so once these are displayed you can select a single app and view all available review apps then as the gif shows you can select a single review app from the terminal to automatically open in the browser this allows you to interact with the review apps without having to navigate to github.com and look at the poll requests the add and access command work together to alter and view access control they allow collaboration between users on different devices who want to use the same stage end app the destroy command is opposite of the init command it's run in the root of an existing stagehand application it removes all related local files such as the workflow files in the github directory it also removes references to this app inside the dodge station directory so this app won't show up when running other commands like stage analyst and last but definitely not least this command tears down the aws infrastructure so now we know how stagen was created and how it can be used we'll delve into some of the specific technical challenges involved in its creation remember that our final architecture used a service worker on the client side code to handle routing and a iframe was used to add a dashboard as well while this is our final approach our original solution look quite a bit different we will be covering this original solution in our upcoming section in order to understand the routing problem a certain amount historical context is needed so let's just say you're a google engineer and you've been given the task to create a maps app when the app is coded up and then its assets are built it has no awareness of where it's going to be hosted or what its domain will be because of this the app is coded using relative paths which are shown above like routes slash routes settings etc so what are relative paths relative paths assume the domain to be used is the same as the current domain therefore relative paths only specify how to get the new asset relative to the current files location so if you're hosting the maps app at google.com all of its assets will be relative to that domain thus slash routes which the router link will navigate to google.com routes because throughout the password used are used when navigating within an app this means application code is unaware that it's actually hosted at google.com however there's already an app being served from google.com so we can't use that so we want to serve our entire maps app from the slash maps path unfortunately the application code will not be aware of this change and it will look for the asset in the wrong place as you can see in the image this results in a four or four across all relative assets instead of going to a google.com maps routes we're going to google.com routes how do we ensure that all of our requests from the maps app goes to the correct location the traditional way to handle it is that a web server will take all requests coming from google.com and figure out which application to forward it to this way only the web server needs to know which path belongs to which app so now that all of our application requests are b are going to the correct location as shown above but how do we solve this if you don't have a web server for example what if all of our assets are hosted on cdn content delivery network we need a way to intercept the request response cycle and make sure it's going to the correct place so there are two ways we can solve this there's the infrastructure interception solution which involves adding serverless functions to our cdn or there's a browser interception solution which uses a service worker on our client-side code so to understand how all of this relative writing stuff relates to chain let's recall that each review app had a branch name and a commit identifier so these two pieces are referred to as the base pad the base path in the s3 bucket corresponds to the start of the url path in the browser each of the review apps for a single stage and app are hosted at a unique base path under the same cloudfront url so if you look at the browser image on the left you can see one cloudfront url one two four five dot cloudfront.net which corresponds to a single staging app on the bottom right you can see different base paths which correspond to different review apps within that single domain right that single cloudfront url this is similar to a google maps example earlier where we wanted multiple apps hosted under google.com within different paths so why does this all matter for stagehand specifically the major problem we then need to handle in stagehand is how would we add a base pad to our site so relative links work within a review app that is nested under a specific base path we expect to happen is on the top right right we expect the relative link so clicking slash about to uh take us to test slash one two five one two slash about right so that's uh you expect the relative link to automatically add the base path after the domain and before the relative path is clicked however we don't have a web server that can automatically intercept every request to cloudfront and manipulate it to add the basepad so what actually occurs is on the image at the bottom right the relative path is added to the domain without a base path and in four or four curse books that item doesn't exist so in order to solve this we initially used the infrastructure interception solution so our infrastructure introduced lambda edge functions to intercept the requests coming in to ensure that the relative paths were going to the correct location basis lambda functions are serverless functions used to run code without having to provision a full server like an aws ec2 instance they're event based and their code will execute in response to a trigger this means we can run code in response to certain cloud for events such as an incoming request and request to the s3 bucket the next slide will go into more detail about how we use slam dust processing here we have lambdas that trigger for both the cloudfront request and an s3 bucket request that will enable us to do any extra processing that is needed to ensure the requests are all routed to the correct asset so note that this is our first solution not not not the final architecture unfortunately we found the solution to be incredibly limiting it required more user configuration a lot of build time changes and also limited the number of frameworks we could support with the solution because of this we went with a browser interception solution that used frame service workers all right so let's quickly review stageheng's actual solution so initially stage and html is requested and that returns the dashboard and the iframe which will later contain the review app then a service worker is requested and installed thus any requests from the iframe for the review app will be intercepted by the service worker to ensure the base path is always added as the image shows here we're handling routing on the client side without having any additional infrastructure involved so now that we saw the ralph routing issue with client-side code there's another issue that comes up what happens once the relative link is clicked well the iframe content will update so that's good but the url in the main page will not change that's because um it's not the content that's changing it's the iframe url that's actually changing unfortunately the url the user can only see the main window url so we need to update the main window so that it matches the page that the review app is on so note that in order to make this update we're going to need to use url fragments as shown on the right otherwise the main window when its url changes will automatically make a new http request so our first attempt to fix this was to use the post message api and the broadcast channel api both of these apis were tricky to get the messages to the right client especially when we had multiple review apps and they also had some cross browser support issues so as a result we needed another solution decided to have the main window continuously pull the iframe to see if the path had been updated if the path had been updated we update the main window accordingly so this basically used the iframe location as a source of truth so now that we've covered some technical challenges involved with creation of station let's reiterate what exactly stagen does for its users so we started off our journey by showing you what review apps are and the value they can bring to a development team and we ended up giving you the power to turn your own front-end application into the best production it can be so allowing you to self-host review apps without worrying about a thing before we wrap up we have a couple of things on the horizon we'd like to add to stagehand so we'd like to develop dashboard templates for specific use cases we'd also like to implement our solution across non-aws cloud providers and we'd like to provide an option for using a self-hosted github runner so a unique vps like an ec2 instance instead of using github's default servers and last but definitely not at least we'd like to create an automated test suite thank you for watching and this is us if you have any questions now uh please let us know in the chat or the q a all right so here's a question from gabe in the chat he says what did you guys find to be the most difficult aspect of this project um i would say probably handling that relative paths issue um it seems like when you get your head around it it's a pretty simple problem like all we need to do is add in that bass path right but when we don't have a web server like we went through um it was it was really challenging to figure that out so getting to the service worker solution as a general one-size-fits-all was really challenging so i would say that so we got another question from ezra what's the cost of running stagehand on aws uh that's obviously going to vary depending on the size of the application and how many review apps you have open for us we did an enormous amount of testing on this and i'm pretty sure our bill didn't even exceed a couple cents um but you definitely haven't got any emails either so as long as your app is and doesn't have thousands of review apps you should probably be fine cost wise um we have another question from oscar romero uh so i had a question regarding access so if a pull request or review request uh create a link can anybody open the link that stagehang created or only the initiator of the poll slash review see it through github and any other valid github login work um so anybody can view these links um because these are front-end applications we didn't see like we're not dealing with any production data so there it wasn't too high of a concern uh to kind of uh protect people from seeing the links um here's one from arthur he says what's the most interesting thing you learn while doing this project um i think it's different from all of us like i think it was just interesting to learn the technologies we use to learn about you know the different aws services and to pick which ones were best for a use case uh github actions is a brand new thing that's incredibly helpful and then um yeah and then service workers as a whole world into itself where we didn't even scratch the surface of the power there so i would just say all the technologies we learn yeah i think uh after discovering about service workers and like looking into it i kind of fell in love with them so i definitely want to look a lot more into them about the different aspects that we didn't quite get into in this presentation and in our project so gabe had a question of how long does the initial deployment of station enable this take from the init command to be able to click on a link and see the app so regarding the uh running the init command the primary i guess blocker if you want to call it would be setting up the aws infrastructure specifically the cloudfront cdn so some of that is going to depend on a database's efficiency but generally um like a few minutes uh in some cases and sometimes it might take a little bit longer now regarding creating a review app again that's going to depend on how long the build takes so if you have like thousands upon thousands of files to build obviously that'll take a lot longer and if you have if you're using a framework that's known to be slow versus a framework that known to be fast it's also gonna play into it again for smaller apps like the ones we demoed we're talking minutes usually as long as nothing goes wrong uh yeah um here's one from rodney he says can you briefly go into more detail about the process of setting up the cli portion and what you had to consider um so the clr because because the whole process starts on the user's local uh repo we want to automate as much of the process as possible from right there so that meant getting their aws credentials um being able to sync and not have to have the user manually go in and add the plethora of github secrets that they're going to need for their review apps um so it was just automating that whole process feel like finding the balance between what's too much to ask from a user and how much we can automate for them we ended up automating quite a bit um and we also made the decision not to go at least right now with like a you know a huge um graphical like dashboard to look at review apps because because you're working in the context of pull requests on github you already have that uh graphical interface there so that the cli can just just handle any of that on the client side for you so to kind of uh add on to that the only things we really needed from like a stagehand user to know how to spin up their stagehand app was the the commands that you used to build your application and then we also needed to know how your your the certain framework that you're using uh builds its assets so there's some like little uh quirks that some frameworks have so we just kind of separated into like two different categories of uh routing so gabe says what was your guy's experience of working with aws did you all find it easy were you able to pick it up quickly the aws infrastructure that we kind of finished off with was probably the easiest part of uh the aws that we used uh we went over kind of briefly how our first iteration used lam does and lambdas are probably the hardest thing to work with and to debug so after we gave up our we found a different solution that didn't use lambdas uh it was a lot more straightforward i don't know if uh cody or ammo has anything to add to that yeah regarding the aws infrastructure that definitely checks out with me um also like once i figured out how to use the documentation a little bit better so like initially it was a little bit tough since i had to figure out where things were but once i figured that out in the general structure of how a database likes to do things uh it was easier to pick stuff up yeah same it's uh aws is really well documented and powerful it's i think the most challenging part was figuring out what services of aws to use for our use case but once we did it was really easy to learn and pick up uh rodney asks how long did it take to build oh wait you got this daniel good oh um so i think the majority of the time we kind of spent on this whole process was in researching the project it took us a while to find what exactly we wanted to do uh we were we were kind of puttering around different kind of like front-end uh framework tools so we were looking at static site generators and we were looking at jam stack applications but in terms of once we actually like sat down we knew what we were doing and we started to build it probably took like i don't know like four weeks something like that three four weeks yeah the prototype came pretty fast but getting everything really polished up and working and expanding you know what all types of front-end applications that we support uh took a little time after that so it looks like azar is asking is cjn available on github yes it is and uh sooner write-up will be as well which i'm sure we can share in slack or something once it's ready yeah and the npm package is ready to go as well if you want to try it out on your own repositories yeah it's called a stagehand dash framework so ram maybe i missed it but what else could service worker be used for uh so you didn't miss it we didn't really want to like go into the weeds of what service workers could be used for because they're kind of a confusing concept but the thing that they're used primarily for is something called uh progressive web application so basically uh i don't remember the there's like a list of six or seven different things that like a lot of progressive web applications have as like traits but um but one of like the most important things that it can be used offline so it uses a couple different browser apis like a like a cache and a database so if you're offline let's say you're you're working on something like like google docs and your google docs goes offline all the changes that you're typing in aren't going anywhere to the google database but instead they're just getting saved in the browser and then once you go online that all that information that was saved in the browser by the service worker will then be sent to the google database to update the the uh the google sheets uh we just have one final question from edmund tam uh they're asking would it be possible to extend this to back end instead of just front end so a couple of the different services that we went over a lot earlier in the presentation release apps was one of them and they do like a full stack of a full stack review app it would kind of be hard to adjust stagehand to that at that mo at the moment it would involve like a lot more work which is why we kind of contained the scope of just using front end applications and also it's harder with full stack applications if it's rely on like a lot of data too for review apps to mimic a production environment with a full stack up versus a versus a front-end application yeah i'll just add related to that if you want to like try this out for a full stack i think heroku has something similar called heroku review apps and i know in the core you use roku i believe for 170. so you could try something like that um here's one from rodney um can you tell us about how it was working as a team and what you would say is something each of you would consider and how your experience was so i guess that's for all of us um it's it was it was a lot of fun working with these guys i think um we uh i think we worked really well together it's when you're on a team and you're remote and sometimes your schedules don't sync up like that can be a challenge at first but i think we overcame all that and we were able to really put in the work and um yeah collaborate well yeah it was it was great working with these two um it's nice that because i think everybody goes into the process with their own strengths and weaknesses so it's nice that you have a balance of that so it's sometimes when you're kind of like lacking in one department somebody else picks up the slack which is always uh nice to nice to have um what i would kind of uh what i would recommend uh like going into into capstone is communicate like a lot like over communicate everything just to make sure everybody's on the same page and uh like during this whole process take lots of notes so uh justin asks what happens to links generated when a pull request is submitted but never merged to main so if you leave the pull request just open the link will just remain there and the review apps will remain up now if you either so when you merge a request in to main or you close it right they both involve closing it so right so the close event for a pull request is triggered and that will cause all the review apps in that um so all the links and that will basically uh go down right all the review apps related to that will be torn down by the workflow uh so yeah if you don't close it at all then it'll just remain up yeah in which case you would have to use rcla to actually manually get rid of those review apps if you want to do that while leaving the pull request open for whatever reason thanks everybody for coming out and watching our presentation and for all the great questions and take care thanks guys thanks 