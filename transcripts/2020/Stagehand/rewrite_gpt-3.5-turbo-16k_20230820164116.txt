Welcome everyone to our presentation. We are Stachan, consisting of Cody, Daniel, and Emil. Today, we are excited to showcase our project, Stagehand. 

Stagehand aims to simplify the process of getting applications to production by providing review apps for modern front-end applications. In this presentation, we will provide a general overview of what review apps are, discuss existing solutions, explain how Stagehand fits in, detail the development process and challenges, and outline future work. 

Let's start by understanding what review apps actually are and where they fit in the development cycle. When making changes to an application, such as adding a new feature, the process usually involves development, testing, staging, and finally, deploying to production. Review apps fall under the staging environment category, which is used to ensure that code works as designed before going live. 

Imagine you are a developer working on a front-end application, and the product manager wants a responsive navigation bar added. After coding and testing your new feature, you deploy the changes to a staging environment for review. In this environment, stakeholders can interact with the new feature and validate its functionality. Once approved, the feature can go live. 

However, when multiple developers are working on different parts of the application simultaneously, a bottleneck can occur. Review apps address this issue by providing ephemeral and fully functional versions of the application. Each developer has their own isolated environment to deploy and share their changes without conflicts or delays caused by a shared staging environment. Review apps can be easily accessed and shared with non-technical stakeholders, promoting collaboration within the team. 

Now, let's take a closer look at how review apps work. When a developer opens a pull request for a new feature on the GitHub repository, Stagehand automatically builds and deploys a review app. This app is available through a unique URL, which can be shared with stakeholders for review. Subsequent commits trigger the creation of new review apps, allowing multiple versions to be compared side by side. Once a feature is approved and merged, the review apps associated with it are automatically removed to free up resources. 

Review apps are particularly useful for front-end applications as they focus on end-user experience and visual testing. They are lightweight, closely mimic the production environment, and facilitate sharing of new features with non-technical stakeholders. 

Now that we have an understanding of review apps, let's explore existing solutions. There are two types: reviews as a feature and reviews as a service. Reviews as a feature integrates review app functionality into a larger hosting service, while reviews as a service specifically focuses on managing and hosting review apps. Examples of each type include Netlify, Heroku, FeaturePeek, and Tugboat. 

Both types of solutions offer convenience and automation for review apps, but they lack full control and extensibility as infrastructure and code are not in your hands. To address this, one can opt for a do-it-yourself approach, manually developing a solution for deploying and managing review apps. This involves provisioning and configuring various resources such as cloud storage, CDN, serverless functions, build servers, and security measures. While this approach provides complete control, it can be labor-intensive and time-consuming. 

Here is where Stagehand comes in. Stagehand provides the same level of control and flexibility as the do-it-yourself approach, but with the convenience of automation. It is an open-source framework that automates the setup of infrastructure needed for review apps. With Stagehand, you can self-host your review apps on your own infrastructure. While Stagehand may not have as many features out of the box as the hosted solutions, it allows for customization and development of additional features. 

Now, let's explore how Stagehand works and how we built it. Stagehand consists of three main components: AWS services, GitHub Actions, and client-side code. AWS services are used to host and serve the review app assets. GitHub Actions automate the deployment and management of review apps, while client-side code handles routing and creates a dashboard for users. 

To provide review apps on AWS, we leverage various components. When a user requests a review app asset, it is fetched from AWS S3, where the assets are stored. This reduces the load on the main application and ensures quick delivery of review apps. 

Now, let's dive into the deployment and management of review apps using GitHub Actions. After installing Stagehand, setting up your repository is as simple as running a single command. Whenever code is pushed to GitHub or a pull request is created, a review app is automatically generated. This seamless integration streamlines the review process and allows for easy collaboration. 

Lastly, let's discuss the client-side code that handles routing and creates a dashboard for users. The Stagehand dashboard displays the review app logo and provides essential information about the review app being viewed. It also reminds users that they are not in the production environment. With Stagehand, multiple review apps can be created and shared, enabling efficient reviewing and comparison. 

In conclusion, Stagehand offers a comprehensive solution for managing review apps in front-end applications. It combines the benefits of open-source flexibility and control with the convenience of automation. By automating infrastructure deployment and streamlining the review process, Stagehand simplifies the journey from development to production. In the future, we aim to further enhance Stagehand by adding additional features and improving its extensibility. Thank you for joining us today, and we hope you find Stagehand valuable for your front-end development projects. Stagehand is an open-source framework that automates the process of setting up review apps for any frontend application. Unlike a do-it-yourself approach, Stagehand eliminates the need for manual work by offering a fully automated solution. It is a flexible and self-hosted alternative, allowing users to host their review apps on their own infrastructure. However, it is important to note that Stagehand is not feature-rich out of the box and requires additional configuration.

To understand how Stagehand works and how it was built, we will now dive into the details. Daniel will guide us through this process. 

Stagehand is designed to provide review apps for frontend applications that can be pre-built and served from a CDN. Frameworks such as React, Gatsby, Hugo, and Next are supported. Installing Stagehand is a simple process, requiring just one command to set up the repository. After pushing the code to GitHub, each pull request and subsequent commit triggers the automatic creation of a review app. 

Let's look at a demonstration of how this works on an already set-up repository. First, a pull request is created on the Stagehand demo branch. This triggers the creation of a review app, and a shareable URL is posted in the comments section. The review app interface displays the Stagehand logo and a banner providing context information about the review app and reminding users that it is not the production environment. After a commit is made on the same branch, another review app is created reflecting the new changes, and a new URL is posted. This allows users to have multiple review apps for sharing and comparison.

Stagehand is composed of three main parts, which are integrated using a command-line interface. AWS cloud infrastructure, GitHub actions, and client-side code are combined to create the framework. Let's now discuss each part in more detail.

In terms of AWS components, Stagehand utilizes S3 buckets as a storage solution. Each review app is stored as a file in the bucket, with the branch name and commit identifier used to distinguish between apps. CloudFront is used as a CDN and hosting solution, handling all incoming HTTP requests and forwarding them to the correct S3 bucket. Identity and Access Management (IAM) is used to secure access to the infrastructure. IAM ensures that the credentials used by Stagehand can only access the necessary resources in the AWS account.

To deploy the AWS infrastructure, Stagehand utilizes CloudFormation. This allows for easy setup and teardown of the infrastructure, as all the resources are defined in a template. The template ensures that each Stagehand app has its own set of resources, making customization and configuration easier.

Moving on to GitHub actions, they are used to automate the deployment and management of review apps. GitHub provides a server for each repository, allowing users to run code within the repository itself. This eliminates the need for an external server. Stagehand takes advantage of this feature by leveraging GitHub actions to build and deploy review apps automatically. Users do not need to have prior knowledge of GitHub actions, as Stagehand handles all the setup.

The workflow file is a crucial part of GitHub actions setup. It contains all the configuration and logic necessary for running the application build. When a pull request is created, GitHub detects the workflow file and proceeds to provision a server with the required environment credentials. The server then executes the workflow, building the review app, uploading it to the S3 bucket, and posting a comment with the review app URL.

In addition to the workflow for creating review apps, Stagehand also has a workflow for teardown. This ensures that resources are properly cleaned up when a review app is no longer needed.

The client-side code of Stagehand provides a dashboard using an iframe and routing through a service worker. The Stagehand HTML file serves as the scaffold for the dashboard, which visually overlays the review app. The iframe embeds the review app, giving it context and reminding users that they are viewing a review app rather than the production environment. The iframe can be styled to blend seamlessly with the main window.

A service worker, a browser feature, acts as a proxy server between the web application, the browser, and the network. It intercepts requests and responses, allowing Stagehand to handle routing efficiently. By intercepting HTTP requests within the iframe, the service worker ensures that the review app's assets are retrieved from the correct location in the S3 bucket, providing a uniform approach to routing.

With all the architectural components and their interactions explained, we can now visualize how Stagehand operates as a whole. GitHub actions handle the automated management of review apps. AWS infrastructure stores and secures the assets, while the client-side code provides the dashboard and routing. Combining these elements creates a seamless experience for managing review apps.

Stagehand also offers a command-line interface (CLI) for easy management of stage-end apps. The CLI is an npm package that can be installed with a single command. The "init" command is used to set up a project with Stagehand, prompting the user for app configuration details and automatically creating necessary files, such as GitHub actions workflows. The CLI also handles the provisioning of AWS infrastructure by using CloudFormation templates. Additionally, it automatically adds required secrets to the GitHub repository using GitHub's API. The "list" command displays all the stage-end apps associated with the user, allowing easy selection and opening of review apps directly from the terminal. The "add" and "access" commands enable collaboration and access control for multiple users. Finally, the "destroy" command allows for the teardown of stage-end apps.

In conclusion, Stagehand is an open-source framework that automates the process of setting up review apps for frontend applications. It offers the convenience of automation while being flexible and self-hosted. By combining AWS cloud infrastructure, GitHub actions, and client-side code, Stagehand provides a complete solution for managing review apps. The CLI simplifies the setup and management process, allowing users to focus on their development workflow. The architecture of our application involves intercepting all HTTP requests from the iframe using a service worker. Once intercepted, the service worker ensures that the requests are directed to the correct review app by forwarding them to CloudFront. This approach allows us to effectively manage routing for all types of assets, including HTML pages, CSS, and JavaScript. The service worker then sends the response back to the iframe, populating the review app with all the necessary assets.

To provide a user-friendly interface for managing their stage-end apps, we have developed a CLI tool called Stagehand CLI. This tool is a Node/npm package, and setup is as simple as running the command "npm install -g stagehand-framework". The CLI tool offers several commands to the user. The "init" command is the main command for setting up a project. It prompts the user for app configuration details and adds necessary files, such as the GitHub directory and GitHub Actions workflows. It also updates or creates the "dodgestation" directory in the user's home directory, which holds information about their local staging apps. Additionally, this command runs the AWS CloudFormation template to provision the required infrastructure on AWS. It automatically adds the required secrets to the user's repository via the GitHub API. Overall, this process simplifies setting up review apps by running a single command.

The "list" command is used to display all the stage-end apps the user has access to. Once displayed, the user can select a specific app and view all available review apps. They can then select a review app from the terminal and automatically open it in the browser, allowing them to interact with the app without needing to navigate to GitHub.com and search for pull requests. The "add" and "access" commands work together to modify and view access control for collaboration between users on different devices using the same stage-end app. The "destroy" command is the opposite of the "init" command. Running this command in the root of an existing stage-end application removes all related local files, such as the workflow files in the GitHub directory, and removes references to the app in the "dodgestation" directory. It also tears down the AWS infrastructure associated with the app.

Now, let's discuss some of the technical challenges we encountered during the creation of Stagehand. One such challenge was handling relative paths in the application's assets. When an app is built, it doesn't know where it will be hosted or its domain. Because of this, relative paths are used, which specify how to access the assets relative to the current file's location. However, when hosting the app under a specific base path, the application code looks for the assets in the wrong place, resulting in 404 errors. To solve this, we initially used the infrastructure interception solution, which involved adding serverless functions to our CDN. However, this solution had limitations, such as requiring more user configuration and restricting the supported frameworks. Therefore, we switched to a browser interception solution using service workers.

In our final solution, when a stage-end HTML page is requested, it returns the dashboard and an iframe that will contain the review app. A service worker is also requested and installed, intercepting any requests from the iframe for the review app. The service worker ensures that the base path is added to the requests, handling routing on the client-side without additional infrastructure. Another challenge we faced was updating the URL of the main window when a relative link is clicked within the iframe. To address this, we initially tried using the postMessage API and the broadcast channel API but encountered difficulties with message delivery and cross-browser support. Ultimately, we implemented a solution where the main window continuously checks the iframe's location for updates and updates its URL accordingly.

To summarize, Stagehand provides users with a simple CLI tool for managing their stage-end apps. It automates the setup process, handles access control, and allows users to interact with review apps directly from the terminal. We encountered challenges such as handling relative paths and updating the main window URL, which we addressed using service workers and continuous polling. In the future, we plan to develop dashboard templates for specific use cases, expand our solution to non-AWS cloud providers, provide an option for self-hosted GitHub runners, and create an automated test suite. Thank you for watching, and feel free to ask any questions in the chat or Q&A. We have developed dashboard templates for specific use cases and plan to implement our solution across non-AWS cloud providers. Additionally, we offer the option of using a self-hosted GitHub runner, such as an EC2 instance, instead of relying on GitHub's default servers. Lastly, we aim to create an automated test suite for our project.

Thank you for watching our presentation. If you have any questions, please let us know in the chat or Q&A section.

One viewer, Gabe, asks about the most challenging aspect of the project. We found that handling the issue of relative paths was particularly difficult. While adding the base path seems simple, it became a challenge when we didn't have a web server. Finding a generalized solution using service workers proved to be challenging.

Ezra inquires about the cost of running Stagehand on AWS. The cost varies depending on the size of the application and the number of review apps. However, based on our extensive testing, we found that our bill did not exceed a few cents. As long as the app isn't heavily reliant on thousands of review apps, the cost should be manageable.

Oscar Romero asks about access to the links created by Stagehand. Anyone with a valid GitHub login can open the links generated by Stagehand. Since these are front-end applications and don't involve production data, we didn't need to implement additional protections for viewing the links.

Arthur asks about the most interesting thing we learned during the project. Each team member found different aspects fascinating, such as learning about various AWS services for different use cases. GitHub Actions proved to be tremendously helpful, and delving into service workers opened up a whole new world of possibilities.

We received a question from Gabe about the duration of the initial deployment of Stagehand. The time required to set up Stagehand depends on the efficiency of the AWS infrastructure, particularly the CloudFront CDN. With a well-optimized database, the process typically takes just a few minutes. Creating review apps is also relatively quick unless there are substantial build requirements or dependencies, which might extend the time.

Rodney requests more details about the CLI setup process. Since the process starts on the user's local repository, we aimed to automate it as much as possible. This involved streamlining AWS credential management and synchronizing without users needing to manually add numerous GitHub secrets. We found a balance between automating tasks and not burdening users with excessive manual intervention. For the CLI design, we decided against creating a graphical dashboard and opted to utilize GitHub's existing interface for pull requests. The CLI efficiently handles these tasks on the client side.

To elaborate further, the only essential information we need from Stagehand users is the commands used to build their applications and how their chosen framework builds its assets. By categorizing the routing process, we simplified the setup for various frameworks.

Gabe asks about our experience working with AWS. The AWS infrastructure we integrated in the later stages of the project proved to be relatively straightforward. In the initial stages, we experimented with Lambdas, which were more challenging to work with and debug. Eventually, we found a different solution for AWS infrastructure that bypassed the need for Lambdas, making the development process much more manageable.

A question from Rodney asks about the duration of the project. The majority of the time was spent on research and deciding which direction to take. It took a few weeks to finalize the project and develop all the necessary features. While the initial prototype came together quickly, polishing and expanding the functionality, as well as accommodating different types of front-end applications, took additional time.

Azar asks about GitHub's availability for CDN. Yes, GitHub is available on CloudFront CDN, and we plan to share a write-up on this topic.

Working with service workers was a complete learning experience. They primarily power progressive web applications, enabling offline functionalities. By leveraging browser APIs like caching, service workers allow applications like Google Docs to work offline. Any changes made while offline are temporarily saved in the browser until an internet connection is available and the data can sync with the cloud database.

Edmund Tam wonders if Stagehand could be extended to include back-end functionalities. While there are services like Heroku's review apps that provide similar full-stack capabilities, it would require significant additional work to introduce full-stack support to Stagehand. Factors such as the complexity of mimicking a production environment and managing large volumes of data make this a more challenging endeavor.

Rodney asks about the team's experience working together and each member's takeaways. Overall, it was a great experience working as a team. We each brought unique strengths and weaknesses, allowing us to complement one another. Communication was key throughout the project, and note-taking played a significant role in ensuring everyone was on the same page.

Justin wants to know what happens to the links generated when a pull request is submitted but never merged into the main branch. If the pull request remains open, the link and associated review apps will continue to be accessible. However, once the pull request is merged into the main branch or closed, the review apps linked to it will be dismantled through the workflow.

We want to express our gratitude to everyone for attending our presentation and asking insightful questions. Thank you, and take care. During the coding Capstone project presentation, Justin raised a question about the fate of generated links when a pull request is submitted but not merged into the main branch. The answer is that if the pull request is left open, the associated link will remain active, as will the review apps. To clarify, when a pull request is merged into the main branch or closed, both actions result in effectively closing the pull request. Consequently, the close event triggers the removal of all related review apps and associated links. This means that if a pull request remains open indefinitely, the links and review apps will continue to be accessible. If you wish to remove these review apps manually while keeping the pull request open, you will need to use RCLA. 

The presenters express their gratitude to everyone for attending and watching the presentation, as well as for the insightful questions. They conclude by wishing everyone well and bidding farewell.