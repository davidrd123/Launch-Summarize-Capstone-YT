Welcome everyone! Thank you all for joining our presentation on Satellite, a GraphQL Backend as a Service. Satellite aims to simplify application development for front-end developers. In this presentation, we will discuss the architecture of a typical web application and then delve into the challenges of building a specific type of application. We will explain what a Backend as a Service entails and explore the architecture of a single Satellite deployment. Furthermore, we will demonstrate how to use Satellite. 

Applications can be divided into two main parts: the front-end and the back-end. The front-end is what users see and interact with, while the back-end handles the business logic and data required to support the front-end's functionality. In modern app development, it is common to separate the front-end from the back-end and establish a communication channel between them via an API. The back-end produces the API, and the front-end consumes it. This architecture enables front-end and back-end teams to work independently and facilitates the development of various front-end client apps that utilize the same back-end. 

An interesting case study for API development is Facebook's news feed API. When they decided to rewrite their native iOS app, they encountered challenges in reusing their existing API for the news feed feature. The backend was responsible only for returning data, while the front-end handled user interactions. However, Facebook's news feed involved complex interconnections, nesting, and recursion between stories, making it difficult to retrieve the required data efficiently. The existing APIs were designed for web browsers, returning HTML, rather than enabling a rich news feed experience on mobile. This resulted in numerous round trips to the API and excessive data transfers. Recognizing the need to improve mobile experience, Facebook developed a new API: GraphQL.

GraphQL was designed at Facebook with the goal of creating an ideal API for front-end developers. The key innovation of GraphQL is that it allows front-end clients to specify the exact information they need for a request, eliminating over-fetching and avoiding multiple round trips. This optimization significantly enhances network performance, which is crucial for mobile apps with limited bandwidth and the need for fast response times. Another noteworthy feature of GraphQL is its strongly typed system, which enables clients to use introspection to understand the capabilities of the API. This self-documenting aspect of GraphQL has contributed to its widespread adoption and the development of numerous client-side tools. Initially an internal tool at Facebook, GraphQL was released as an open-source project in 2015, gaining popularity among companies like Airbnb, Twitter, Netflix, and GitHub. 

Now, let's delve deeper into GraphQL. At a high level, GraphQL is a query language for APIs. More specifically, it is a specification that defines a type system and query language, and it can be implemented in any programming language. GraphQL servers, the server-side implementations of the GraphQL specification, receive requests as strings sent from clients over HTTP. The server parses the request into an abstract syntax tree, enabling programmable traversal. By walking this tree, the server determines how to respond to the request, allowing for a structured API interaction. The data available on the server is described using a type system, enabling clients to request precise information and receive only that which is required. 

Considering the complexity of building the back-end of a GraphQL application, it is essential to understand the basic setup of a back-end. Typically, back-ends follow a three-tier architecture. A web server acts as the entry point, serving static files and acting as a reverse proxy for dynamic data requests. The app server handles the application's business logic, processing and fulfilling requests for dynamic data. Lastly, there is a database for data persistence. 

To build a GraphQL API, one must implement a GraphQL server. The server is responsible for receiving and responding to GraphQL requests and consists of two main components: the schema and the resolvers. The schema declaratively defines the API's functionality, consisting of types and fields. On the other hand, resolvers are functions that instruct the server on how to respond to requests, such as fetching data from the database. The flexibility of resolvers allows developers to adapt to the specific needs of their underlying database. 

While the schema specifies what the API can do, the resolvers determine how it is accomplished. Query and mutation resolvers correspond to the types defined in the schema and provide the necessary logic for data access and manipulation. Together, the schema and resolvers form the foundation of a GraphQL API. 

Additionally, constructing a fully functional GraphQL backend requires consideration of various other components, such as standard backend features and configurations. This includes aspects like SSL, static front-end hosting, and database setup. The complexity of these tasks can be overwhelming, particularly for front-end developers who primarily focus on GraphQL functionality. To address this complexity, Backend as a Service (BaaS) solutions provide an abstraction layer over the standard backend components, along with pre-configured features accessible via an API. By treating the backend as a service, developers can primarily focus on the front-end without much concern for the implementation details of the backend.

There are two main categories of BaaS solutions: managed services and open-source products. Managed services offer extensive features and support, but they are proprietary and not always GraphQL-specific. Open-source options, such as Parse, provide more control and flexibility but can be challenging to set up and use. Recognizing a need, we developed Satellite, an easy-to-use, self-hosted, open-source BaaS solution specifically for GraphQL applications. Satellite emphasizes simplicity, allowing front-end developers to quickly build GraphQL-based applications without extensively worrying about the backend. While it may not suit every application due to its limited feature set, Satellite is ideal for developers who prioritize ease of setup and use. However, Satellite does not include built-in user authentication, although integration with external tools like Auth0 is still feasible.

Satellite primarily caters to development teams in need of a sandbox environment for front-end developers. Once deployed by a system administrator, Satellite provides front-end developers with easy access to create and utilize their back-ends within the Satellite deployment. Each back-end can host a different front-end application, fostering a seamless development environment.

In conclusion, Satellite serves as a GraphQL Backend as a Service, streamlining application development for front-end developers. By leveraging GraphQL's efficient communication between front-end and back-end, Satellite allows for rapid development without extensive backend implementation knowledge. Although it sacrifices some features for simplicity, Satellite provides an ideal solution for front-end developers seeking an easy-to-use BaaS solution. 

Thank you for your attention, and now we will proceed with a demo showcasing the usage of Satellite. Satellite is a GraphQL backend as a service that aims to address the need for a self-hosted open-source solution with simplicity and control. There are already many backend as a service options available, falling into two categories: managed services and open-source products. Managed services offer extensive features and support but can lead to vendor lock-in and may require extra setup for a GraphQL API. On the other hand, open-source options like Parse are not proprietary and offer flexibility, but can be complex to set up.

Satellite was developed as an easy-to-use self-hosted open-source GraphQL backend as a service. It prioritizes simplicity of setup and usage, with the understanding that other features can be integrated later if needed. While it does not include user authentication, integration with tools like Auth0 is possible.

Satellite is an ideal choice for developers who want to quickly build a GraphQL-based application without having to worry about complex backend management. It is particularly useful for development teams that require sandbox environments for front-end developers. By deploying Satellite and granting access to front-end developers, each developer can create and use their own back-end, allowing for multiple front-end applications to be hosted.

The core application of Satellite is made up of several components. An Nginx web server serves static files and routes incoming requests, while a Node.js Express application server allows for administrative actions on the Satellite instance. The Dgraph graph database is used as the data store.

Initially, the challenge was to build a generic GraphQL backend that would work for any application without prior knowledge of the specific data requirements. Traditionally, backends require a separate database schema in addition to the GraphQL schema. To simplify this process, Satellite aimed to generate a relational database schema from a GraphQL schema, eliminating the need for two separate schemas.

The next challenge was to access the data. GraphQL servers require resolver functions to handle requests. Satellite aimed to automatically generate resolver functions for common actions such as creating, reading, updating, and deleting data. This would simplify usage and eliminate the need for developers to edit the backend's code.

Satellite's architecture revolved around generating a complete backend based on the provided GraphQL schema. However, as the schema complexity increased, creating the necessary database schema and resolver functions became more challenging. To address this, alternative database options were considered.

Graph databases emerged as an ideal solution due to their specialization in handling interconnected data. Dgraph, in particular, was chosen for its native GraphQL integration, allowing for direct generation of resolvers from a GraphQL schema. With Dgraph as the database, the hypothetical architecture for Satellite simplified, requiring only the GraphQL schema to generate the GraphQL API.

Additional components were required to address the need for administrative endpoints and static file serving. An Nginx web server was used to serve static files and act as a reverse proxy to the GraphQL API endpoint of Dgraph. A Node.js application served as a private entry point for developers to perform administrative actions and upload static files.

To simplify deployment, Satellite adopted containerization using Docker. Containers package applications with their dependencies in an isolated and consistent manner, eliminating the need for manual installation and configuration. Docker containers were used to package each component of Satellite, making deployment easier and more efficient.

However, starting each container individually still posed a challenge. Docker Compose, a tool specifically designed for multi-container Docker applications, was chosen to address this issue. A Docker Compose configuration file was created to launch a single containerized Satellite instance, including options for environment variables and storage volumes.

Overall, Satellite was developed as a self-hosted open-source GraphQL backend as a service that prioritizes simplicity and control. It offers an easy-to-use solution for quickly building GraphQL-based applications, particularly for development teams that require sandbox environments. The core application consists of components like Nginx, Node.js, and Dgraph, with containerization using Docker to simplify deployment. Docker Compose enables the launch of a containerized Satellite instance, further streamlining the process. In this video, we will discuss the components and deployment of a single satellite instance and then move on to designing a multi-instance architecture. 

A satellite instance consists of several components, including the Nginx web server, which handles web-facing tasks such as processing GraphQL requests and serving static files. The Node.js application serves as a private entry point for developers to perform administrative actions, such as uploading static files or updating the GraphQL schema. 

Deploying a single satellite instance manually can be time-consuming and challenging. To simplify the process, we turn to containers. Containers allow us to package an application with its dependencies in an isolated and consistent manner, eliminating the need for manual installation and configuration. Containers also offer lightweight deployment compared to options like virtual machines. For our project, we choose to use Docker containers, as they are widely popular for packaging applications. 

Despite simplifying the deployment of individual components, manually starting and stopping each container for an application is still required. To address this, we make use of Docker Compose. Docker Compose is a tool specifically designed for defining and running multi-container Docker applications. Using a YAML file, we can declaratively describe the containers we want to run and launch them with the necessary configurations. 

Now, let's move on to the design of a multi-instance architecture. Supporting multiple satellite instances is essential to accommodate front-end developers who may want to work on multiple applications or versions of the same application. Our chosen solution is a multi-instance architecture, where multiple instances of a software application run on a machine, sharing its hardware and system resources. Each instance is self-contained, meaning it has its own schema and front-end files. 

To support multiple satellite instances, we need to address several challenges. Firstly, we need a way to spin up and tear down individual instances of the back end. Running multiple compose files on a single machine introduces port name and network conflicts, as well as resource scarcity issues. To solve this problem, we opt for horizontal scaling, which involves adding more servers to meet demand and ensure resource efficiency. 

To manage the distribution of individual components of a single satellite across multiple machines, we utilize Kubernetes as our container orchestrator. Kubernetes allows containers to run within a cluster, which consists of connected machines. By using Kubernetes, we can easily spin up new containerized applications, define how satellite instances should be created, and specify how node or container failure should be handled. Kubernetes also provides networking capabilities between containers running on the same or separate nodes. 

To enable communication between satellite components, we utilize Kubernetes services. Services act as a fixed gateway to containers and provide a way to dynamically discover each other's IP addresses and ports. By defining services for each component, such as the Nginx container and the Express API, we can route traffic internally and ensure that requests reach the correct destination even when containers change IP addresses. 

Routing external requests to the correct satellite instance is achieved using a tool called "Traffic." Traffic is an HTTP reverse proxy that allows us to route requests based on user-defined routing rules. By using subdomains as routing rules, we can send requests to the correct satellite instance. Traffic communicates with the Cluster IP Service of the Nginx container to route the request accordingly. 

To simplify the management of individual satellite instances, we provide an admin panel. This panel, built as a React application, communicates with an Express API and is accessible at admin.yourdomain.com. Through the admin panel, front-end developers can create and destroy satellites, configure the GraphQL schema, upload files for static hosting, and manage satellite data. 

Now that we have covered the multi-instance architecture, let's move on to building an actual application using Satellite. Suppose we want to build a to-do app. We can create a satellite instance named "To-Do App" and configure its GraphQL schema by uploading a text file. The admin panel visually displays the current schema of the satellite instance. We can then populate the database with to-do list entries using GraphQL mutations. 

Once we have the back-end set up, we need to update the JavaScript files to make requests to the correct origin. We upload these files to be served by the Nginx container within the satellite instance. With the front-end and back-end connected, we now have a fully functional to-do app ready for use. 

As for future improvements, we aim to implement an authentication mechanism within the admin panel, eliminating the need for third-party providers. Additionally, we intend to enhance the satellite management capabilities, including adding features to update the schema and securely manage user data. The request is routed to traffic, which checks out the subdomain and path. It then routes the request to the cluster AP service with a matching subdomain. The cluster IP service then forwards the request to the engineer's container for that satellite instance. The goal is to make managing administrative tasks easier by using an admin panel. Currently, front-end developers need to issue commands directly to Kubernetes to manage satellites, which is not ideal as developers may not be familiar with Kubernetes and it raises security concerns. Is there a way to provide an interface to abstract away the process of managing satellites? The solution is to use a GUI as the interface, specifically an admin panel. The admin panel is a React application that communicates with an Express API and is accessible at admin.yourdomain.com (your domain can be chosen). Through this React app, front-end developers can create and destroy satellites, configure the GraphQL schema of their application, upload files for static hosting, and manage satellite data.

Now, let's take a look at the final multi-instance architecture. We have a Kubernetes cluster where the containerized satellites run, traffic as a reverse proxy running as a container within the cluster, and an admin panel provided at admin.domain.com for front-end developers to perform administrative actions on their satellite instances. Now, let's build an actual application. We'll build a to-do app using satellites. Since we don't have any satellites running yet, let's create one called "To-Do App." It takes a few moments for the button to spin up, and once it's ready, we can start configuring our application.

First, we define the GraphQL schema of the to-do list. The schema is uploaded as a text file, and once uploaded, the admin panel displays the current schema of the satellite instance. Now, let's populate the database with some data. We perform a GraphQL mutation to add entries to the to-do list. Since our app is called "To-Do App," the backend will be available at the subdomain to-do-app.yourdomain.com (your domain). We just need to update the JavaScript files to make requests to the correct origin. Once the front-end files are updated and ready to go, we upload them to be served by the satellite instance's web server, Nginx. And there you have it â€“ a fully built to-do app ready for venture capital funding.

Looking ahead, there are several features we plan to implement in the future. Firstly, we want to provide an authentication mechanism so front-end developers don't have to rely on third-party providers. Secondly, we would like to add a way to keep track of API metrics and loads. And finally, we aim to facilitate easy database backups and exports. These are the people involved in bringing this project to life and who presented it today. Thank you all for coming, and now we will open the floor for questions.

Question: Where are the backends hosted? The backends are hosted on a Kubernetes cluster, which can be managed by various cloud providers. You can get a managed Kubernetes cluster as a service from providers like Azure, AWS, and DigitalOcean. Additionally, you can run Kubernetes on your own hardware if desired.

Question: Does the user need to configure the Kubernetes cluster for specific cloud architecture? No, the user doesn't need to configure the Kubernetes cluster for a specific cloud architecture. Managed Kubernetes clusters provided by cloud providers make it easy for users since the application is already packaged and can be easily deployed. With Kubernetes, providers also offer external storage, which simplifies persistent data management compared to Docker Swarm.

Question: What were some of the challenges of using a graph database instead of a SQL database? One challenge of using a graph database is that it requires a different query language and has its own data model. Graph databases like Dgraph and Neo4j have specific query languages, such as Cypher or Open Query. This is different from SQL databases, which use SQL for querying. However, when using GraphQL to interact with the database, these challenges are abstracted away, and front-end developers only need to use familiar GraphQL queries.

Question: How did you decide to work with GraphQL? GraphQL was chosen because it solves the problem of over-fetching and prevents unnecessary round trips for the client. It also simplifies the back-end development process, providing a back-end as a service for front-end developers.

Question: Does this work with any kind of front-end application? Yes, it works with any front-end application as long as it can make GraphQL queries to the back-end. The admin panel, for example, is a React app, but any front-end framework can be used.

Question: What did you use to develop the admin panel? The admin panel is built using React, specifically using the Front component for the front end and an Express app for the back end. This combination allows for data management and interaction with the Postgres database.

Question: How did you discover existing tools like traffic to solve specific problems? The process of discovering existing tools involves deeply understanding the problem at hand and trying to solve it on your own. Once you have a good understanding of the problem, you can start asking the right questions and researching solutions. Over time, you will start to come across existing tools and resources that address similar problems. It's a process of trial and error, self-education, and persistence in finding the best fit for your specific needs.

Question: What was the most meaningful part of working on this project for each of you? Each team member had their unique meaningful experiences throughout the project. For some, it was the coordination and management of a long-term group project. For others, it was the opportunity to learn about reverse proxies, setting up Kubernetes clusters, and working with GraphQL's statically typed system. Overall, the project provided valuable learning experiences and the chance to work with various technologies and solve real-world problems. In order to successfully navigate the world of Kubernetes or traffic as an ingress controller, it's important to have a solid understanding of the problem at hand before diving in. Starting without any knowledge or understanding of these tools can be overwhelming and confusing. It's crucial to know where to start and how to approach these technologies effectively. The learning curve can be steep, but with time and self-education, the pieces start to fall into place. As you become more familiar with the problem, you begin to ask the right questions and seek out the answers, often by turning to resources like Google. By seeking guidance, you can discover existing tools that can help address the specific problem you're facing.

Moving on to Will's section, the process of converting from schema to a graph database was not a quick one. It took several weeks of intensive research, patience, and perseverance to determine the best option for their needs. This journey required a significant investment of time, energy, and mental effort. They encountered various obstacles and had to overcome challenges to ultimately arrive at the ideal solution.

It appears that we have answered all the questions so far, but it seems there is another inquiry. Rodney is asked about the most meaningful aspect of working on this project. For him, it was coordinating a project of this magnitude. He had never experienced such an involved group or team project before, so it was a valuable learning experience in terms of project coordination and management.

Another team member mentions that they were initially unfamiliar with reverse proxies and Kubernetes, which forced them to delve deeper into the networking side of things. The process of implementing reverse proxies and getting to grips with Kubernetes expanded their understanding of server-side concepts and computer networking, making it a highly valuable experience.

For another team member, the most meaningful part from a technological standpoint was working with the statically-typed system of GraphQL. They had previously worked with dynamically-typed languages, so this was a new and interesting experience for them. Although GraphQL is not a programming language itself, its strongly-typed schema introduced a different way of thinking and brought about certain benefits, such as enabling schema introspection and facilitating certain applications.

One team member reflects on the valuable lesson they learned about dealing with uncertainty throughout the project. In the beginning, there was no way to predict how things would evolve or where they would end up. However, as the project progressed, they saw it all come together. This experience taught them the importance of being comfortable with not knowing the next step and embracing the challenges that accompany diving into the unknown.

With that, the team concludes their presentation. They express gratitude to the audience for attending and wish them a pleasant start to the new year.