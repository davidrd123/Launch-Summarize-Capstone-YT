Rodney Mutambo: Good day, everyone. My name is Rodney Mutambo, and with me today are Christian Larwood, Owen Lentz, and Ezra Elliott. Together, we have developed a lightweight, open-source framework called Jolt. Jolt is designed to build and deploy Jamstack applications with serverless functions. In this video, we will cover five key sections. First, we will explain what Jamstack is and how it relates to serverless architecture. Then, we will explore existing solutions for deploying Jamstack applications. Next, we will discuss how to deploy applications using Jolt. Following that, we will share the challenges we encountered while developing Jolt. Finally, we will present the final architecture of Jolt and discuss any future work we have planned.

The combination of Jamstack and serverless architecture may not be well-known to everyone, but it is gaining popularity. In fact, the VP of Engineering at a prominent cloud architecture deployment company has stated that serverless plus Jamstack is the future of web app architectures. To grasp this concept, let's first define web application architecture. It refers to how different components of our infrastructure interact, including middleware systems and databases. These interactions ensure that multiple applications can work together seamlessly.

Generally, web applications consist of a client-side and a server-side. The client-side and server-side communicate through HTTP requests. The choice of web app architecture depends on what needs to happen on each side. Most developers adopt a three-tier architecture. In this architecture, the client sends a request, and most of the processing happens on the server-side. The web server handles routing and hosting of static assets. If the client only requires static assets, the request ends at the web server, which serves the static assets as a response. The application server handles general compute tasks and business logic. Finally, the database server stores persistent data.

While this three-tier architecture is common, it requires significant server-side involvement, which may not be ideal for front-end developers who want to focus on their application code rather than managing servers. As a result, new architectures have emerged that push more activity to the client-side or minimize server ownership and management. One such architecture is Jamstack.

The term Jamstack was coined by Matthias Billman, CEO, and Founder of Netlify. Jamstack is a modern web development architecture that relies on client-side JavaScript, reusable APIs, and pre-built markup. By breaking it down, the "Jam" in Jamstack represents JavaScript, APIs, and Markup. Client-side JavaScript handles dynamic workflows, while APIs provide additional functionalities like content management, search, authorization, and payments. Markup refers to a collection of pre-rendered HTML files.

In a typical Jamstack architecture, static content is delivered using a content distribution network (CDN). Dynamic content is obtained through JavaScript making API calls to third-party APIs. CDNs consist of distributed servers that serve content based on the user's location. For example, if a user is in Africa, they will receive content from the server nearest to their location. This distributed approach ensures faster performance.

To populate the CDN, a site generator is used to assemble the content needed to build static sites. This content is then pushed to the CDN. When a user requests a page, the browser receives one of these pre-built pages from the nearest server. This takes care of the static content. For dynamic content, most of the processing is shifted to the client-side. Client-side JavaScript performs DOM manipulations without requiring a complete page reload. Third-party APIs handle additional content retrieval, such as Google Forms or Fauna DB. This offloads most of the activity to the client-side.

By combining these capabilities, a Jamstack architecture can serve both static and dynamic content with improved performance. However, it is worth noting that Jamstack has limitations. For instance, it is not suitable for sites that require frequent rebuilds or constant changes to static assets. It works best for sites with consistent static assets but changing data behind the APIs.

Comparing Jamstack and the traditional three-tier architecture, we can see a clear shift in responsibilities. Web servers used to handle static content, but in Jamstack, that responsibility is handed over to CDNs. Instead of managing databases and application servers, third-party APIs abstract away those concerns. This reduces the complexity for front-end developers, who can now focus solely on their application code while API services handle the rest.

Despite the advantages of Jamstack, there are times when developers may need custom backend capabilities without relying on third-party intermediaries. This is where serverless architecture comes into play. Serverless functions, made popular by AWS Lambda, provide a compute service that runs code without requiring server provisioning or management.

Serverless functions simplify development by handling infrastructure and runtimes automatically, enabling developers to focus on writing code. However, using serverless functions does come with some tradeoffs. For example, serverless functions are not designed for long-running applications and can have limitations when integrating with Jamstack. Nonetheless, many Jamstack providers are working to improve the integration between Jamstack and serverless functions.

There are several examples of companies successfully adopting serverless plus Jamstack architecture. For instance, PayPal migrated its PayPal.me portal to this architecture and reported significant performance improvements. They even coined the term "static apps" to describe applications built using this combination.

If you want to build a serverless plus Jamstack application manually, you need to consider four core aspects of infrastructure: storing static assets, running functions, managing APIs, and distributing assets. Static assets, such as HTML and JavaScript files, need storage. Function files and dependencies also require storage. These files should be easily accessible by other parts of the infrastructure.

To run functions, serverless compute functionality is required. This enables functions to be invoked when needed. Managing APIs necessitates routing HTTP requests from clients to the appropriate serverless function. Finally, distributing and serving static assets to users worldwide requires a global network of CDNs.

Now, let's move on to the deployment of Jamstack plus serverless applications. We'll explore existing solutions and introduce Jolt, our lightweight open-source framework designed specifically for this purpose. In the world of web development, there is a growing trend towards serverless architecture combined with the Jamstack approach. These serverless Jamstack applications, also known as static apps, are gaining popularity because they offer various advantages. The concept of serverless architecture involves shifting away from traditional server-based models by leveraging cloud-based services to handle backend functionality dynamically. The Jamstack approach, on the other hand, focuses on delivering static assets to users by pre-building as much as possible during the build process.

To build a serverless Jamstack application manually, you need to consider four core pieces of infrastructure: storage for static assets, a way to run functions, management of APIs, and distribution of static assets to users. First, you need to determine where to store your project's static assets such as HTML and JavaScript files, as well as other files like functions and their dependencies. These files should be easily accessible by other infrastructure components.

Next, you must determine how to run your functions. Serverless compute functionality is essential for a serverless Jamstack application. It allows you to handle tasks that require backend processing, such as querying a third-party database or making API calls.

Managing APIs is another crucial aspect of building a serverless Jamstack application. With multiple functions in your application, you need a way to route HTTP requests from clients to the appropriate serverless function. An API gateway can handle this by receiving API calls and forwarding them to the correct function for processing.

Lastly, you need to consider how to distribute and serve your application's static assets to users worldwide. To achieve low latency and ensure an optimal user experience, you can employ a global network of content delivery networks (CDNs). CDNs ensure that when a user accesses your site, they receive the static assets from the CDN nearest to their location.

If you decide to use AWS as your infrastructure provider, you will also need to provision and work with AWS Identity and Access Management (IAM), which allows you to manage access to other AWS services. However, the manual deployment process for a serverless Jamstack application via the AWS web console can be extremely tedious and error-prone. It involves around 50 individual steps, including creating each Lambda function, uploading dependencies, setting up API Gateway routes, and configuring CloudFront distribution.

Fortunately, there are solutions available that abstract away the complexity and streamline the deployment process. Tools like Netlify and Vercel can simplify the deployment of Jamstack applications by providing robust features focused on the Jamstack architecture. These tools handle provisioning the necessary infrastructure, including serverless functions, and deploying static assets to CDNs. However, they have limitations and restrictions, such as managing your infrastructure entirely and imposing constraints on Lambda memory size, timeout limits, and monthly invocation limits.

Alternatively, you can use other options like the Serverless Framework or AWS-specific tools like Amplify IAC (Infrastructure as Code), which encompasses CloudFormation, CDK (Cloud Development Kit), SAM (Serverless Application Model), and the AWS web console. These options offer more control and robust infrastructure capabilities but may lack specific features tailored to Jamstack applications.

To address the limitations and find a middle ground between ease of use and infrastructure control, we introduce Joltâ€”a lightweight Jamstack plus serverless framework. Jolt simplifies the deployment process by automating project builds, provisioning cloud infrastructure for applications and serverless functions, and deploying applications to a CDN. With a single command, "jolt deploy," you can avoid the manual and error-prone steps involved in the AWS web console deployment. Importantly, Jolt allows you to retain ownership and control over your application's underlying infrastructure, making it open-source and customizable to suit your team's needs.

While Jolt may not offer as many Jamstack-centric features as Netlify or Vercel, it enables developers to deploy applications with serverless functions easily. Compared to AWS, Jolt provides a simpler deployment process and the ability to seamlessly update infrastructure and functionality as your Jamstack plus serverless application evolves.

Now that we have discussed the necessary infrastructure and explored different deployment options, let's delve into the core architecture of Jolt and how it deploys Jamstack plus serverless applications. The core components of a Jamstack plus serverless application involve static assets requested from a CDN, third-party APIs for computational tasks, and custom compute through serverless functions.

To serve static assets with minimal latency, Jolt utilizes Amazon CloudFront as a CDN service. Amazon S3 serves as the storage solution for the static files, which are cached by CloudFront and promptly delivered to clients upon request. Periodically, the cache expires, triggering a cache miss and prompting CloudFront to retrieve the latest versions of the requested files from S3.

For custom compute that cannot be handled by third-party APIs, Jolt employs AWS Lambda, which allows developers to create their own serverless functions tailored to their application's specific needs. However, for clients to send requests to these Lambdas, a reverse proxy is required to route each request to the appropriate Lambda. Here, Jolt utilizes AWS API Gateway, which provides unique endpoints for each Lambda and integrates them into the gateway's routing system.

By combining these infrastructure components, Jolt offers a fully functional Jamstack application with serverless functions. Static content is served by CloudFront, dynamic content is provided by Lambdas through API Gateway or third-party APIs, and requests flow smoothly throughout the application's architecture.

Now that we have covered the necessary infrastructure and Jolt's core architecture, let's explore how Jolt can be used from a developer's perspective. Imagine a developer named Bob who is building a note-taking application using React. Bob is a front-end developer seeking a backend solution that provides secure interfacing with a third-party database without the complexity of managing an application server. Additionally, he wants scalability without excessive effort. After researching various options, Bob decides that a Jamstack plus serverless approach suits his needs.

To get started with Jolt, Bob runs "jolt init" from the root directory of his application. This command prompts Bob to answer a few questions, which are then stored in a local configuration file. This file tracks all the details needed for development, deployment, and management of his note-taking app. If Bob decides to use Jolt for other applications in the future, he can run "jolt init" again in those projects to configure them similarly.

Since Bob's application requires Lambdas to interact with the FaunaDB database, he can define each Lambda as a separate file within the "functions" folder located in the root of his application. This modularity allows Bob to have separate Lambdas for getting, creating, and updating notes. However, since coding errors are common, Bob needs a way to test and debug these Lambdas locally. Unfortunately, without specialized tools, running Lambdas locally is challenging. The typical process involves deploying the Lambda on AWS, sending requests to it, consulting logs from another AWS service, making changes locally, redeploying, and repeating the cycle.

Fortunately, with Jolt, Bob can avoid this cumbersome process. Jolt offers streamlined local testing and debugging for Lambdas. Bob can save time by testing his Lambdas locally, making changes on-the-fly, and deploying updates seamlessly. By leveraging Jolt's simplicity and automation, Bob can quickly develop and deploy his functional Jamstack plus serverless application.

In conclusion, we have explored the necessary infrastructure for deploying and maintaining a Jamstack plus serverless application, as well as various deployment options. We have also introduced Jolt, a lightweight framework that simplifies deployment by automating infrastructure provisioning and configuration. Jolt strikes a balance between ease of use and infrastructure control, allowing developers to deploy applications quickly while retaining ownership over their infrastructure. By explaining Jolt's core architecture, we have demonstrated how it deploys Jamstack plus serverless applications efficiently, utilizing a combination of CDNs, serverless functions, and API gateways. Finally, we have examined Jolt's usage from a developer's perspective, emphasizing the ease of configuration and the productivity gains it offers during the development and deployment lifecycle. Jolt is a programming platform that utilizes serverless functions and cloudfront requests to handle static and dynamic content. It provides developers with a lightweight backend solution for interfacing with third-party databases, without the need for complex application management. Using Jolt, developers can build highly scalable applications with minimal effort.

Let's take a look at how a hypothetical web developer, Bob, can make use of Jolt. Bob is working on a note-taking application and wants to find an architecture that offers both frontend functionality and secure interaction with a third-party database. After researching, Bob decides that a combination of Jamstack and serverless computing is the best fit for his needs.

Bob's application is built using React and utilizes CRUD functionality provided by lambdas, which interface with FaunaDB, a GraphQL database. To get started, Bob runs "jolt init" from the root directory of his application. This command prompts him with a few questions to create a configuration file that stores all the necessary details for developing, deploying, and managing his notes app. 

Next, Bob needs to define the lambdas required to interface with FaunaDB. He creates separate files for getting, creating, and updating notes in a "functions" folder within the root of his application. These lambdas will handle specific operations on the database.

One challenge in building a Jamstack with serverless application is testing and debugging the lambdas. Without a specialized tool, running lambdas locally is not possible. Developers usually have to deploy the lambdas to AWS, send requests to them, consult the logs, make changes, re-deploy, and repeat. This process is time-consuming and involves a lot of context switching.

To address this challenge, Jolt provides a local development server that allows developers to run their lambdas locally. Bob can use the "jolt dev" command to start this server, which runs both his notes app and his lambdas locally. He can then access his application at "localhost:3000" and test the lambdas in real time. Logs from lambda requests are printed in the terminal, making debugging much smoother.

Once Bob has finished development and tested everything, he is ready to deploy his application. He simply runs "jolt deploy" to kick off the build process. This process transforms Bob's frontend code into minified HTML, CSS, and JavaScript files, making them compatible with various web browsers. Jolt provisions the necessary infrastructure outlined in Bob's configuration file and sends the static assets and lambda code to S3. CloudFront caches the static assets, while lambdas are created using the uploaded code.

Deployment to a CDN like CloudFront may take some time, but after a few minutes, Bob's app is fully deployed and accessible worldwide. Thanks to the Jamstack and serverless architecture, his app can automatically scale to handle increased traffic, and the CDN ensures optimal performance globally.

As time goes by, Bob's app, "Bob Notes," gains popularity. With the Jamstack and serverless architecture, Bob can focus on developing new features without worrying about backend management. Scalability is built-in, and the CDN efficiently serves static assets to any number of clients without slowing down.

Bob's next task is to add the ability for users to delete notes. After developing and testing this functionality locally, Bob is ready to roll out version 2 of Bob Notes. He uses the "jolt update" command to build the application code into static assets and update the existing infrastructure on AWS. New lambdas, such as the "delete note" lambda, are created if necessary. After a few minutes, version 2 of Bob Notes is live worldwide.

However, Bob encounters a problem with version 2. It seems he forgot to include any CSS in the update, leading to user complaints. Luckily, Jolt provides an easy fix for such situations. Bob can use the "jolt rollback" command to revert both the frontend and lambdas to the previous version. Rolling back ensures compatibility between the frontend and serverless functions, solving this particular problem. Jolt handles the complexities of rolling back static assets and infrastructure changes.

Developing Jolt presented a set of technical challenges. One such challenge was making the API endpoints predictable and user-friendly. Traditionally, users would have to use the API gateway URL to access their functions, which could be confusing and time-consuming. Jolt uses CloudFront's lambda at edge feature to redirect requests with a ".functions" path prefix to CloudFront, which then redirects to the API gateway. This provides users with intuitive, relative URLs for their functions without the need for manually hard-coding the gateway URL.

Another challenge was managing failures during deployment or updates. With multiple pieces of infrastructure involved, rectifying errors manually could be time-consuming. To mitigate this, Jolt treats deployments and updates as atomic units. If a deployment or update fails, Jolt reverts the application to its previous state, ensuring that no lingering or unnecessary infrastructure remains. A DynamoDB database serves as a source of truth for all Jolt applications, maintaining records for different versions. This allows developers to safely deploy, update, and roll back their applications.

Rolling back an application that includes both static assets and APIs presented another challenge. Jolt solves this by either deleting static assets of newer versions or re-uploading files from a specific version, depending on the chosen rollback strategy. While re-uploading assets uses more storage on S3, Jolt chose this approach to allow users to roll back to any version they require.

The rollback process involves invalidating cached objects in CloudFront, updating the proxy version, and ensuring that the selected rollback version is active globally. Jolt's CLI provides a rollback command that makes it easy for users to roll back their applications to a specific version.

These were just some of the technical challenges faced while building Jolt. The platform aims to simplify the development, deployment, and management of Jamstack applications by providing a seamless workflow and addressing common pain points. In the next section, Ezra will provide a closer look at some of the commands used in Jolt and discuss how the team tackled specific technical challenges.

(Note: Due to the length of the transcript, I can only provide the first half here. Please let me know if you'd like the rest of the transcript.) The transcript discusses the usage of DynamoDB, a database used as a source of truth for all Jolt applications. Each application has its own table within the database, which keeps track of files and infrastructure for each version. This allows for safe deployment and updating of applications. However, there is a challenge when it comes to managing a Jolt application. In the case of an update resulting in a malfunction, users should be able to quickly revert to a working version. While this is relatively straightforward for static assets, it is more challenging for APIs. Rollback versions of APIs need to have the same endpoints as the previous versions, and the static assets need to be accessible. Two options were considered for rolling back the static assets of a Jolt application: deleting all versions of a file that exceed the rollback version or re-uploading files from a specific version. The decision was made to re-upload static assets, even though it would require more storage on S3, because the ability to roll back to any version was considered more valuable.

The next step involves querying the DynamoDB database to retrieve the proxy used in the selected version. This allows access to the specific version's API gateway, as the API is completely rebuilt and saved as a new version during updates. The final step in the rollback process is updating CloudFront. First, the objects cached by CloudFront are invalidated, forcing CloudFront to retrieve the updated static assets from S3. Additionally, the proxy version is changed to link the static assets to the appropriate API version. This process takes a couple of minutes due to the global nature of CloudFront. Once all the steps are completed, the selected rollback version becomes active globally.

In the CLI, users can leverage the Jolt CLI's rollback command to revert a project to any desired version. The process involves selecting the project and then choosing the version for the rollback. Users can then confirm their selection, and the rollback process will commence. After rolling back, users can observe that the application has reverted to the previous version. Jolt's final architecture includes changes such as the ability to use relative paths for function calls, update capabilities, and rollback capabilities. This architecture involves interaction between a client, CloudFront for retrieving static assets, Lambda functions for accessing the application's APIs, and DynamoDB for storing information about Jolt applications.

As for future work, Jolt aims to add a GUI dashboard for managing projects, integrate with GitHub for continuous deployment, and provide support for additional Lambda runtimes and application staging environments.

During the Q&A session, the team received a question about the part they enjoyed the most while building Jolt. The responses varied, with one team member expressing enjoyment in implementing rollbacks and the other team members mentioning the learning process and gaining familiarity with AWS services.

Furthermore, the team was asked if they would recommend all Core graduates to learn more about AWS and which other tools they would recommend. One team member recommended learning AWS as it allows developers to gain a better understanding of the industry and systems thinking. Another team member suggested prioritizing learning tools that are relevant to specific job interests.

The team was also asked if it is possible to roll forward to a more recent version after rolling back. They explained that the rollback functionality allows users to change the version to any previously deployed or updated version. Therefore, after rolling back, it is possible to perform another rollback to the latest version without any issues.

Regarding the division of responsibilities during the project's development process, they mentioned that they worked as a team, discussing the implementation details together, and then splitting off into pairs or working individually based on the task's complexity.

Lastly, the team was asked how they transitioned from a manual process to their eventual solution. They explained that they first explored using third-party tools like AWS CDK, but ultimately decided to use the AWS SDK to issue the necessary commands for infrastructure provisioning. This allowed them more flexibility and control over the process while reducing the number of commands required.

In conclusion, the team presented Jolt as a solution for Gemstack developers, highlighting its benefits and cost-effectiveness. They recommended learning AWS and emphasized the importance of continuous learning and adapting to the ever-evolving software development industry. In this video, we will discuss the rollback functionality of our coding Capstone project. Rollback functionality allows you to change the version of the application to any previously deployed or updated version. For example, you could do a rollback to version one of the application for historical purposes and then do another rollback to go back to the latest version. This can be done without any issues.

Moving on to project responsibilities, we had a collaborative approach. We started by coming together as a team to decide what we wanted to implement. Once we had a clear idea, we would split into pairs or individuals would work on specific tasks. The approach varied depending on the project phase, and we would adapt accordingly to ensure efficient progress.

Now let's discuss the process of transitioning from a manual process of issuing commands to our eventual solution. Initially, we manually issued dozens of commands to set up our gemstack. To understand the challenges involved, we exclusively used the AWS web console, resulting in a guide with over 50 steps. However, we wanted to streamline this process, so we explored different options.

One option we considered was the AWS CDK (Cloud Development Kit). Ultimately, we decided to use the AWS SDK (Software Development Kit) as it provided more flexibility for issuing commands. With the SDK, we were able to issue the necessary commands to set up our infrastructure efficiently. For example, to create a lambda function, we needed to create an IAM role and attach it to the lambda function for invocation. By using the SDK, we simplified this into a few primary commands.

Additionally, a suggestion from Austin was to add a feature that allows users to check their available or remaining AWS bandwidth from within the Jolt CLI (Command Line Interface) terminal, especially for the free tier. While we haven't implemented this yet, it's an excellent suggestion. We will explore if there is an API available for metering AWS bandwidth usage and consider implementing it in our project. It would be a useful feature to have.

Lastly, we want to express our gratitude to everyone for attending this presentation. We appreciate your presence and value your input. We have received some good suggestions, and we may even invite some of you to join our team. This entire project has been a rewarding experience for us, and we hope it has been a valuable learning experience for those who have followed our journey. Thank you for your support, and we are proud to represent our team in this presentation.