all right hello everyone thank you all for joining us this is sheila chris andrew and i'm melinda we're the creators of gander the open source solution for deploying isolated ephemeral apps based on your pull requests so what exactly does that mean it means scanda makes it easy to view a live deployment of your code changes within minutes of creating a pull request with no additional steps required from you as a developer so here we are on github and we're creating a pull request upon creating a pull request we see that github automatically runs a check called create review app if we click into that check we can see the build workflow running building the review app and after that build is done running we can return to the pull request to find a link clicking that link leads us to a live deployment of our app where we can test any features that we're developing now usually when a team's developing an app there's more than one feature in the works meaning there's more than one pr open gander will spin up separate review apps for all open pr's and each pr will get their own semantic link so we can see here that pr9 on our to-do app has a link starting with to-do app nine and pr10 on the same app will receive a link starting with to-do app 10. clicking each link leads us to two live deployments each showcasing a different feature and if we read the to-do's within the separate to-do app deployments we can see that the lists are different this is possible since each review app receives its own isolated database we feel gander is a pretty nifty tool so today we'd love to share our journey in its creation first we'll start off with the basics and build a case for why review apps are useful tool next we'll take a look at existing solutions for adding review apps into our development flow and then we'll introduce you to ganda and what it offers followed by a section on how we built gander and the interesting design decisions we had to make and lastly we'll touch on some especially challenging problems that we encountered so let's get started in case you're not sure how review apps could be a helpful part of your development flow we'll start with a more concrete definition of what they are and where they can fit in review apps are temporary deployments of your applications typically these applications are deployed to an isolated environment separate from your development machine these deployments are easily shareable via live link making it easy for other developers project managers and quality assurance and clients to give feedback on the features that you're developing and since the environment is both temporary and isolated developers creating separate features can each spin up their own review app to showcase the feature in isolation and then tear down after the feature has been finalized when a feature is developed we follow some development cycle the specifics of each developer's cycles and git practices will differ though we can follow a developer's journey of creating a new navigation bar to get an idea of where review apps can fit into a development cycle so here we see the main branch of the git repository in this particular model we see that our developer first creates a new feature branch of maine and then builds a new navbar on this separate branch and after he's done he opens up a pull request which after some code reviews gets merged back into main after merging the new nav by into main this new feature will typically go through some development pipeline for users before it goes live so these phases can involve things like testing qa checks or deploying to a staging environment meant to mimic production conditions the main point to notice is that regardless of the phase the new code enters the code is only visually reviewed after the merge back into name as new features are only deployed and viewed after the merge we see that without review apps developers must wait for the end of the development cycle before receiving more extensive feedback from non-technical stakeholders so if something with the feature isn't quite up to par with the client standards or a small bug made it through the code reviews our developer would have to go through yet another development cycle before receiving another review on his navigation bar fixes this trend of reviewing after mergers lengthens the amount of time development takes as there's more time between the constructive reviews involving non-developers more lengthy back and forth between all parties involved and there's the possibility of merging unsatisfactory features into main with review apps we can shorten the feedback loop our developer doesn't have to wait for his code to be merged into main before he can receive feedback review ad solutions allow us to create an fml deployment upon creating the pull request before merging into main our developer can share his work with and receive feedback from other developers clients and other non-technical stakeholders not only is the feedback loop shorter but we're also reviewing the feature earlier within the development process making us more likely to avoid problems associated with debugging and fixing merged code all in all review apps are a convenient tool offering developers the chance to review and get feedback on features earlier within a development cycle review code changes both visually and through code comments include more people including non-technical stakeholders in a reviewing process and review apps by nature are easily and quickly available and offer a safe isolated environment to preview features so what tools and services exist to help us easily create review apps generally speaking there seem to be two categories of existing review art solutions the first category is review apps as part of a pipeline service products like heroku pipelines provide review apps as one part of a fully integrated development pipeline service while it's great that now services to help handle all stages of your development pipeline such services impose a specific pipeline model such as the one that you see on the screen which means you have less flexibility in your development cycles furthermore you must host your application with them trading away access and control of your application's code and infrastructure if you're looking for just a simple review app solution and not a whole development pipeline then this isn't the solution for you the second category is review apps as a service oftentimes such services like tugboat and reply offer a whole configurable platform of deploying and managing review apps more features than simply deploying a review app however with more features comes more configuration responsibilities that falls on the end user the user needs to learn the services system and write a server-specific configuration file for each and every application they want to preview also similar to the pipeline services these review app services host applications on their own infrastructure thus limiting the user's control over the code they also require subscription so the user pays a flat fee that's independent of how often they use the service so if you're looking for a simple solution that deploys review apps without too much work from you then this isn't the solution for you either we can see here that the existing solutions for creating review apps target users who want highly configurable services want applications hosted for them and possibly want more features than just review ads however some development teams may not need all the bells and whistles that come with such feature-rich packages there isn't a solution that simply builds and deploys review apps without too much configuration what we're missing is a simple open source solution and one with a favorable payment plan based on the resources that you use so to fill this gap we could try to build our own review app solution we can design a solution and focus on building and deploying apps easily and since we're designing it we can control the infrastructure and design it in a cost effective way but before we consider how to build a whole review app solution let's start with a simpler problem what goes into deploying one application well we'd probably need a provision some service somewhere to host our application and then we need to make sure that our server's secure by configuring it and then we want to install all the dependencies needed to run our application and then we'd want to provision some database for our apps data configure the data storage on that server and initialize and see our database and then we need to start up our actual application and so on and so on as you can see there's a lot of configuration in setting up that goes into deploying one app but here's the thing if we want to create an in-house review app solution we've still got quite a few points to consider after deploying just one app what if we want to host more than one review app at a time should we repeat this process each and every time or do we want to design some long-lived infrastructure to host our applications in addition to multiple application instances how can we create a solution that can support multiple types of apps that each require a different set of dependencies how can we isolate and persist each review app's data for the time that the review apps are live and how can we automatically deploy these review apps when we need them as you can see creating our own solution gives us control over our code data and infrastructure it offers us flexibility in customizing our solution for our specific development needs and by choosing our design carefully it allows us to control the amount of money that our organization wants to invest in such a tool however setting up an in-house review app solution is not a trivial project there's quite a bit of work in design considerations that goes into creating a solution focused on just automating review apps so this is why we built gander which sheila will now be introducing thanks melinda so now we've seen a bit about what review apps are why you'd want to use them and what options are out there if you want to incorporate them into your workflow we're going to take a look at where gander fits in among those options so gander is a great fit for organizations or teams that want to retain complete control over their code and sensitive data while also maximizing cost efficiency we aim to provide all the benefits of the diy solution that you just saw while also adding the convenience factor of automating all of those builds deploys and tear downs the re of the review apps since we embraced the pay-as-you-go model of cloud computing we designed gander so that you only pay for the compute that you use and since review apps are both temporary and typically fielding very light traffic the cost of using gander scales up or down depending on your exact needs lastly since gander is a no commitment drop-in solution you could feasibly try it out and be able to decide if it's useful for you in minutes so what do you actually get when you incorporate gander into your development workflow well as you've seen already you gain the ability to preview a live full stack deployment of your feature changes within minutes of creating a pull request with no additional action required if you want to share these gander previews with other stakeholders or clients that's as easy as sending a link there's no login or user management needed we also support a wide variety of languages and frameworks and the provisioning and teardown of every piece of infrastructure that we create for you is fully automated as far as what kinds of applications can integrate with us we currently only support applications using postgres as a database and whose source code is hosted on github aside from those constraints your app must employ a monolithic architecture and all that means is that all of your apps components like its user interface business logic the database access layer those all have to be contained within a single app server if your system splits out any of those responsibilities into a separate service then gender wouldn't be the right fit for you so before we jump into a quick demo of how to actually get set up with gander we're going to briefly look at its architecture at a high level and you'll be seeing a lot of this diagram over the next half hour so broadly speaking gander consists of three distinct pieces the first one is a cli tool that you globally install on your machine and this enables our setup and tear-down process and it's the primary way that you're going to interact directly with gander the second piece is workflow automation files that live in your github repository and we create all of these for you and the last piece is the aws infrastructure that actually underlies all of your review app deployments this is kind of where all the action happens so as i said we're going to dig into the specific pieces of this diagram through the rest of the presentation but the main takeaway here is that once you're all set up with gander creating a pull request is going to trigger a build based on your code changes on a server within github's infrastructure after that the necessary resources are provisioned within aws and that application build will be deployed at which point you can view it you can test it and interact with it just by visiting the gender generated url on your pr so the first thing you'll do after installing is run gander setup and the only prerequisite for running gander setup is having an authenticated working aws cli already on your machine then all we need from you is the aws region that you want your review apps to operate in and then all of the infrastructure that's required to host gander review apps will be provisioned for you it's uh important to note here that the infrastructure that's spun up by this command is the structure underneath your review apps so you're only going to run gander setup once after installation regardless of how many different repositories you ultimately integrate with us we'll also create a restricted aws user for the sole purpose of interacting with gander aws resources and the only steps left for you the user are securely storing those generated access keys that you see on the screen there and creating a dns record on the domain that you want the review apps to be accessible through then after running setup the next step is to actually initialize gander within an application and for that you'll run gander init from the root directory of your repository we'll need a couple pieces of information about your application in order to customize the files and infrastructure that we generate for you and then the init command will inject those files into your repository and prepare your aws infrastructure for this particular project's review apps once all that's done all that's left to do to complete the integration is to commit and push these new files to your remote repository and then to add the aws access keys that we saw generated during setup i'm going to add those to your repository secret store on github and that's actually it so your project would now be set up to deploy a live preview every time a pull request is made and you didn't have to go through any headache of digging through documentation or entangling the configuration and setup of a new automated preview environment so now that we've seen what gander can do we're going to get into how we actually made this all happen and the first design decision we're going to discuss is uh how we figured out the mechanism that we use to set off a new review app build and also figuring out the best place for that build process to actually occur essentially enabling the process that you see highlighted here so we're going to take a look at two options that we considered and why we eventually chose to go with github actions so one way we could have achieved this is by setting up a virtual private server whose purpose is basically to listen for a web hook event notifying that a pull request was opened and then our server would clone the relevant code from github in order to actually build it and doing it this way would give you more fine-grained control over the build environment but since this vps would live outside the boundaries of github there would be an additional authentication step that's required before your server is allowed to actually interact with the repository on top of that any other metadata that the server needs about the repository in order to carry out its work would require additional requests over the network to github's api and then this server would also need to be up and online all of the time in order to listen for this web hook event considering that it'd be idle for the majority of that time this isn't very resource efficient or cost effective as an option so another viable option to accomplish our goals here was using github actions which is just a workflow automation tool that's provided by github and it allows users to build test and deploy code from within the existing context of the repositories and all that means is the metadata that i referred to earlier that the server might need in order to build the app well it no longer requires an api call it's just baked into the workflow environment and the best part about this is actually that github provides an option where all this is executed on their servers so this basically eliminates the need for our users to provision maintain and configure an entirely separate build server running our workflows on github servers through actions also means that our users are not incurring any costs or consuming any compute resources when there's no build to actually be generated remember that we want to be pay as you go so ultimately we chose to use actions to take advantage of this reduced cost as well as the convenience of executing code in the context of the repository that it's already living in and based on gander's build and tear down times this would give you around 250 to 300 pull requests per month under github's free tier for actions so now that we've established how and where we're going to kick off the review app deployment the next decision we faced was how to actually generate these application builds from source code for an arbitrary application so i'm going to hand it off to my teammate andrew to tell you about that thank you sheila so you've seen that on every pull request we execute some code on github servers using github actions and now we're going to start looking at what that code actually does which is build review apps gander creates review apps for monolithic applications as we said these applications must have exactly two processes an application and a database the naive solution for building these applications is to provision a server and simply drop the application code and its database onto that server hosting one and only one application per server in this way would be called single tenancy of course when it comes time to serve the review apps as you've seen we will want the capability to serve many review apps at one time for example we might need to serve a to do projects review app and a chat projects review app and there might be simultaneous pull requests on the same project as well like the header feature and the sidebar feature for the to do project if we drop each review app onto its own server that will get inefficient quickly we will be spinning up multiple servers and most of their resources will end up going unused the alternative to single tenancy is multi-tenancy which means running multiple apps on the same server but this creates a new problem which is dependency conflicts suppose one app depends on version one of a certain library while another app depends on version two of the same library you couldn't install that dependency on the root of the server because each version would overwrite the other you would need some way to keep the two versions of the library separate some kind of custom naming system maybe or directory structure with multiple apps and multiple dependencies that type of work will grow in complexity as the number of conflicts grows so containers are the standard solution to this type of problem containers wrap an application together with its dependencies in a way that isolates the dependencies from each other in this new environment the container rather than the server houses the dependencies that the application depends on now we can place multiple apps on the same server without worrying about the conflicts containers also give us the ability to implement multi-tenancy with projects that use a variety of languages and frameworks our architecture for managing the review apps will interact with the apps at the container level and will not need to know about what languages or frameworks are used inside of the apps each review container each review app container will look the same as all the others from outside of the containers so you can see why we have decided to build our applications using containers rather than dropping the apps directly onto a server because we can isolate the dependencies and prevent the conflicts so what about the databases well we run our databases in containers as well which provides several benefits with containerized databases we can avoid the need to deal with any potential conflicts between databases running on the same machine such as port conflicts or naming conflicts and if one database server fails then the other apps won't be affected so now each of our review apps will run in two containers one container for the application source code and one container for the database so how do we build these two container applications well containers don't actually get built directly instead what happens is we build images the images contain executable code that runs a container as a process the images that get built are stored in a registry and so when it's time to run a container the server will pull the image from a registry and then use it to run the container for our database we can pull an image from the public docker hub registry because nothing about the database server will be application specific we can use the same image for every review app but the application image is something we will need to build ourselves because that image will depend on the application source code and that code will be completely different for every project there are several ways we considered to use to build our application container images one option would be to have the user provide a docker file so a docker file is just a configuration file giving instructions for how to build an image using docker and docker is the industry standard container tool the main advantage of the user provided docker file would be the ability to support any framework that the user might need as long as the user is able to write a docker file that will containerize their own application however one of gander's design goals is convenience for the end user so to direct our design towards that goal we would prefer not to require expertise with docker and containers on the part of the user one alternative option would be to have gander generate the docker file for the user this would improve gander's ease of use and would help us reach our goal of convenience for the user however this choice would limit the types of frameworks we could support because we would need to write dockerfile generating code for every supported framework one at a time cloud native build packs provide a third option build packs give us the best of both worlds and so we chose to use them cloud native build packs are open source tools that transform source code into a runnable container image and build packs have the ability to automatically detect the language a project is written in and see how the project is constructed within its repository so build packs have the power to containerize applications written in a wide variety of frameworks and build packs give us the best of both worlds because while taking advantage of their auto detection functionality gander does not need to identify the language or structure of a project or require the user to write the configuration files as long as the user's project can be containerized with cloud-native build packs then gander can generate a review app for the project so once we have built review apps we are ready to serve review apps so we built the review apps into containers and we need to deploy those containers we use amazon to host the review apps and so that's where we deploy the containers and that's the part of the architecture that we will discuss next to serve several review apps we need a way to manage the containers that our review apps run remember there's two containers in each application and managing these containers includes several different things one would be placing the containers on servers uh deciding deciding which containers go on which servers and distributing the containers as efficiently as possible we would also have to think about scaling up additional servers when needed we also want to keep the application available if a container fails so managing containers includes restarting them on failure if a container fails we want to run another container from the same image in its place a server might fail too and in that case its containers would also fail fixing this situation will require restarting a new server and then running replacement containers on it we also need our containers to communicate with each other the application container and its database must be networked together into a group to form a review app and that container group has to know what order to start up containers in and just how the containers relate to one another all these container management operations are grouped under the concept of container orchestration and so we had to decide how gander would handle container orchestration one option would be to manage the container orchestration ourselves doing our own container orchestration would give us granular control over all aspects of it including the opportunity to determine exactly how scaling and routing are set up and managed kubernetes and docker swarm are two popular solutions for container orchestration externally managed container orchestration on the other hand would turn over the implementation details of orchestration to a service scaling and fault detection would happen automatically there would be fewer options for configuration but the benefit would come in the form of ease of use so we decided to let amazon ecs handle container orchestration for gander review apps granular control over container orchestration would really be overkill for an application like gander each review app only needs to manage two containers and we won't ever be running enough containers to see any benefit from customized orchestration we knew we wanted to use aws for our infrastructure already due to its convenience extensive documentation popularity and pay-as-you-go pricing model so this decision made a lot of sense for us so now amazon ecs is handling our container orchestration ecs will efficiently and automatically manage our containers performing auto scaling placing containers on servers restarting containers and so on but what about managing the servers would we want ecs to manage our servers as well as our containers or do we need some kind of control over our servers that was our next decision amazon ecs gives us two ways to launch containers one where we have some control over our servers that one is called ec2 the elastic compute cloud and one where we don't have any control over our servers and that is called fargate amazon ec2 would give us control over the size and processing power of our servers as well as access to their file systems but then we would also be responsible for keeping most of our servers processing power and memory in use or end up wasting them if our review apps which are shown on the screen here as tasks because in ecs language each review app runs as a task but if our tasks or review apps leave a server mostly idle as you can see in this diagram then we would be responsible for that aws fargate on the other hand would handle servers entirely on our behalf the downside of that is that we have no choice in what type of servers host our applications and no access to the server's file systems but the advantage would be that amazon would bear the responsibility of using the servers efficiently and keeping them running near maximum capacity so we chose to use fargate rather than ec2 because gander will only run a relatively small number of containers at any given time it would be very difficult for us to occupy servers efficiently with just the handful of ephemeral and isolated applications that gander runs more generally variable workloads and uncertainty are problems for keeping servers running efficiently and near capacity and gander has both uncertainty and variable workloads uncertainty because we don't know how many review apps will be running at any given time and we don't know ahead of time how many res how much how many resources each review app will need and on top of that after a review app is spun up it might sit idle for some time before the reviewer has time in her schedule to test it and even when it does get tested the workload it requires could be tiny so gander is not the type of app that runs large workloads with consistent demand which is what you really need if you want to use a option like ec2 where you manage your own servers so a serverless option like fargate is a much more cost effective choice for our users and that was an important priority for us of course the trade-off of using fargate's serverless orchestration is that we are not able to access the host machines on which our review apps live so but we were able to compensate for this as you will see in the next section when chris discusses how we handled the challenge of data persistence thank you andrew so now that we know how to provision your review apps and orchestrate them how do we make sure the data you enter is persistent we're going to be taking a look at the part of the architecture that pertains to storing the data databases use so containers do have access to an ephemeral file system this file system can be used to store data such as postgres data but imagine you're developing a chat application and you're testing a user signup workflow in your review app and halfway through the testing the task restarts this could be due to a fault in the container management service the server hosting your task or a network fault rendering the original task unreachable in this instance we lose that data we just spent time entering in during our validation testing if we had access to the host servers file system we would be able to map a volume to that and all volume mapping means is mirroring a folder within the container to the outside of the container any data written to that directory within the container by the application will also be written to the directory outside of the container however on fargate we don't have access to the hosting server's file system the solution here is to use amazon's elastic file system in fact it's the only way to map a volume to a fargate managed container efs is an amazon product accessible over the network file system protocol and it charges per gigabyte stored per month and scales up automatically when we use elastic file system volume mapping acts the same way as using the host server's file system and when data is written to the efs when data is written data is mirrored to efs and when the container restarts due to a network fault application error or server failure we don't lose the data because it was written to efs so now that we can build and host your app and persist its data how do we route traffic to these isolated review apps so now we're going to take a look at the part of our infrastructure involved in routing traffic to the generated review apps one way to do this is to use the auto-generated dns names given to each task amazon provisions what they call an elastic network interface for each task or eni for short and these enis can be thought of as software network cards they're assigned a unique dns name that amazon generates on creation so in this diagram you can see that our pull request comment has a link to the same dns name as our chat application however this approach presents a problem because if the task were to restart again due to a network fault server failure or an application error a new network interface would be provided provisioned for the new task this new network interface would have a different dns name so our comment on the pull request would no longer have an accurate link one solution to this problem is to use an application load balancer all this is an amazon product that acts as a layer 7 load balancer that allows it to route traffic based on the host name of the url rather than just the ip each task can be registered to the application load balancer such that the host name of the url routes the correct task so now even if the task for chat app 14 restarts it will re-register itself to the load balancer ensuring our links never break so that wraps up the technical overview of gander but let's let's go back over the architecture we just covered on a pull request we trigger our workflows on github servers to build a container image of the application server this is then pushed to amazon's infrastructure and a review app with the database and application server is started with its data persisted to efs this review app is then registered to the load balancer allowing easy routing so what does this mean for the developer using gander after our developer installs the gander cli and runs the setup and initialize commands every pull request that will trigger a github workflow that builds and deploys an isolated full stack review app automatically to amazon infrastructure this review app will give a chance for non-technical stakeholders to chime in on the code review process ultimately increasing development velocity by shortening this feedback loop so to cover some future work we plan to add support for different types of databases we want to add support for arbitrary startup scripts and we want to add support for rail style migrations where runtime is required for exceeding the database so thank you very much for attending our presentation we'll be sticking around for a few minutes if any of you have any questions please drop them in the q a section okay so i'll read you the questions there's a question from cody he asked how hard would this be to expand for running on gcp google cloud and or supporting other databases like my sql  and so on um to answer number one it would be pretty difficult because a lot of our solutions are pretty baked into amazon's infrastructure i'm sure you can do something similar on google cloud but right now we're using a lot of amazon specific tooling like cloud formation and uh you know just amazon specific implementations as for other databases that would just require extra configuration because right now we just assume postgres i'm not quite sure how hard that would be though yeah to chime in on that um a lot of the ecs configuration that we wrote for gander um kind of relies on the specific mechanisms that the docker public postgres image uses um so supporting other databases would pretty much be a matter of just kind of researching what those database images do and what they expect like what files they expect um how to how to run scripts with them and that pretty much would be involved in that okay next question from rodney for each person what was the most interesting part of this project for you uh i can go first i guess um yeah the most interesting part probably was seeding the databases um so it was it was a whole journey just figuring out how to get the databases to run along with the application but once we had that um we then had the problem that we hadn't thought about before of um how do we actually get a user's schema and seed data onto that database so that it's up and running and ready for when they want to do any testing and um we ended up having to do kind of a a roundabout solution for that that we don't really get into detail in the presentation but shameless plug look out for our write-up that we'll be publishing very soon and um we'll talk about that more there that was um for me for me i think the most interesting part was working with github actions like it's really cool uh seeing everything just launch and i don't know event driven architectures are just really interesting so it was it was fun to work on that bit even though the testing did kind of get kind of tedious you know you have to make a pull request wait five minutes check it wait five minutes you know there's a lot of waiting in there so those debugging sessions ran a little long but that was the most interesting part for me and i was you know i all of us might say that seeding the database was the most interesting part like sheila said just because that particular problem was so complex and interesting but there were a lot of interesting parts it's hard to pick one i enjoyed working with a lot of people might think i'm crazy but the aws cli it was just fun to and and fascinating to to provision all these sorts of aws architecture and all that was totally new to me so it was just um really exciting to learn everything they offer and i mean not everything but just everything that we used that they offer and uh get to know how to make it work uh with writing scripts and various options to make things happen that was that was very interesting and i guess since all of the interesting technical parts have been claimed um the on a different note i thought it was really interesting to see our group's evolution throughout all of capstone and through this project i felt like we all learned how to work well with each other and capitalize our strengths and weaknesses and lean on each other so that was a lot of fun another from cody how long would this take to build a review app with the large production rails application lots of code and lots of data we have re review apps at work for our react apps via reversal but not a rails monolith also this is incredible and if your mail stage can't look like a joke i can actually give the time to take to build a rails app it's about 10 minutes it takes kind of a while for buildback to run and it pulls a lot of images and that's part of it um but may i also just say stagehand is not a joke it just addresses a different problem very well yeah i agree with that it's kind of hard to answer uh with an exact number depending on how big the project is you know bigger projects take longer to build and a big part of that is waiting for the database to finish uh you know seeding yes might i just had the project for cody who remembers capstone um project says request bin so that gives you the scale of the rails application a lot of the app is rails okay the next question from julius at what scale would you say gander is suited for i'm imagining that the company that he has hundreds of prs and review apps per day could be more than what gender targets yeah actually um since we kind of went with the serverless option for all of the different like every fork in the road we kind of went with the um elastic choice particularly with fargate so we're the limitation for what kind of organization can use gander is more so like what kind of apps you're trying to preview um so if you remember it's pretty much it has to be pretty simple um it just has an api uh server and then a database server but as far as like how many pr's are running that's kind of just up to how much you want to spend yeah that's what i would say is the only reason that it would be difficult to use hundreds of i mean it can handle hundreds of prs and review apps because it's gonna scale up automatically it's just that we don't have the most cost-effective solution for that model because we chose fargate so if you were going to use if you had that many pr's and review apps you would probably want to go with ec2 because it would be cheaper to have you would have enough demand there to make it worthwhile that's what i would say yeah to add on to that i think the only limit here is uh i think there's like a concurrent job limit for github actions um but that might be lifted for the you know enterprise level um but yeah most everything that we touch scales essentially and definitely um yeah it depends on your wallet okay the next question from joe how well did you feel core prepared you for this project uh as this project is a capstone project i suppose capstone prepared them for the project however core prepared them for the capstone so and indirectly you could say it was very important but anyone wants to add something yeah nothing besides core and capstone um beforehand um so yeah i feel like it prepared me really well gave me the background i needed yeah i would say um the level of comfort you have with digging through dry documentation is um it's going to play a lot into at least it played a lot into this project because we basically read the aws stocks like a novel um to figure out how to build it so i would say that from the beginning like all the way in in like 101 you immediately learn the the skill of reading docs so i would say little things like that there's a lot of tiny skills that you might not think of that you pick up in core that those are the things that really shine and translate into these projects i think okay awesome next question from milto stella i apologize because i missed the first part but in essence have you built a container uh how how you built the container reconstruction system essentially eks no we did not build a container orchestration system we used something called aws ecs which is their container orchestration system kind of like a non-kubernetes version of eks yeah we kind of built on top of the container orchestration system that was already there another question how are you managing keeping the aws details safe secure which are being used to deploy the a thermal review apps ephemeral so the us joel's get uh entered into github secrets by the user so um the only place that they get stored besides the aws cli on the user's machine uh would be inside github secrets so they're as secure as the user's machine and as they believe github to be from justin just wondering how you came up with this idea great presentation stay tuned andy love you yeah we uh we were looking around at various uh topics like you know distributed tracing and testing serverless stuff and then we you know read stagehand we're like oh cool we could just stick a database on this that'd be pretty cool and then it turned out to be a pretty hard problem solved so we went with that did you implement any testing of this framework i imagine it would have been hard to test since a lot of things are based in infrastructure very hard to test yeah yeah pretty much we manually tested everything um we are trying to write some unit tests for some of the pieces of the cli that uh don't have to do with any cloud infrastructure but other than that it was kind of a manual process okay from daniel that was sweet do you only run the cloud native built back on that initialization is there an instance where the image of the app would need to change half through through development does this handle that um yeah so we do we do support uh changes halfway through like if you so if you push to an open pr um it will essentially the the event is called synchronize and what our app will do is dispose of the app and then rebuild it yeah so cloud native build packs will um will create a new image each time that happens yeah so do we you only run the cloud native build pack on app initialization um we don't like we have a gander init command which um just sets up some like environment variables and and uh and puts the workflow files in github but we don't run cloud native build packs on that point at that point we we use cloud native build packs on every pull request or on every push to an open pull request yeah did you consider making it a user option on each follow request whether to build the review app or not how did you come up to the decision to have every pr on the reefer get built uh we have considered that but um ultimately that would actually be a pretty easy thing to implement um essentially all we'd have to do is like add a flag that they could set like maybe there'd be a you know do not build thing they put in the comment and then we just have to listen for that um but we didn't uh implement that on this initial build julius is asking was this project written in go since gold was added to capstone he is curious to hear your impressions on it now the project's written in uh in node but uh we're testing some go apps to be built with it i do i do like the go language though it's very interesting i was a little weirded out by the fact that it's like not object oriented um but as far as statically typed languages go i think it's a fun one for sure how did you split responsibilities during the development process we pretty much um it was a rough process to figure out how to divide work up um we kind of we would do individual spikes which is just to say like small pieces of work some proof of concept things like that um and we would meet every morning and just kind of try to teach each other about the individual work that we'd done and how it would fit together to actually achieve the functionality that we wanted so it was kind of a i don't know if i really answered the question we also paired sometimes um really i feel like one of the most important things we did was have group meetings a lot with all four of us there yeah and and every day was kind of a new decision as to okay how are we going to split things up today who's going to work on what today and since we we did such a good job i feel communicating um meeting every morning for probably an hour and a half um and sometimes once a day at least yeah um we you know it feels like we spent almost as much time working on things all together all at the same time as we did dividing things up and so i think that was pretty effective um at least for us because we were all kind of knew what everybody was working on at any given time and were able to um just work as a team pretty well i think because of that uh there is a trial and error process to it yes yeah i guess that's the answer for the next question as well uh how was your interactions with your mentor and how you were able to leverage their expertise please go ahead sorry chris oh god um so our mentors come in mostly for guidance on the project narrative how we want to shape our presentation and write up um in terms of specific implementation questions our mentor you know would give his insight and try to poke holes in our thinking and that's really where he came in but um so it's just a lot of guidance and making sure that you know he's a great sanity check does anyone want to add anything else yeah the sanity check was a big big help um you know we could go and it was like we were in our own little bubble or making this right so it's really useful to be able to talk to someone with actual industry experience and say does this make sense is this actually useful and you know and final question what technologies did you guys use to build gander and is it possible to share github repo which i believe is not but um yes so the github repo it it will be available once we uh publish the write up which will happen in a week or two there will be a link to it on our write up page so shameless plug two be on the lookout for that and what technologies did we use um that was uh the two main technologies would be github actions and aws but then cloud native build packs was also really important um and the cli is written in node yeah yep yeah we used heroku's open command line interface framework it's pretty useful and another question i would say final do you feel confident in your job search after this project i would say so i guess several weeks i hope so yeah that's the goal awesome that's it some final words uh thank you all for attending the first capstone presentation of our cohort it's been an honor and an adventure and we're really excited to see the rest of the capstone series so be sure to check it out all right if anyone has any other questions you can hang us on slack or something thanks everyone awesome work thank you 